NATIVE=1      ; 1 = 6309 native mode, 0 = emulation mode

****************************************
* register position on stack after IRQ *
****************************************

***************
* Stack       *
*-------------*
* 6809   6309 *
* c:     PC   *
* b:          *
* a: PC  U    *
* 9:          *
* 8: U   Y    *
* 7:          *
* 6: Y   X    *
* 5:     DP   *
* 4: X   F    *
* 3: DP  E    *
* 2: B   B    *
* 1: A   A    *
* 0: CC  CC   *
***************

* define stack offset for native mode

#if NATIVE
   STOFF=2
#else
   STOFF=0
#endif

          SETDP   $20
          ORG     $2000

          STORE $c000, $4000, "MO5E.IMG"

SKIP1     MACRO                 ; Pour sauter 1 octet
          FCB     $21
          ENDM

SKIP2     MACRO                 ; Pour sauter 2 octets
          FCB     $8C
          ENDM

*         Macros d'appel du moniteur par SWI

CALL      MACRO   ARG1
          SWI
          FCB     ARG1$
          ENDM

JUMP      MACRO   ARG1
          SWI
          FCB     ARG1$+$80
          ENDM

******************************************
*                                        *
*             MEMORY MAP                 *
*                                        *
*  0000-1FFF  screen memory 2 x 8K       *
*  2000-20FF  BIOS  direct page          *
*  2100-21FF  BASIC direct page          *
*  2200-25A2  BASIC work space           *
*  25A3-9FFF  free memory 31K            *
*  A000-A7BF  disk controller ROM 2K     *
*  A7C0-A7C3  PIA 6821 system            *
*  A7C4-A7CB  free                       *
*  A7CC-A7CF  PIA 6821 game              *
*  A7D0-A7DF  controller mini-floppy     *
*  A7E0-A7E3  PIA 6821 printer interface *
*  A7E4-A7E7  lightpen                   *
*  A7E8-A7FF  free                       *
*  B000-EFFF  ROM cartridge 16K          *
*  C000-EFFF  BASIC ROM 12K              *
*  F000-FFF   BIOS ROM 4K                *
*                                        *
******************************************

*******************
* DISK CONTROLLER *
*******************

Boot_Error_Vector = $1e

IDDISK = $A000  ; Identificateur de reconnaissance du controleur.
DKCHK  = $A003  ; Checksum de l'identificateur de disque.
DKCONT = $A004  ; Point d'entree du controleur disque.
DKBOOT = $A007  ; Points d'entree disque
DKFMT  = $A00A
LECFA  = $A00D
RECFI  = $A010
RECUP  = $A013
ECRSE  = $A016
ALLOD  = $A019
ALLOB  = $A01C
MAJCL  = $A01F
FINTR  = $A022

***********************
* BIOS FUNCTION CODES *
***********************

MENU$  = $00
PUTC$  = $02    ; put character
FRM0$  = $04    ; select colour RAM
FRM1$  = $06    ; select screen RAM
BIIP$  = $08    ; beep
GETC$  = $0A    ; get character
KTST$  = $0C    ; keyboard test
DRAW$  = $0E    ; draw line
PLOT$  = $10    ; plot dot
CHPL$  = $12    ; character plot
GETP$  = $14    ; get point
LPIN$  = $16    ; light pen input
GETL$  = $18    ; light pen
GETS$  = $1A    ; get character
JOYS$  = $1C    ; joystick
NOTE$  = $1E    ; play note
K7CO$  = $20    ; cassette controller
K7MO$  = $22    ; cassette motor
PRCO$  = $24    ; print controller
DKCO$  = $26    ; disk controller
DKBO$  = $28    ; disk boot
DKFM$  = $2A    ; disk format
ALLB$  = $2C    ; allocate block
ALLD$  = $2E    ; create file
ECRS$  = $30    ; write sector
FINT$  = $32    ; close write file
LECF$  = $34    ; load FAT
MAJC$  = $36    ; update cluster
RECF$  = $38    ; open file
RECP$  = $3A    ; delete file

RIMA    = 40    ; right margin

********************
* BIOS direct page *
********************

TERMIN  = $2000 ; table of line terminators
PIXMOD  = $2019 ; 0 = BG drawing, else FG drawing

Wpt_Row = $201a ; Wpt_Row/Row = pointer to row terminator
Row     = $201b ; current row    [0..24]
Col     = $201c ; current column [0..39]

Wpt_Top = $201d ; Wpt_Top/Win_Top = pointer to top row terminator
Win_Top = $201e ; window top row
Wpt_Bot = $201f ; Wpt_Bot/Win_Bot = pointer to bottom row terminator
Win_Bot = $2020 ; window bottom row

SCRPT   = $2021 ; Pointeur d'ecran.
CAPSLK  = $2023 ; 0 = no CAPS lock
AUTRPT  = $2024 ; 0 = auto repeat flag
ENACUR  = $2025 ; 1 = cursor enabled
DISBUZ  = $2026 ; 1 = buzzer disabled
BLOCZ   = $2027 ; Bloc de deux zeros pour initialisations.
FORME   = $2029 ; Couleur PLOT et DRAW [-16,+15]
FR_202a = $202a
COLOUR  = $202b ; p B V R p B V R : registre de couleur.
                ;  0:black      1:red       2:green       3:yellow
                ;  4:blue       5:magenta   6:cyn         7:white
                ;  8:grey       9:lightred 10:lightgreen 11:lightyellow
                ; 12:lightblue 13:violet   14:lightblue  15:orange
CLOCK   = $202c ; 4 byte jiffy clock
EFCMPT  = $2030 ; Flag de clignotement curseur.
FR_2031 = $2031
PLOTX   = $2032 ; Dernier plot, abscisse.
PLOTY   = $2034 ; Dernier plot, ordonnee.
CHDRAW  = $2036 ; ASCII caractere utilise dans PSET,LINE et BOX "CH"
KEY     = $2037 ; Touche clavier
CMPTKB  = $2038 ; Repeats du clavier.
TEMPO   = $2039 ; Tempo general de l'interpreteur musical.
DUREE   = $203b ; Duree de la note.
TIMBRE  = $203d ; Timbre.
OCTAVE  = $203e ; Octave.
PR.OPC  = $2040 ; Mot de code pour l'imprimante parallele
PR.STA  = $2041 ; Status courant de l'imprimante parallele
TEMP    = $2042 ; Registre temporaire de travail
DELTAX  = $2044 ; plot variable
DELTAY  = $2046 ; plot variable

****************************
* DISK CONTROLLER REGISTER *
****************************

DK.OPC  = $2048 ; MOT DE COMMANCE : Code d'instruction utilise par DKCONT
                ; pour appeler une commande parametree par les registres
                ; qui suivent.
DK.DRV  = $2049 ; No du disque selecte
DK.TRK  = $204a ; No de piste
DK.SEC  = $204c ; No de secteur
DK.NUM  = $204d ; Entrelacement au formatage
DK.STA  = $204e ; MOT D'ETAT : Contient le code d'erreur en cas d'insucces
                ; de la commande signale par CY = 1 en sortie de DKCONT.
DK.BUF  = $204f ; I/O BUFFER POINTER
TRACK0  = $2051 ; Position courante de la tete sur le drive 0
TRACK1  = $2053 ; Position courante de la tete sur le drive 1
TRACK2  = $2055 ; Position courante de la tete sur le drive 2
TRACK3  = $2057 ; Position courante de la tete sur le drive 3

*****************************
* AUTRES REGISTRES MONITEUR *
*****************************

SEQUCE    = $2059 ; ESC and RS sequences

FR_205b   = $205b
FR_205c   = $205c
FR_205d   = $205d

SWI1PT    = $205e ; Pointeur SWl utilisateur ou SWITCH + flag
TIMEPT    = $2061 ; Pointeur interrupt timer utilisateur + flag MO9.
IRQPT     = $2064 ; Pointeur IRQ utilisateur + flag MO9.
FIRQPT    = $2067 ; Pointeur FIRQ utilisateur + flag MO9.
SIMUL     = $206a ; Pointeur sur la table des entrees moniteur+ flag MO9
CHRPTR    = $206d ; Pointeur sur la table de decodage clavier + flag MO9
USERAF    = $2070 ; Pointeur sur le gen. caracteres utilisateur+flag MO9
GENPTR    = $2073 ; Pointeur sur le generateur de caracteres G0 + flag "
LATCLV    = $2076 ; Latence clavier programmable
GRCODE    = $2077 ; Mot de code pour le mode graphique imprimante
DECALG    = $2078 ; Decalage du light-pen en resolution "points".
RGMON     = $2079 ; Prochaine position utilisable
DEFDST    = $207f ; Flag de simple ou double densite
DKFLG     = $2080 ; Flag de presence controleur disque

SD_CMD    = $208e ; SD command
SD_LBA    = $208f ; LBA (4 bytes)

COLDST    = $20cc ; top of stack during cold start

MONBUF    = $20d0 ; Monitor buffer
MON_PC    = MONBUF
MON_DP    = MONBUF+2
MON_CC    = MONBUF+3
MON_A     = MONBUF+4
MON_B     = MONBUF+5
MON_W     = MONBUF+6
MON_X     = MONBUF+8
MON_Y     = MONBUF+10
MON_U     = MONBUF+12
MON_S     = MONBUF+14
MON_V     = MONBUF+16
MON_MEM   = MONBUF+18

*******************
* PIA 6821 SYSTEM *
*******************

PRA     = $A7C0 ; REGISTRE DE DONNEES DU PORT A
                ; PA0 (output) Forme
                ; PA1 (output) Rouge Tour.
                ; PA2 (output) Vert Tour.
                ; PA3 (output) Bleu Tour.Forme
                ; PA4 (output) 1/2 teinte tour: 0=sature,1=pastel
                ; PA5 (input) interruption photostyle
                ; PA6 (output) ecriture cassette
                ; PA7 (input) lecture cassette

PRB     = PRA+1 ; REGISTRE DE DONNEES DU PORT B
                ; PBO (output) Son.
                ; PB1,PB2,PB3 (output) Matricaqe clavier:74 LS 138
                ; PB4,PB5,PB6 (output) Dematricaqe clavier:74 LS 151
                ; PB7 (output) Lecture clavier

CRA     = PRA+2 ; REGISTRE DE CONTROLE DU PORT A
                ; CA1 (input) LP
                ; CA2 (output) Commande moteur cassette

CRB     = PRA+3 ; REGISTRE DE CONTROLE DU PORT B
                ; CBl (input) Interrupt 50 HZ.
                ; CB2 (output) Incrustation: 0 mode incruste, 1 normal

*****************
* PIA 6821 GAME *
*****************

PRA1    = $A7CC ; REGISTRE DE DONNEES DU PORT A1
                ; PA0-7 (input) Lecture directions joysticks : 0 Nord0,
                ; 1 Sud0, 2 West0, 3 Est0, 4 Nord1, 5 Sud1, 6 West1
                ; 7 Est1

PRB1    = PRA1+1; REGISTRE DE DONNEES DU PORT B1
                ; PB0-5 (input) Convertisseur digital/analogique sur 6 bits
                ; PB6 (input) Action joystick 0
                ; PB7 (input) Action joystick 1

CRA1    = PRA1+2; REGISTRE DE CONTROLE PORT A1
                ; CA1 (input) Action joystick 0

CRB1    = PRA1+3; REGISTRE DE CONTROLE PORT B1
                ; CB1 (input) Action joystick 1

********************************
* PIA 6821 PARALLEL CENTRONICS *
********************************

PRA2    = $A7E0 ; REGISIRE DE DONNEES PORT A2
                ; PA0 (output) Receive data
                ; PAl (output) Clear to send
                ; PA5 (input) Request to send
                ; PA6 (input) Data terminal ready
                ; PA7 (input) Transmit data

PRB2    = PRA2+1; REGISTRE DE DONNEES PORT B2
                ; PB0-7 (output) Donnees paralleles

CRA2    = PRA2+2; REGISTRE DE CONTROLE PORT A2
                ; CA1 (input) Request to send

CRB2    = PRA2+3; REGISTRE DE CONTROLE PORT B2
                ; CB1 (input} Acknowledge
                ; CB2 (output) Strobe

LP4     = PRA2+4; Compteur
LP5     = PRA2+5; Compteur
LP6     = PRA2+6; INIL + LT3
LP7     = PRA2+7; INIT

***********************
* ASCII CONTROL CODES *
***********************

* NUL   = $00 ; Ctrl @  NULL
* SOH   = $01 ; Ctrl A  START OF HEADING
* SOX   = $02 ; Ctrl B  START OF TEXT
  ETX   = $03 ; Ctrl C  END OF TEXT : BREAK
* EOT   = $04 ; Ctrl D  END OF TRANSMISSION
* ENQ   = $05 ; Ctrl E  ENQUIRE
* ACK   = $06 ; CTRL F  ACKNOWLEDGE
  BEL   = $07 ; Ctrl G  BELL
  BS    = $08 ; Ctrl H  BACKSPACE
* HT    = $09 ; Ctrl I  HORIZONTAL TABULATION
  LF    = $0A ; Ctrl J  LINE FEED
  VT    = $0B ; Ctrl K  VERTICAL TABULATION
  FF    = $0C ; Ctrl L  FORM FEED
  CR    = $0D ; Ctrl M  CARRIAGE RETURN
* SO    = $0E ; Ctrl N  SHIFT OUT
* SI    = $0F ; Ctrl O  SHIFT IN
* DC0   = $10 ; Ctrl P  DEVICE CONTROL 0
  DC1   = $11 ; Ctrl Q  DEVICE CONTROL 1
* DC2   = $12 ; Ctrl R  DEVICE CONTROL 2
* DC3   = $13 ; Ctrl S  DEVICE CONTROL 3
  DC4   = $14 ; Ctrl T  DEVICE CONTROL 4
* NAK   = $15 ; Ctrl U  NON ACKNOWLEDGE
* SS2   = $16 ; Ctrl V
* ETB   = $17 ; Ctrl W  END OF TRANSMISSION BLOCK
  CAN   = $18 ; Ctrl X  Erase_EOL
  ESC   = $1B ; ESCAPE
* RS    = $1E ; RECORD SEPARATOR
  US    = $1F ; UNIT SEPARATOR

  QUOTE = $22 ; "

***********************
* PARAMETRES MUSICAUX *
***********************

* PO    = '0'
* DO    = '1'
* DOD   = '2'
* REB   = '3'
* RE    = '3'
* RED   = '4'
* MIB   = '4'
* MI    = '5'
* FA    = '6'
* FAD   = '7'
FR_205a   = $205a
* SOLB  = '7'
* SOL   = '8'
* SOLD  = '9'
* LAB   = '9'
* LA    = ':'
* LAD   = ';'
* SIB   = ';'
* SINAT = '>'
* DOB   = '<'
* UT    = '='

************************************
* PARAMETRES IMPRIMANTE CENTRONICS *
************************************

PR.WRC  =  %00000001 ; ECRIRE UN OCTET
PR.CLS  =  %00010000 ; CLOSE
PR.CPY  =  %00000010 ; SCREEN GRAPHIC COPY (CENTRONICS)
PR.OPP  =  %00000100 ; OPEN EN WRITE PARALLEL (CENTRONICS)
PR.NRD  =  %00001000 ; DEVICE NOT READY

**********
* DIVERS *
**********

KBSEC   =  $07       ; Latence clavier, environ 1 seconde.
COLINT  =  %01000110 ; Bleu sur cyan, couleurs saturees
INPRLP  =  $070C     ; MSB = code mode qraphique imprimante, LSB = decalage
                     ;    light-pen par defaut. (Les registres correspondants
                     ;    sont consecutifs)
CBASE   =  $40       ; Adresse de base couleur ( sequences escape )
FBASE   =  $50       ; Adresse de base fond ( sequences escape )
TBASE   =  $60       ; Adresse de base tour ( sequences escape )

***********************
* ADRESSES DE L'ECRAN *
***********************

CURSOR  =  $0118    ; Origine de la 1ere rangee
TELCUR  =  $0258    ; Origine de Ia 2eme rangee
ORGROL  =  $0140    ; Origine du Rollup
ORGDBL  =  $028C    ; Origine du Rollup double hauteur
DERCUR  =  $1F18    ; Curseur sur la derniere rangee
DIRECT  =  $20      ; Page zero moniteur


*******************************************************
*     CONTROLEUR HD6843 COUPLE AVEC 4 MINI-FLOPPY     *
* ENSEMBLE DES EQUATES DES ROUTINES D'ACCES PHYSIQUES *
*******************************************************

CRINIT = %00000001 ; controller reset
                   ; possible errors: CONTROLLER INOPERABLE.
SSREAD = %00000010 ; SINGLE SECTOR READ : Lecture d'un secteur. Erreurs pos-
                   ; sibles : TRACK ERROR, SECTOR ERROR, DATA ERROR, NON
                   ; FORMATTED DISQUETTE, DRIVE NOT READY.
SSWRIT = %00001000 ; SINGLE SECTOR WRITE : Ecriture d'un secteur. Meme er-
                   ; reurs que SSR avec en plus WRITE PROTECTED.
STZERO = %00100000 ; SEEK TRACK ZERO = Retour en piste O. Erreurs possibles
                   ; DRIVE NOT READY, NON FORMATTED DISQUETTE.
SEEK   = %01000000 ; SEEK : Acces a une piste. Erreurs possibles : DRIVE NOT
                   ; READY, NON FORMATTED DISQUETTE.
VERIFY = %10000000 ; VERIFY OPTION : Option verification sur les acces en
                   ; ecriture. Erreur specifique : VERIFY ERROR.

********************
* NUMEROS DE DRIVE *
********************

DRV0   = %00000001 ; DRIVE 0
DRV1   = %00000010 ; DRIVE 1
DRV2   = %00000100 ; DRIVE 2
DRV3   = %00001000 ; DRIVE 3

******************
* CODES D'ERREUR *
******************

WRTPR  = %00000001 ; WRITE PROTECTED
TRKER  = %00000010 ; TRACK ERROR : Erreur d'acces piste lors d'une tentative
                   ; de lecture ou d'ecriture. Implique que I'ID est correct
SCTER  = %00000100 ; SECTOR ERROR : Erreur sur secteur ID, soit qu'il soit
                   ; illisible ou qu'il y ait une erreur de CRC. La piste
                   ; est cependant la bonne.
DATER  = %00001000 ; DATA ERROR : Erreur sur les data : soit le DAM est
                   ; absent, il y a eu un overflow ou underflow, ou le CRC
                   ; est errone.
DRNRD  = %00010000 ; DRIVE NOT REAOY : La commande moteur renvoit toujours
                   ; un etat OFF, ou l'INDEX ne passe pas.
VRFER  = %00100000 ; VERIFY ERROR : L'option verification a amene a constater
                   ; une difference.
CNTER  = %01000000 ; CONTROLLER INOPERABLE : Impossibilite de ramener le
                   ; controleur a un etat voulu.
FMTER  = %10000000 ; NON FORMATTED DISQUETTE : ID de la disquette illisibles
UTRK   = $8000     ; UNKNOWN TRACK FLAG

WRMTST = $2200

**********************
* BASIC token values *
**********************

TK_END     = $80
TK_FOR     = $81
TK_NEXT    = $82
TK_DATA    = $83
TK_DIM     = $84
TK_READ    = $85

TK_GO      = $87
TK_RUN     = $88
TK_IF      = $89
TK_RESTORE = $8a
TK_RETURN  = $8b
TK_REM     = $8c
TK_APO     = $8d
TK_STOP    = $8e
TK_ELSE    = $8f
TK_TRON    = $90
TK_TROFF   = $91
TK_DEFSTR  = $92
TK_DEFINT  = $93
TK_DEFSNG  = $94

TK_ON      = $96
TK_IDSK    = $97
TK_ERROR   = $98
TK_RESUME  = $99
TK_AUTO    = $9a
TK_DELETE  = $9b
TK_LOCATE  = $9c
TK_CLS     = $9d
TK_CONSOLE = $9e
TK_PSET    = $9f
TK_MONIT   = $a0
TK_SDDSK   = $a1
TK_EXEC    = $a2
TK_BEEP    = $a3
TK_COLOR   = $a4
TK_LINE    = $a5
TK_BOX     = $a6

TK_ATTRB   = $a8
TK_DEF     = $a9
TK_POKE    = $aa
TK_PRINT   = $ab
TK_CONT    = $ac
TK_LIST    = $ad
TK_CLEAR   = $ae
TK_DOS     = $af

TK_NEW     = $b1
TK_SAVE    = $b2
TK_LOAD    = $b3
TK_MERGE   = $b4
TK_OPEN    = $b5
TK_CLOSE   = $b6
TK_INPEN   = $b7
TK_PEN     = $b8
TK_PLAY    = $b9
TK_TAB     = $ba
TK_TO      = $bb
TK_SUB     = $bc
TK_FN      = $bd
TK_SPC     = $be
TK_USING   = $bf
TK_USR     = $c0
TK_ERL     = $c1
TK_ERR     = $c2
TK_OFF     = $c3
TK_THEN    = $c4
TK_NOT     = $c5
TK_STEP    = $c6
TK_PLUS    = $c7
TK_MINUS   = $c8
TK_MULT    = $c9
TK_DIV     = $ca
TK_POT     = $cb
TK_AND     = $cc
TK_OR      = $cd
TK_XOR     = $ce
TK_EQV     = $cf
TK_IMP     = $d0
TK_MOD     = $d1
TK_AT      = $d2
TK_GT      = $d3
TK_EQ      = $d4
TK_LT      = $d5
TK_SGN     = $d6
TK_INT     = $d7
TK_ABS     = $d8
TK_FRE     = $d9
TK_SQR     = $da
TK_LOG     = $db
TK_EXP     = $dc
TK_COS     = $dd
TK_SIN     = $de
TK_TAN     = $df
TK_PEEK    = $e0
TK_LEN     = $e1
TK_STR$    = $e2
TK_VAL     = $e3
TK_ASC     = $e4
TK_CHR$    = $e5
TK_EOF     = $e6
TK_CINT    = $e7


TK_FIX     = $ea
TK_HEX$    = $eb

TK_STICK   = $ed
TK_STRIG   = $ee
TK_GR$     = $ef
TK_LEFT$   = $f0
TK_RIGHT$  = $f1
TK_MID$    = $f2
TK_INSTR   = $f3
TK_VARPTR  = $f4
TK_RND     = $f5
TK_INKEY$  = $f6
TK_INPUT   = $f7
TK_CSRLIN  = $f8
TK_POINT   = $f9
TK_SCREEN  = $fa
TK_POS     = $fb
TK_PTRIG   = $fc

*********************
* BASIC DIRECT PAGE *
*********************

ENDCHR   = $2100  ; scan quotes flag
CHARAC   = $2101  ; search delimiter
COUNT    = $2102  ; index /  counter
GARBFL   = $2103  ; garbage collection flag
INPFLG   = $2104  ; input mode flag
MOTOR    = $2105  ; motor status 0:off 1:on
TEMPPT   = $2106  ; temporary pointer
TEMPST   = $2108  ; last descriptor stack pointer
XSAV     = $210a  ; save X regitser
TMPTR1   = $210c  ; save X in Search_Stack
ACC_M1   = $210e  ; accumulator C mantissa MSB
ACC_M2   = $210f  ; accumulator C mantissa
ACC_M3   = $2110  ; accumulator C mantissa LSB

STACKS   = $2111  ; temporary storage in Mem_Avail
TXTTAB   = $2113  ; start of free BASIC RAM
VARTAB   = $2115
VAREND   = $2117
FRETOP   = $2119
STRTAB   = $211b
FRESPC   = $211d
MEMSIZ   = $211f

TRAPLN   = $2121
ENDFLG   = $2123
CURLIN   = $2124
OLDLIN   = $2126
LINNUM   = $2128
CONPTR   = $212a
OLDTXT   = $212c
DATTXT   = $212e

DATPTR   = $2130
INPPTR   = $2132
VAR1ST   = $2134
VANLEN   = $2136
VARPTR   = $2137
TYPSIZ   = $2139
ARYDIS   = $213a
VARDES   = $213b
PRECED   = $213d
INDEXA   = $213e
CRUCNT   = $213f

INDEXB   = $2140
INDEXC   = $2142
INDEXD   = $2144
FAC3_EX  = $2146
SQMFLG   = $214a     ; show question mark

ACA_SZ   = $214b
ACA_EX   = $214c
ACA_M1   = $214d
ACA_M2   = $214e
ACA_M3   = $214f
ACA_SI   = $2150
ACA_RN   = $2151

COEFCT   = $2152
DSA_LEN  = $2153
DSA_ADR  = $2154
FPCARY   = $2156

ACB_SZ   = $2157
ACB_EX   = $2158
ACB_M1   = $2159
ACB_M2   = $215a
ACB_M3   = $215b
ACB_SI   = $215c

SGNEOR   = $215d
COEFPT   = $215e

RESSGN   = $2160
IFCTR    = $2162
Haystack = $2163      ; INSTR variable
Needle   = $2164      ; INSTR variable
LOOPV    = $2165      ; loop value in FOR/NEXT
Range_F  = $2167
Range_T  = $2169
NXTFLG   = $216b
LPBODY   = $216c      ; index to end of FOR statement
TRCFLG   = $216e
ERRNO    = $216f

ERRLIN   = $2170
SP_DEF   = $2172
SAVTXT   = $2174      ; save TXTPTR for RESUME
Use_Dot  = $2176      ; set by PRINT USING
Use_Befo = $2177      ; digits before decimal point
Use_Flag = $2178      ; set by PRINT USING
                      ; bit 0 = use exponential form
                      ; bit 3 = use '+' sign
                      ; bit 5 = use '*' as leading zeroes
                      ; bit 7 =
CHANNEL  = $2179
CINBFL   = $217a      ; console input buffer status
DEVCFW   = $217b      ; TAB field width
DEVLCF   = $217c      ; last TAB zone
DEVPOS   = $217d      ; print position
COLMAX   = $217e      ; physical line length
PROTECT  = $217f      ; BASIC program protection

STR_B1   = $2180
STR_B2   = $2181
STR_B3   = $2182
FR_2184  = $2184
FR_2185  = $2185
FR_2186  = $2186
FR_2187  = $2187
FR_2188  = $2188
PRTCOL   = $2189
PRT_MARGIN = $218a
PRT_TAB_END = $218b
PRTBUSY = $218c
INPSTD = $218d
INPDEV = $218e
PRTDEV = $218f
ACTDEV = $2190
SAVDEV = $2191
PROCHK = $2192        ; FF = protection checked
CASS_MODE = $2193
Bytes_Read = $2194
CASS_BUSY = $2195
D2196 = $2196
D2197 = $2197
CASS_Msg_Flag = $2198
LDRUN = $2199
MRGFLG = $219a   ; MERGE flag
LOADMF = $219b   ; LOADM flag
RUNADR = $219c   ; RUN address after LOAD
WRMFLG = $219e
FR_219f = $219f
BOXFILL = $21a0
TOPRAM = $21a1
ACD_M1 = $21a3
ACD_M2 = $21a4
ACD_M3 = $21a5
STOPFLG = $21a6
STR_TERM_INDEX = $21a7
STR_TERM_VALUE = $21a9
USRCHR = $21aa
FREE_21ab = $21ab

* Routines are copied starting from ROM_CHRGET

CHRGET                 = $21ac
CHRGOT                 = $21b2
TXTPTR                 = $21b3
ISNUM                  = $21b9
Need_Comma             = $21c2
Test_ACA_Type          = $21c5
Set_Type_Flags         = $21c7
Dec_TXTPTR             = $21ca
Eval_Numeric           = $21cd
Assert_ACA_Numeric     = $21d1
Assert_ACA_Desc        = $21d6
Dec_Eval_Exp           = $21d9
Eval_Expression        = $21db
Need_Right             = $21de
Need_B                 = $21e0
CHROUT                 = $21e3
Byte_Var               = $21e6
Cast_ACA_Real          = $21e9
B_To_ACA               = $21ec
D_To_ACA               = $21ed
Parse_Name             = $21f0
Device_Context         = $21f3
Illegal_Quantity       = $21f6
Syntax_Error           = $21f9
Print_Error_B          = $21fb
ZERO_W                 = $21fe

* end of direct page routines

Crunch_Tab    = $2201 ; 2 crunch structures of size 5
BASIC_AUTO    = $2236 ; JMP Syntax_Error
Oper_Error    = $2239 ; JMP Syntax_Error
FUNC_HEX      = $223c ; JMP Syntax_Error
EXEC_Pointer  = $223f
Load_Error    = $2257
Mode_Error    = $225a
Close_Error   = $225d
M2260         = $2260
M2263         = $2263
M2266         = $2266
M2269         = $2269
J226c         = $226c ; JMP Device_Not_Present
J226f         = $226f
Syntax_Check  = $2272
Get_FN        = $2275
Hook_2278   = $2278
Hook_227b         = $227b
Hook_227e         = $227e
Hook_2281         = $2281
Hook_2284         = $2284
Hook_2287         = $2287
Hook_228a         = $228a
Hook_228d         = $228d

CASS_FN       = $2291

Device_Tab    = $23c8  ; device routines for open/close etc.
Channel_Tab   = $23e8  ; open channels 0 - 16
FILENAME      = $23fa

FILEDESC      = $2406
SEED          = $2427  ; random number seed
IMPLICIT      = $242b  ; type for 'A' to 'Z'
KBDBUF        = $2445  ; keyboard buffer
BUF_LNK       = $244d
BUF_NUM       = $244f
BUF_TXT       = $2451
Ext_Token     = $248e  ; extended token list

Format_Buffer = $2556

GRBX          = $257d  ; keep together
GRBY          = $257f
GRAX          = $2581
GRAY          = $2583

STRSTK        = $2585
STREOS        = $25a3

RAMBOT        = $25a3

        ORG      $c000
        SETDP    $21

************************
BASIC_Function_A ; $c000
************************

          FDB   FUNC_SGN       ; $00
          FDB   FUNC_INT       ; $01
          FDB   FUNC_ABS       ; $02
          FDB   FUNC_FRE       ; $03
          FDB   FUNC_SQR       ; $04
          FDB   FUNC_LOG       ; $05
          FDB   FUNC_EXP       ; $06
          FDB   FUNC_COS       ; $07
          FDB   FUNC_SIN       ; $08
          FDB   FUNC_TAN       ; $09
          FDB   FUNC_PEEK      ; $0a
          FDB   FUNC_LEN       ; $0b
          FDB   FUNC_STR       ; $0c
          FDB   FUNC_VAL       ; $0d
          FDB   FUNC_ASC       ; $0e
          FDB   FUNC_CHR       ; $0f
          FDB   FUNC_EOF       ; $10
          FDB   FUNC_CINT      ; $11
          FDB   Cast_ACA_Real  ; $12
          FDB   Syntax_Error   ; $13
          FDB   FUNC_FIX       ; $14
          FDB   FUNC_HEX       ; $15
          FDB   Syntax_Error   ; $16
          FDB   FUNC_STICK     ; $17
          FDB   FUNC_STRIG     ; $18
          FDB   FUNC_GR        ; $19
          FDB   FUNC_LEFT      ; $1a
          FDB   FUNC_RIGHT     ; $1b
          FDB   FUNC_MID       ; $1c
          FDB   FUNC_INSTR     ; $1d
          FDB   FUNC_VARPTR    ; $1e
          FDB   FUNC_RND       ; $1f
          FDB   FUNC_INKEY     ; $20
          FDB   FUNC_INPUT     ; $21
          FDB   FUNC_CSRLIN    ; $22
          FDB   FUNC_POINT     ; $23
          FDB   FUNC_SCREEN    ; $24
          FDB   FUNC_POS       ; $25
          FDB   FUNC_PTRIG     ; $26

*****************
OP_Switch ; $c04e
*****************

          FCB   "\""    , (TXTPTR_String   - Neg_Operand) & $ff;
          FCB   "&"     , (String_To_Float - Neg_Operand) & $ff;
          FCB   "("     , (Eval_In_Pars    - Neg_Operand) & $ff;
          FCB   "."     , (String_To_Float - Neg_Operand) & $ff;
          FCB   TK_ERL  , (ERRLIN_To_Real  - Neg_Operand) & $ff;
          FCB   TK_ERR  , (ERRNO_To_Real   - Neg_Operand) & $ff;
          FCB   TK_NOT  , (Not_Operand     - Neg_Operand) & $ff;
          FCB   TK_PLUS , (Get_Operand     - Neg_Operand) & $ff;
          FCB   TK_MINUS, (Neg_Operand     - Neg_Operand) & $ff;
          FCB   $ff     , (Call_Function   - Neg_Operand) & $ff;

*****************
VAR_SIZES ; $c062
*****************

          FCB   4   ; $21 = ! = real
          FCB   0   ; $22 = "
          FCB   0   ; $23 = #
          FCB   3   ; $24 = $ = string
          FCB   2   ; $25 = % = integer

**************
BIN_OP ; $c067
**************

          FCB   $79,OP_PLUS
          FCB   $79,OP_MINUS
          FCB   $7c,OP_MULT
          FCB   $7c,OP_DIV
          FCB   $7f,OP_EXP
          FCB   $50,OP_AND
          FCB   $46,OP_OR
          FCB   $3c,OP_EOR
          FCB   $32,OP_EQV
          FCB   $28,OP_IMP
          FCB   $7a,OP_MOD
          FCB   $7b,OP_AT
          FCB   $64,OP_GT
          FCB   $64,OP_EQ
          FCB   $64,OP_LT

*******************
COMPARE_TAB ; $c094
*******************

          FCB   TK_GT,TK_EQ
          FDB   OP_GE
          FCB   TK_LT,TK_EQ
          FDB   OP_LE
          FCB   TK_LT,TK_GT
          FDB   OP_NE

*********************
KEYWORD_TAB_A ; $c0a0
*********************

          FCB   "END"^     ; $80
          FCB   "FOR"^     ; $81
          FCB   "NEXT"^    ; $82
          FCB   "DATA"^    ; $83
          FCB   "DIM"^     ; $84
          FCB   "READ"^    ; $85
          FCB   $ff        ; $86
          FCB   "GO"^      ; $87
          FCB   "RUN"^     ; $88
          FCB   "IF"^      ; $89
          FCB   "RESTORE"^ ; $8a
          FCB   "RETURN"^  ; $8b
          FCB   "REM"^     ; $8c
          FCB   "'"^       ; $8d
          FCB   "STOP"^    ; $8e
          FCB   "ELSE"^    ; $8f
          FCB   "TRON"^    ; $90
          FCB   "TROFF"^   ; $91
          FCB   "DEFSTR"^  ; $92
          FCB   "DEFINT"^  ; $93
          FCB   "DEFSNG"^  ; $94
          FCB   $ff        ; $95
          FCB   "ON"^      ; $96
          FCB   "IDSK"^    ; $97
          FCB   "ERROR"^   ; $98
          FCB   "RESUME"^  ; $99
          FCB   "AUTO"^    ; $9a
          FCB   "DELETE"^  ; $9b
          FCB   "LOCATE"^  ; $9c
          FCB   "CLS"^     ; $9d
          FCB   "CONSOLE"^ ; $9e
          FCB   "PSET"^    ; $9f
          FCB   "MONIT"^   ; $a0
          FCB   "SDDSK"^   ; $a1
          FCB   "EXEC"^    ; $a2
          FCB   "BEEP"^    ; $a3
          FCB   "COLOR"^   ; $a4
          FCB   "LINE"^    ; $a5
          FCB   "BOX"^     ; $a6
          FCB   $ff        ; $a7
          FCB   "ATTRB"^   ; $a8
          FCB   "DEF"^     ; $a9
          FCB   "POKE"^    ; $aa
          FCB   "PRINT"^   ; $ab
          FCB   "CONT"^    ; $ac
          FCB   "LIST"^    ; $ad
          FCB   "CLEAR"^   ; $ae
          FCB   "DOS"^     ; $af
          FCB   $ff        ; $b0
          FCB   "NEW"^     ; $b1
          FCB   "SAVE"^    ; $b2
          FCB   "LOAD"^    ; $b3
          FCB   "MERGE"^   ; $b4
          FCB   "OPEN"^    ; $b5
          FCB   "CLOSE"^   ; $b6
          FCB   "INPEN"^   ; $b7
          FCB   "MON"^     ; $b8
          FCB   "PLAY"^    ; $b9
          FCB   "TAB("^    ; $ba
          FCB   "TO"^      ; $bb
          FCB   "SUB"^     ; $bc
          FCB   "FN"^      ; $bd
          FCB   "SPC("^    ; $be
          FCB   "USING"^   ; $bf
          FCB   "USR"^     ; $c0
          FCB   "ERL"^     ; $c1
          FCB   "ERR"^     ; $c2
          FCB   "OFF"^     ; $c3
          FCB   "THEN"^    ; $c4
          FCB   "NOT"^     ; $c5
          FCB   "STEP"^    ; $c6
          FCB   "+"^       ; $c7
          FCB   "-"^       ; $c8
          FCB   "*"^       ; $c9
          FCB   "/"^       ; $ca
          FCB   "^"^       ; $cb
          FCB   "AND"^     ; $cc
          FCB   "OR"^      ; $cd
          FCB   "XOR"^     ; $ce
          FCB   "EQV"^     ; $cf
          FCB   "IMP"^     ; $d0
          FCB   "MOD"^     ; $d1
          FCB   "@"^       ; $d2
          FCB   ">"^       ; $d3
          FCB   "="^       ; $d4
          FCB   "<"^       ; $d5

*********************
KEYWORD_TAB_B ; $c1cc
*********************

          FCB   "SGN"^    ; $d6
          FCB   "INT"^    ; $d7
          FCB   "ABS"^    ; $d8
          FCB   "FRE"^    ; $d9
          FCB   "SQR"^    ; $da
          FCB   "LOG"^    ; $db
          FCB   "EXP"^    ; $dc
          FCB   "COS"^    ; $dd
          FCB   "SIN"^    ; $de
          FCB   "TAN"^    ; $df
          FCB   "PEEK"^   ; $e0
          FCB   "LEN"^    ; $e1
          FCB   "STR$"^   ; $e2
          FCB   "VAL"^    ; $e3
          FCB   "ASC"^    ; $e4
          FCB   "CHR$"^   ; $e5
          FCB   "EOF"^    ; $e6
          FCB   "CINT"^   ; $e7
          FCB   $ff       ; $e8
          FCB   $ff       ; $e9
          FCB   "FIX"^    ; $ea
          FCB   "HEX$"^   ; $eb
          FCB   $ff       ; $ec
          FCB   "STICK"^  ; $ed
          FCB   "STRIG"^  ; $ee
          FCB   "GR$"^    ; $ef
          FCB   "LEFT$"^  ; $f0
          FCB   "RIGHT$"^ ; $f1
          FCB   "MID$"^   ; $f2
          FCB   "INSTR"^  ; $f3
          FCB   "VARPTR"^ ; $f4
          FCB   "RND"^    ; $f5
          FCB   "INKEY$"^ ; $f6
          FCB   "INPUT"^  ; $f7
          FCB   "CSRLIN"^ ; $f8
          FCB   "POINT"^  ; $f9
          FCB   "SCREEN"^ ; $fa
          FCB   "POS"^    ; $fb
          FCB   "PTRIG"^  ; $fc
          FCB   $00

*********************
Action_Switch ; $c25f
*********************

          FDB   BASIC_END
          FDB   BASIC_FOR
          FDB   BASIC_NEXT
          FDB   BASIC_DATA
          FDB   BASIC_DIM
          FDB   BASIC_READ
          FDB   Syntax_Error
          FDB   BASIC_GO
          FDB   BASIC_RUN
          FDB   BASIC_IF
          FDB   BASIC_RESTORE
          FDB   BASIC_RETURN
          FDB   BASIC_REM
          FDB   BASIC_REM
          FDB   BASIC_STOP
          FDB   BASIC_REM
          FDB   BASIC_TRON
          FDB   BASIC_TROFF
          FDB   BASIC_DEFSTR
          FDB   BASIC_DEFINT
          FDB   BASIC_DEFSNG
          FDB   Syntax_Error
          FDB   BASIC_ON
          FDB   BASIC_IDSK
          FDB   BASIC_ERROR
          FDB   BASIC_RESUME  ; $99
          FDB   BASIC_AUTO    ; $9a
          FDB   BASIC_DELETE
          FDB   BASIC_LOCATE
          FDB   BASIC_CLS
          FDB   BASIC_CONSOLE
          FDB   BASIC_PSET
          FDB   BASIC_MONITOR
          FDB   BASIC_SDDSK
          FDB   BASIC_EXEC
          FDB   BASIC_BEEP
          FDB   BASIC_COLOR
          FDB   BASIC_LINE
          FDB   BASIC_BOX
          FDB   Syntax_Error
          FDB   BASIC_ATTRB
          FDB   BASIC_DEF
          FDB   BASIC_POKE
          FDB   BASIC_PRINT
          FDB   BASIC_CONT
          FDB   BASIC_LIST
          FDB   BASIC_CLEAR
          FDB   BASIC_DOS
          FDB   Syntax_Error
          FDB   BASIC_NEW
          FDB   BASIC_SAVE
          FDB   BASIC_LOAD
          FDB   BASIC_MERGE
          FDB   BASIC_OPEN
          FDB   BASIC_CLOSE
          FDB   Syntax_Error
          FDB   Syntax_Error
          FDB   BASIC_PLAY
Msg_OK    FCB   "OK\r\n",0

*****************
Msg_Break ; $c2d8
*****************

          FCB   "\r\nBreak",0

*****************
Msg_Error ; $c2e0
*****************

          FCB   "Error ",0

***************************
SUBROUTINE Open_Gap ; $c2e7
***************************

          BSR   Mem_Avail

******************************
SUBROUTINE Move_XAXBXD ; $c2e9
******************************

          PSHS  U
          LDU   INDEXA
          LEAU  1,U
          LDX   INDEXB
          LEAX  1,X
Gap_20    LDA   ,-X
          STA   ,-U
          CMPX  INDEXD
          BNE   Gap_20
          STU   INDEXC
          PULS  PC,U

*******************************
SUBROUTINE Stack_Free_B ; $c2ff
*******************************

          CLRA
          ASLB

*********************
Adjust_VAREND ; $c301
*********************

          ADDD  VAREND
          BCS   MEMORY_OVERFLOW

*****************
Mem_Avail ; $c305
*****************

          ADDD  #$003a
          BCS   MEMORY_OVERFLOW
          STS   STACKS
          CMPD  STACKS
          BHI   MEMORY_OVERFLOW
          RTS

***********************
Print_OK_Prompt ; $c313
***********************

          LDX   #Msg_OK-1

**************
Print_X_Prompt
**************

          JSR   Print_Newline
          JMP   Print_Msg_X

***********************
MEMORY_OVERFLOW ; $c31c
***********************

          LDB   #7
          LDX   FRETOP
          LEAX  -1,X
          STX   SP_DEF

*************************
BAS_Print_Error_B ; $c324
*************************

          STB   ERRNO
          LDA   #$11
          STA   CHANNEL
          JSR   Close_File
          CLR   CHANNEL
          JSR   Motor_Off
          LDU   CURLIN
          STU   ERRLIN
          LDX   STR_TERM_INDEX
          BEQ   Perr_10
          LDA   STR_TERM_VALUE
          STA   ,X

Perr_10   JSR   Hook_2281
          LDA   WRMFLG
          BEQ   Perr_20
          JSR   NEW_10

Perr_20   LDS   SP_DEF
          JSR   NEW_60
          LDX   OLDTXT
          STX   SAVTXT
          LDU   ERRLIN
          LEAY  1,U
          BEQ   Perr_30
          STU   OLDLIN
          STX   CONPTR
          LDX   TRAPLN
          BEQ   Perr_30
          LDA   ENDFLG
          LBEQ  Inte_10

Perr_30   LDX   #Msg_Error-1
          BSR   Print_X_Prompt
          LDA   #BEL          ; error beep
          JSR   CHROUT
          LDB   ERRNO
          CLRA
          JSR   Print_Integer_D

Perr_40   LDA   CURLIN
          INCA
          BEQ   Main
          JSR   Print_in_Line

************
Main ; $c37d
************

          CLR   CHANNEL
          BSR   Print_OK_Prompt
Main_10   JSR   Hook_2278
          JSR   Edit_Get_Line
          BCS   Main_10
          TST   CINBFL
          LBNE  LOAD_50         ; -> close file
          STX   TXTPTR
          JSR   CHRGET        ; get 1st. char
          BEQ   Main_10       ; -> empty line
          LDX   #$ffff        ; direct mode
          STX   CURLIN
          BCS   Main_20       ; -> starts with digit
          LDB   #$38          ; ILLEGAL DIRECT
          LDA   CHANNEL
          BNE   BAS_Print_Error_B
          LDX   TXTPTR
          JSR   CRUNCH
          JMP   Execute       ; execute in direct mode

Main_20   JSR   Scan_Linenumber
          JSR   Check_Protection
          LDX   LINNUM
          STX   BUF_NUM
          CLR   BUF_TXT
          LDX   TXTPTR

Main_30   LDA   ,-X           ; skip backwards until non blank
          CMPA  #' '
          BEQ   Main_30

          LEAX  1,X           ; ++X -> char after line number
          LDA   ,X
          CMPA  #' '
          BNE   Main_40
          LEAX  1,X           ; skip one blank

Main_40   JSR   CRUNCH
          PSHS  D             ; push A & B
          BSR   Find_BASIC_Line
          BCS   Main_50       ; -> line does not exist
          JSR   Delete_Program_Line

Main_50   LDA   BUF_TXT
          BEQ   Main_70       ; -> no new line
          LDD   VARTAB
          STD   INDEXB        ; save old VARTAB
          ADDD  ,S++          ; add line length
          STD   INDEXA        ; save new VARTAB
          JSR   Open_Gap      ; prepare insertion
          LDU   #BUF_LNK

Main_60   LDA   ,U+           ; store crunched line
          STA   ,X+
          CMPX  INDEXC
          BNE   Main_60
          LDX   INDEXA
          STX   VARTAB        ; update end of program

Main_70   BSR   Clear_Relink
          BRA   Main_10

********************
Clear_Relink ; $c3f9
********************

          BSR   Clear_Variables
          LDX   INDEXD

**************
Relink ; $c3fd
**************

          LDD   ,X
          BEQ   Reli_40
          LEAU  4,X
Reli_10   LDA   ,U+
          BNE   Reli_10
          STU   ,X
          LDX   ,X
          BRA   Relink
Reli_20   COMA
Reli_30   STX   INDEXD
Reli_40   RTS

***********************
Find_BASIC_Line ; $c411
***********************

          LDD   LINNUM
          LDX   TXTTAB

**************************
Find_BASIC_Line_DX ; $c415
**************************

          LDU   ,X
          BEQ   Reli_20
          CMPD  2,X
          BLS   Reli_30
          LDX   ,X
          BRA   Find_BASIC_Line_DX

*****************
BASIC_NEW ; $c422
*****************

          BNE   Reli_30

**************
NEW_10 ; $c424
**************

          CLR   PROTECT
          LDX   TXTTAB
          LEAU  2,X
          CLRB
NEW_20    CLR   ,X+
          DECB  ; clear one page starting at TXTTAB
          BNE   NEW_20
          STU   VARTAB ; VARTAB = TXTTAB + 2
          CLR   TRCFLG

***********************
Clear_Variables ; $c434
***********************

          LDX   TXTTAB
          JSR   Set_TXTPTR

**************
NEW_40 ; $c439
**************

          JSR   Hook_228d
          JSR   Init_Sound
          LDX   #IMPLICIT
          LDD   #$041a ; A = 4 (real)   B = 26 (A-Z)
NEW_50    STA   ,X+
          DECB
          BNE   NEW_50
          CLRA
          STA   ENDFLG
          STD   TRAPLN
          STD   GRAX
          STD   GRAY
          LDX   MEMSIZ
          STX   STRTAB
          LEAX  1,X
          STX   USERAF
          BSR   Reset_DATPTR
          LDX   VARTAB
          STX   VAREND
          LDX   #$804f
          STX   SEED
          LDX   #$c752
          STX   SEED+2
          PULS  X,D
          LDS   FRETOP ; Initialize stack pointer
          CLR   ,-S ; put a zero on stack
          STS   SP_DEF
          CLR   CONPTR
          CLR   CONPTR+1
          PSHS  X,D

**************
NEW_60 ; $c480
**************

          LDX   #STRSTK
          STX   TEMPPT
          CLR   WRMFLG
          JMP   Clear_TERM_INDEX

*********************
BASIC_RESTORE ; $c48a
*********************

          BEQ   Reset_DATPTR
          JSR   Scan_Linenumber
          JSR   Find_BASIC_Line
          BCC   ReDP_10
          JMP   UNDEFINED_LINE

********************
Reset_DATPTR ; $c497
********************

          LDX   TXTTAB
ReDP_10   LEAX  -1,X
          STX   DATPTR
          RTS

*****************
BASIC_END ; $c49e
*****************

          JSR   Close_All
          JSR   CHRGOT
          BRA   STOP_10

***************
STOP_00 ; $c4a5
***************

          CLR   CHANNEL

******************
BASIC_STOP ; $c4a7
******************

          ORCC  #1
STOP_10   BNE   CONT_Ret
          LDX   TXTPTR
          STX   OLDTXT
STOP_20   LDS   SP_DEF
STOP_30   ROR   STOPFLG
          LDU   CURLIN
          LEAX  1,U
          BEQ   STOP_40
          STU   OLDLIN
          LDX   OLDTXT
          STX   CONPTR
STOP_40   LDX   #Msg_Break-1
          TST   STOPFLG
          LBPL  Main
          JSR   Print_Msg_X
          JMP   Perr_40

******************
BASIC_CONT ; $c4cf
******************

          LDB   #$11 ; CAN'T CONTINUE
          LDX   CONPTR
          BNE   CONT_10
          JMP   Print_Error_B
CONT_10   STX   TXTPTR
          LDX   OLDLIN
          STX   CURLIN
CONT_Ret  RTS

*******************
BASIC_CLEAR ; $c4de
*******************

          BEQ   CLEAR_40      ; -> clear variables
          LDD   MEMSIZ
          SUBD  FRETOP        ; D = current string space
          PSHS  DP,D
          JSR   CHRGOT
          CMPA  #','
          BEQ   CLEAR_10
          JSR   Eval_Word
          STD   ,S            ; overwrite size value

CLEAR_10  JSR   MEM_UCHR_X    ; arg 2 = top of RAM
          PSHS  X
          JSR   CHRGOT
          BEQ   CLEAR_20
          JSR   Need_Comma
          CMPA  #','
          BEQ   CLEAR_20
          JSR   Get_Number
          LEAX  -1,X
          CMPX  TOPRAM
          BHI   Jmp_OOM
          STX   ,S

CLEAR_20  LDB   USRCHR         ; # of user chars
          JSR   CHRGOT
          BEQ   CLEAR_30
          JSR   Get_Comma_And_Byte
          CMPB  #$80
          LBHI  Illegal_Quantity

CLEAR_30  STB   4,S
          LDA   #8            ; 8 bytes per character
          MUL
          STD   ACA_M2
          PULS  D
          SUBD  ACA_M2
          TFR   D,X
          SUBD  ,S++
          BCS   Jmp_OOM
          TFR   D,U
          SUBD  #$003a
          BCS   Jmp_OOM
          SUBD  VARTAB
          BCS   Jmp_OOM
          STU   FRETOP        ; new FRETOP
          STX   MEMSIZ        ; new MEMSIZ
          PULS  B
          STB   USRCHR

CLEAR_40  PULS  X
          LDS   FRETOP
          PSHS  X
          JMP   NEW_40

Jmp_OOM   JMP   MEMORY_OVERFLOW

*****************
BASIC_RUN ; $c54b
*****************

          CMPA  #$22 ; '"'
          LBEQ  Load_And_Run
          JSR   Close_All
          JSR   CHRGOT
          LBEQ  Clear_Variables
          JSR   NEW_40
          BRA   Go_20

****************
BASIC_GO ; $c55f
****************

          TFR   A,B
GO_10     JSR   CHRGET
          CMPB  #$bb ; TO token
          BEQ   GO_30
          CMPB  #$bc ; SUB token
          BNE   Jmp_Syntax_Error
          LDB   #3
          JSR   Stack_Free_B
          LDU   TXTPTR
          LDX   CURLIN
          LDA   #$bc
          PSHS  U,X,A
Go_20     BSR   GO_30
          JMP   Interpret

*******************
Skip_To_EOS ; $c57d
*******************

          LDB   #':'
          FCB   $21 ; BRN -> skip byte

*******************
End_Of_Line ; $c580
*******************

          CLRB
          LDX   TXTPTR
          CLR   ENDCHR
EOL_10    EXG   A,B
          LDB   ENDCHR
          STA   ENDCHR
EOL_20    LDA   ,X
          BEQ   REM_Ret ; -> end of line
          CMPA  ENDCHR
          BEQ   REM_Ret ; -> end of line
          LEAX  1,X
          CMPA  #$22 ; '"'
          BEQ   EOL_10
          INCA
          BNE   EOL_30
          LEAX  1,X
EOL_30    CMPA  #$8a ; IF token + 1
          BNE   EOL_20
          INC   IFCTR
          BRA   EOL_20

*************
GO_30 ; $c5a6
*************

          JSR   CHRGOT
GO_40     JSR   Scan_Linenumber

*************
GO_50 ; $c5ab
*************

          BSR   End_Of_Line
          LEAX  1,X
          LDD   LINNUM
          CMPD  CURLIN
          BHI   GO_60 ; search from start
          LDX   TXTTAB ; search from current pos.
GO_60     JSR   Find_BASIC_Line_DX
          BCS   UNDEFINED_LINE

******************
Set_TXTPTR ; $c5bd
******************

          LEAX  -1,X
          BRA   REM_10

********************
BASIC_RETURN ; $c5c1
********************

          BNE   REM_Ret
          LDA   #$ff
          STA   VARDES
          JSR   Search_Stack
          LEAS  ,X
          STS   SP_DEF
          CMPA  #$3b ; ';' ; GSOUB marker
          BEQ   RETURN_10
          LDB   #3 ; RETURN WITHOUT GOSUB
          FCB   $8c ; CMPX #

**********************
UNDEFINED_LINE ; $c5d6
**********************

          LDB   #8
          JMP   Print_Error_B

************************
Jmp_Syntax_Error ; $c5da
************************

          JMP   Syntax_Error

*****************
RETURN_10 ; $c5dc
*****************

          PULS  U,X,A
          STX   CURLIN
          STU   TXTPTR

******************
BASIC_DATA ; $c5e2
******************

          BSR   Skip_To_EOS
          FCB   $8c ; SKIP2

*****************
BASIC_REM ; $c5e5
*****************

          BSR   End_Of_Line
REM_10    STX   TXTPTR
REM_Ret   RTS

****************
BASIC_IF ; $c5ea
****************

          JSR   Dec_Eval_Exp
          JSR   CHRGOT
          CMPA  #$87 ; GO token
          BNE   IF_10
          JSR   CHRGET
          JSR   Dec_TXTPTR
          CMPA  #$bb ; TO token
          BEQ   IF_20
IF_Err    JMP   Syntax_Error
IF_10     LDB   #$c4 ; THEN token
          JSR   Need_B
IF_20     JSR   Get_Sign ; true or false
          BNE   IF_40 ; -> true
          CLR   IFCTR
IF_30     BSR   BASIC_DATA
          TSTA
          BEQ   REM_Ret
          JSR   CHRGET
          CMPA  #$8f ; ELSE token
          BNE   IF_30
          DEC   IFCTR
          BPL   IF_30
          JSR   CHRGET
IF_40     JSR   CHRGOT
          BCS   GO_40 ; -> GOTO
          JMP   Process ; -> continue

****************
BASIC_ON ; $c61f
****************

          CMPA  #$98 ; ERROR token
          BEQ   ON_ERROR
          JSR   Syntax_Check
          JSR   Byte_Var
          LDB   #$87 ; GO token
          JSR   Need_B
          PSHS  A
          CMPA  #$bc ; SUB token
          BEQ   ON_10
          CMPA  #$bb ; TO token
          BNE   IF_Err
ON_10     DEC   ACA_M3 ; ON value
          BNE   ON_20
          PULS  B
          JMP   GO_10
ON_20     JSR   CHRGET
          BSR   Scan_Linenumber
          CMPA  #','
          BEQ   ON_10
          JSR   CHRGOT
          PULS  PC,B

***********************
Scan_Linenumber ; $c64b
***********************

          LDX   ZERO_W ; #0000
          STX   LINNUM
ScLi_10   BCS   ScLi_20
          JMP   CHRGOT
ScLi_20   SUBA  #'0'
          STA   ENDCHR ; current digit
          LDD   LINNUM
          CMPA  #$18 ; $18ff = 6399 (63990 after mult 10)
          BHI   IF_Err
          ASLB
          ROLA
          ASLB
          ROLA
          ADDD  LINNUM
          ASLB
          ROLA  ; LINNUM *= 10
          ADDB  ENDCHR ; current digit
          ADCA  #0
          STD   LINNUM
          JSR   CHRGET
          BRA   ScLi_10

***********
LET ; $c66f
***********

          JSR   Parse_Name
          STX   VARDES
          JSR   R_VALUE
          JSR   Test_ACA_Type
          LBNE  ACA_To_VARDES

******************************
Assign_String_Variable ; $c67c
******************************

          JSR   Load_XB_DSD_ACA
          JSR   Store_String
          LDU   VARDES
          STB   ,U            ; string length
          STX   1,U           ; string address
          RTS

****************
ON_ERROR ; $c689
****************

          JSR   CHRGET
          LDB   #TK_GO
          JSR   Need_B
          LDB   #TK_TO
          JSR   Need_B
          BSR   Scan_Linenumber
          LDX   LINNUM
          BEQ   ONER_10
          JSR   Find_BASIC_Line
          LBCS  UNDEFINED_LINE
          STX   TRAPLN
ONER_Ret  RTS

ONER_10   STX   TRAPLN
          LDA   ENDFLG
          BEQ   ONER_Ret
          LDX   ERRLIN
          STX   CURLIN
          JMP   Perr_20

Ext_Err   JMP   [$2213]

*************
Call_Function
*************

          JSR   CHRGET        ; get 2nd, byte of $ffxx token
          TFR   A,B           ; copy to B
          ASLB                ; B * 2
          JSR   CHRGET        ; next char
          CMPB  #$4c          ; FUNC_PTRIG
          BHI   Ext_Err       ; -> error
          PSHS  B
          CMPB  #$3e          ; FUNC_RND
          BCC   CaFu_10       ; -> FUNC_RND or higher
          BSR   Need_Left_Par
          LDB   ,S
          CMPB  #$34          ; FUNC_LEFT$
          BCC   CaFu_10
          BSR   Eval_To_Par   ; functions with single argument

CaFu_10   PULS  B
          LDX   Crunch_Tab+8  ; BASIC_Function_A
          JMP   [B,X]         ; use token jump table

*************
ERRNO_To_Real
*************

          CLRA
          LDB   ERRNO
          SKIP2

**************
ERRLIN_To_Real
**************

          LDD   ERRLIN
          JSR   Integer_To_Real
          JMP   CHRGET

*********************
TXTPTR_String ; $c6e1
*********************

          LDX   TXTPTR
          JSR   Scan_Quoted_String

*********************
COEFPT_TXTPTR ; $c6e6
*********************

          LDX   COEFPT
          STX   TXTPTR
COTX_Ret  RTS


***********
Get_Operand
***********

          JSR   CHRGET
          BEQ   NO_OPERAND
          BCC   GeOp_10

***********************
String_To_Float ; $c6f1
***********************

          JSR   Dec_TXTPTR
          JMP   Read_Real_To_ACA

GeOp_10   JSR   A_Is_Alpha
          BCC   Operator_Switch
          JSR   Parse_Name
          STX   ACA_M2
          JSR   Test_ACA_Type
          BEQ   COTX_Ret      ; -> string
          JMP   Load_ACA

***********
Neg_Operand
***********

          LDA   #$7d
          BSR   EvEx_05
          JMP   Negate_Real_Or_Int

***************
Operator_Switch
***************

          LDX   #OP_Switch
OpSw_10   CMPA  ,X++
          BHI   OpSw_10
          LBNE  Oper_Error
          LDB   -1,X
          LDX   #Neg_Operand
          JMP   B,X

***********
Not_Operand
***********

          LDA   #$5a          ; operator priority
          BSR   EvEx_05
          JSR   FUNC_CINT
          JMP   Not_D_To_ACA

********************
Eval_In_Pars ; $c729
********************

          BSR   Need_Left_Par

*************
Eval_To_Par ; $c72b
*************

          JSR   Dec_Eval_Exp
          JMP   Need_Right

*********************
Need_Left_Par ; $c72f
*********************

          LDB   #'('
          SKIP2

**********************
BAS_Need_Comma ; $c732
**********************

          LDB   #','

******************
BAS_Need_B ; $c734
******************

          CMPB  [TXTPTR]
          BNE   SYNTAX_ERROR
          JMP   CHRGET

********************
SYNTAX_ERROR ; $c73c
********************

          JMP   Syntax_Error

******************
NO_OPERAND ; $c73e
******************

          LDB   #$16
          JMP   Print_Error_B

***************************
BAS_Eval_Expression ; $c742
***************************

          CLRA
EvEx_05   PSHS  A
          LDB   #1
          JSR   Stack_Free_B
          BSR   Get_Operand
EvEx_10   JSR   CHRGOT
          SUBA  #$c7 ; + token
          BCS   EvEx_20       ; -> not an operator
          CMPA  #14
          BHI   EvEx_20       ; -> not a binary operator
          LDB   #3
          MUL
          LDX   #BIN_OP
          LDA   B,X           ; operator precedence
          CMPA  ,S
          BHI   EvEx_25       ; -> higher precedence
EvEx_20   PULS  PC,A

***************
EvEx_25 ; $c764
***************

          STA   PRECED
          INCB                ; B = index to operator routine
          LDU   B,X           ; U = operator routine
          LDB   #4
          STB   INDEXC        ; check 3 2-byte operators <= >= <>
          LDD   [TXTPTR]      ; A = op token   B = next char
          LDX   #COMPARE_TAB-2
EvEx_30   LEAX  2,X
          DEC   INDEXC
          BEQ   EvEx_35
          CMPD  ,X++
          BNE   EvEx_30
          LDU   ,X            ; 2-byte operator match
          JSR   CHRGET
EvEx_35   PSHS  U             ; push op routine
          BSR   Push_ACA     ; push left operand
          LDA   PRECED
          BSR   EvEx_05       ; recursive call
          STA   PRECED
          BSR   Pull_ACB     ; pop left operand to ACB
          LDA   PRECED
          LDB   ACB_SZ
          CMPB  #3
          BEQ   EvEx_65       ; -> descriptor size
          INCA
          BMI   EvEx_40
          CMPA  #$51
          BLS   EvEx_60       ; -> logic operator
          SUBA  #$7b          ; MULT DIV precedence
          LSRA
          BEQ   EvEx_60       ; -> MULT DIV
          LDA   ACA_SZ
          LSRA
          BCS   EvEx_70       ; -> descriptor size (3)
          ADDA  ACB_SZ
          CMPA  #4            ; sizeof(REAL)
          BCS   EvEx_45
EvEx_40   JSR   Cast_ACA_Real ; REAL or mixed
          BSR   Swap_FAC_AB
          JSR   Cast_ACA_Real
EvEx_45   BSR   Swap_FAC_AB
EvEx_50   PULS  X             ; pull operator routine
EvEx_55   JSR   ,X            ; call operator routine
          BRA   EvEx_10

***************
EvEx_60 ; $c7bc
***************

          JSR   FUNC_CINT     ; logical operator
          BSR   Swap_FAC_AB
          JSR   FUNC_CINT
          BRA   EvEx_50

***************
EvEx_65 ; $c7c6
***************

          STA   PRECED        ; string operator
          JSR   Test_ACA_Type
          BEQ   EvEx_75
EvEx_70   JMP   TYPE_MISMATCH
EvEx_75   BSR   Swap_FAC_AB
          LDA   #$64          ; < = >
          CMPA  PRECED
          BEQ   EvEx_50
          LDX   #OP_PLUS      ; string +
          CMPX  ,S++
          BNE   EvEx_70
          LDX   #Concat_Strings
          BRA   EvEx_55

*****************
Push_ACA ; $c7e3
*****************

          PULS  Y
          LDD   ACA_SZ
          LDX   ACA_M1
          LDU   ACA_M3
          PSHS  U,X,D
          JMP   ,Y

*****************
Pull_ACB ; $c7ef
*****************

          PULS  Y
          PULS  U,X,D
          STU   ACB_M3
          STX   ACB_M1
          STD   ACB_SZ
          JMP   ,Y

*****************
Pull_ACA ; $c7fb
*****************

          PULS  Y
          PULS  U,X,D
          STU   ACA_M3
          STX   ACA_M1
          STD   ACA_SZ
          JMP   ,Y

*******************
Swap_FAC_AB ; $c807
*******************

          LDQ   ACA_SZ        ; SZ,EX,M1,M2
          LDX   ACB_SZ        ; SZ,EX
          STX   ACA_SZ
          LDX   ACB_M1        ; M1,M2
          STX   ACA_M1
          STQ   ACB_SZ
          LDD   ACA_M3        ; M3,SI
          LDX   ACB_M3
          STX   ACA_M3
          STD   ACB_M3
          RTS

*******************
Swap_INT_AB ; $c81f
*******************

          LDD   ACA_M2
          LDX   ACB_M2
          STX   ACA_M2
          STD   ACB_M2
          RTS

          FILL $c827-* ($15)

***********************
Compare_Strings ; $c827
***********************

          JSR   Load_XB_DSD_ACB
          JSR   BX_To_DESCA
          JSR   Load_XB_DSD_ACA
          CMPB  DSA_LEN
          BEQ   CoSt_10
          DECA
          BCS   CoSt_10
          LDB   DSA_LEN
          NEGA
CoSt_10   STA   ACA_SI
          LDU   DSA_ADR
          INCB
CoSt_20   DECB
          BEQ   CoSt_30
          LDA   ,X+
          CMPA  ,U+
          BEQ   CoSt_20
          LDB   #1
          BCC   CoSt_40
          NEGB
          FCB   $8c
CoSt_30   LDB   ACA_SI
CoSt_40   SEX
          BRA   CMP_Result

***********************
Compare_Generic ; $c853
***********************

          JSR   Test_ACA_Type
          BEQ   Compare_Strings
          BPL   Compare_ACA_ACB
          BSR   Swap_INT_AB

***********************
Compare_ACA_ACB ; $c85b
***********************

          JSR   Cmp_ACA_ACB

******************
CMP_Result ; $c85e
******************

          STD   ACA_M2
          CLRA
          CLRB
          LDX   ACA_M2
          RTS

*************
OP_EQ ; $c865
*************

          BSR   Compare_Generic
          BNE   Jmp_D_To_ACA

*********************
Not_D_To_ACA ; $c869
*********************

          COMA
          COMB

*********************
Jmp_D_To_ACA ; $c86b
*********************

          JMP   D_To_ACA

*************
OP_LT ; $c86d
*************

          BSR   Compare_Generic
OPLT_10   BMI   Not_D_To_ACA
          BRA   Jmp_D_To_ACA

*************
OP_LE ; $c873
*************

          BSR   Compare_Generic
          BEQ   Not_D_To_ACA
          BRA   OPLT_10

*************
OP_GE ; $c879
*************

          BSR   OP_LT
          FCB   $8c

*************
OP_NE ; $c87c
*************

          BSR   OP_EQ
          FCB   $8c

*************
OP_GT ; $c87f
*************

          BSR   OP_LE
          COM   ACA_M2
          COM   ACA_M3
          RTS

**************
OP_AND ; $c886
**************

          ANDA  ACB_M2
          ANDB  ACB_M3
          BRA   Jmp_D_To_ACA

*************
OP_OR ; $c88c
*************

          ORA   ACB_M2
          ORB   ACB_M3
          BRA   Jmp_D_To_ACA

**************
OP_EOR ; $c892
**************

          EORA  ACB_M2
          EORB  ACB_M3
          BRA   Jmp_D_To_ACA

**************
OP_IMP ; $c898
**************

          COMA
          COMB
          BRA   OP_OR
          NOP

**************
OP_EQV ; $c89d
**************

          BSR   OP_EOR
          BRA   Not_D_To_ACA

******************
A_Is_Alpha ; $c8a1
******************

          CMPA  #$5b ; 'Z'+1

************************
A_Is_Alpha_Range ; $c8a3
************************

          BCC   AIAR_Ret
          SUBA  #'A'
          SUBA  #$bf
AIAR_Ret  RTS

****************************************************
* Parse the name of a BASIC variable
* --------------------------------------------------
* Maximum name length : 15 characters [A-Z,0-9]
* First character     : [A-Z]
* type appendix       : ! (4 byte REAL = default)
*                     : % (2 byte INTEGER)
*                     : $ (3 byte STRING descriptor)
* --------------------------------------------------
* scalar variable
* --------------------------------------------------
*   0 : size byte (ssss nnnn) size / name length
*   1 : 1st. character
*   n : last character
* n+1 : value (2 for integer, 3 descriptor, 4 real)
* --------------------------------------------------
* array
* --------------------------------------------------
*   0 : (ssss nnnn) size = 8 + type
*   1 : 1st. character
*   n : last character
* n+1 : total size of array
* n+3 : rank (# of dimensions)
* n+5 : 2 bytes for 1st. dimension
* --------------------------------------------------
*  U = TXTPTR = parse pointer
*  X = VARPTR = pointer to variable
*  Y = VAREND = pointer to end of variables
*      VAR1ST = pointer to parse start
*  B = VANLEN = length of name (max. 15)
*      ARYDIS = array flag 0:parse parenthesis
*      TYPSIZ = type size
****************************************************


**********************
BAS_Parse_Name ; $c8aa
**********************

          CLR   ARYDIS        ; array disable flag

***************
Pars_05 ; $c8ac
***************

          LDU   TXTPTR
          STU   VAR1ST        ; save pointer to name
          LDA   ,U+           ; A = 1st. character
          BSR   A_Is_Alpha    ; must be ('A'..'Z')
          BCS   Pars_10       ; -> OK
          JMP   Syntax_Error

Pars_10   CLRB                ; length counter = 0

Pars_15   LDA   ,U+           ; A = next character
          CMPB  #15           ; max length = 15
          BEQ   Pars_20       ; ignore characters beyond the 15th.
          INCB                ; length of variable name

Pars_20   BSR   A_Is_Alpha    ; ('A'..'Z') ?
          BCS   Pars_15       ; valid char -> OK
          JSR   ISNUM         ; ('0'..'9') ?
          BCS   Pars_15       : valid char -> OK
          STB   VANLEN       ; length of variable name
          STU   TXTPTR
          LDX   #VAR_SIZES
          SUBA  #'!'          ; 1st. type character (REAL)
          CMPA  #4
          BLS   Pars_30       ; -> type character given

Pars_25   JSR   Dec_TXTPTR
          LDX   #IMPLICIT-'A'
          LDA   [VAR1ST]      ; A = 1st. char

Pars_30   LDB   A,X           ; B = type size
          BEQ   Pars_25
          TST   ARYDIS        ; array disabled ?
          BMI   Pars_40
          BNE   Pars_35
          JSR   CHRGOT
          CMPA  #'('
          BNE   Pars_40

Pars_35   ADDB  #8            ; set array bit

Pars_40   STB   ACA_SZ       ; size byte
          LDX   VARTAB        ; start of variables

Pars_45   CMPX  VAREND        ; X at end of vars ?
          BEQ   Allocate
          BSR   Size_Nibbles  ; A = ssss nnnn
          LDB   ,X            ; size byte of vartab
          LSRB
          LSRB
          LSRB
          LSRB
          STB   TYPSIZ        ; = type size
          LDB   ,X
          ANDB  #15           ; = var name length

Pars_50   CMPA  ,X+           ; compare name char with tab
          BEQ   Pars_65       ; -> size nibble match
          ABX                 ; X = after VARTAB name
          CLRA
          BSR   Is_Scalar
          BEQ   Pars_55
          LDD   ,X++          ; D = total array size
Pars_55   LEAX  D,X
          BRA   Pars_45       ; compare next entry

********************
Varname_Char ; $c916
********************

          LDA   ARYDIS
          ANDA  #$80
          ORA   ,U+
          DECB
          RTS

***************
Pars_65 ; $c91e
***************

          BSR   Varname_Char  ; load next char
          BPL   Pars_50       ; -> not at end
          BSR   Is_Scalar
          BEQ   AlSc_10       ; -> store X and return
          LDA   ARYDIS
          BNE   Redim_Check
          BSR   Parse_Indices ; parse and push indices
          CMPA  ,X+           ; # of indices == rank ?
          BNE   Out_Of_Bounds

Pars_70   LDD   ,S++          ; D = right most index
          JSR   Mult_Offset
          DEC   COUNT
          BNE   Pars_70       ; loop for next index
          LEAX  D,X           ; X = array address + offset
          BRA   AlSc_10       ; STX VARPTR and RTS

********************
Size_Nibbles ; $c93d
********************

          LDU   VAR1ST
          LDA   ACA_SZ
          ASLA
          ASLA
          ASLA
          ASLA
          ADDA  VANLEN
          LDB   VANLEN
          RTS

*****************
Is_Scalar ; $c94a
*****************

          LDB   TYPSIZ
          BITB  #8
          RTS

********
Allocate
********

          LDB   ACA_SZ
          STB   TYPSIZ
          TST   ARYDIS
          BGT   AlSc_Ret
          BSR   Is_Scalar
          BNE   Implicit_DIM
          BSR   Allocate_Var
          STY   VAREND
AlSc_10   STX   VARPTR
AlSc_Ret  RTS

***************************
Allocate_Array_Name ; $c963
***************************

          LDA   #1
          STA   ARYDIS        ; disable recursion
          JSR   Pars_05       ; parse array name

*************
Allocate_Name
*************

          CLRB                ; no allocation for value

************
Allocate_Var
************

* Input : B = type size

          LDX   VAREND
          CLRA
          ADDB  VANLEN        ; B = namelength + type length
          INCB                ; add 1 for type size byte
          LEAY  D,X           ; Y = new VAREND
          JSR   Mem_Avail     ; check
          BSR   Size_Nibbles  ; create size info byte

AlVa_10   STA   ,X+           ; store size info
          BSR   Varname_Char  ; next char
          BPL   AlVa_10
          CLR   ,X            ; clear two bytes
          CLR   1,X           ; after name

AlVa_Ret  RTS

********
Get_Word
********

          JSR   CHRGET

*****************
Eval_Word ; $c985
*****************

          JSR   Eval_Numeric

*****************************
Eval_Positive_Integer ; $c987
*****************************

          JSR   FUNC_CINT
          BPL   AlVa_Ret
EPI_Err   JMP   Illegal_Quantity



***********
Redim_Check
***********

          LSRA
          BNE   AlVa_Ret
          LDB   #10           ; REDIM
          SKIP2

*************
Out_Of_Bounds
*************

          LDB   #9            ; OUT OF BOUNDS
          JMP   Print_Error_B

************
Implicit_DIM
************

* array references to undeclared arrays trigger an
* implicit declaration of DIM array(10)

          LDU   VAR1ST
          PSHS  U
          BSR   Allocate_Name
          JSR   Allocate_Array_Space
          PULS  U
          STU   TXTPTR
          JMP   Parse_Name

*************
Parse_Indices
*************

          PULS  Y             ; Y = return address
          LDB   TYPSIZ
          ANDB  #7            ; extract type
          CLRA                ; clear high byte

GAO_10    LDU   ARYDIS
          PSHS  U,Y,X,D       ; push all pointers
          BSR   Get_Word
          PULS  U,Y,X,D       ; restore
          STU   ARYDIS
          INCA                ; offset = index + 1
          BMI   EPI_Err       ; $7fxx -> illegal quantity
          LDU   ACA_M2       ; U = current index
          PSHS  U,A
          STA   COUNT
          JSR   CHRGOT
          CMPA  #','          ; are there more indices ?
          PULS  A             ; restore A
          BEQ   GAO_10        ; ',' -> read next index
          STB   TYPSIZ
          JSR   Need_Right    ; need ')' if not comma
          LEAU  ,X            ; U  = X
          LEAX  2,X           ; X += 2
          CLRA
          CLRB                ; D = 0
          STD   COEFPT        ; COEFPT = 0
          INCB
          STD   RESSGN        ; RESSGN = 1
          LDA   COUNT
          JMP   ,Y            ; return



***********
Dim_Product
***********

          STD   ,X            ; size = dim + 1
          SUBD  #1            ; dim

************************************************
* Multiply current index with previous dimension
* ----------------------------------------------
* D      = current index
* RESSGN = previous dimension
*
* offset = i3 + dim3 * (i2 + dim2 * (i1))
************************************************

*******************
Mult_Offset ; $c9e1
*******************

* Input : D      = next index (right to left)
*         X      = array dimensions
*         COEFPT = accumulated offset
*         RESSGN = product of dimensions

          BSR   MuBo_RESSGN   ; i3; i2 * d3; i1 * d2 * d3
          ADDD  COEFPT        ;  0; i3
          BMI   Out_Of_Bounds ; limit to $7fff
          STD   COEFPT        ; i3; i3 + d3 * i2
          LDD   ,X++          ; d3; d2
          BSR   Mult_RESSGN   ; d3; d2 * d3
          STD   RESSGN        ; d3; d2 * d3
          LDD   COEFPT        ; i3;
          STD   ACA_M2
          LDB   TYPSIZ
          LDA   ACA_M2
          MUL                 ; D = high byte * size
          STB   ACA_M2
          BMI   Out_Of_Bounds
          TSTA

Mult_OOB  BNE   Out_Of_Bounds
          LDA   ACA_M3
          LDB   TYPSIZ
          STB   ACA_SZ
          MUL                 ; D = low byte * size
          ADDA  ACA_M2       ; add high result
          BMI   Out_Of_Bounds
          STD   ACA_M2       ; ACA = offset * size
          RTS

***********
MuBo_RESSGN
***********

          CMPD  ,X            ; compare index with dimension+1
          BHS   Out_Of_Bounds

***********
Mult_RESSGN
***********

          MULD  RESSGN
          TSTD
          BNE   Mult_OOB      ; -> overflow
          TSTW
          BMI   Mult_OOB      ; -> overflow
          TFR   W,D
          RTS

          FILL $ca22-* (0)

********************
Create_Array ; $ca22
********************

          JSR   Allocate_Array_Name

****************************
Allocate_Array_Space ; $ca25
****************************

          BSR   Parse_Indices
          STA   ,X+           ; store rank
          TFR   A,B
          ASLA                ; rank * 2
          INCA                ; rank * 2 + 1
          STA   1,U           ; store header length
          CLR   ,U            ; clear header high byte
          JSR   Stack_Free_B  ; check stack availability

AAS_10    LDD   ,S++          ; D = dimension (right to left)
          ADDD  #1            ; size = (0 .. dim)
          TST   ARYDIS
          BNE   AAS_20        ; -> explicit declaration
          LDD   #11           ; default dimension = 10

AAS_20    BSR   Dim_Product
          DEC   COUNT         ; rank
          BNE   AAS_10        ; loop for next dimension
          ADDB  ACA_SZ
          ADCA  #0            ; D += size of element
          STD   ACA_M2
          ADDD  ,U            ; add header length
          STD   ,U++          ; store array size
          JSR   Adjust_VAREND
          LDY   ACA_M2       ; Y = array size

AAS_30    CLR   ,X+           ; initialize array to zero
          LEAY  -1,Y
          BNE   AAS_30
          STX   VAREND        ; update VAREND
          RTS

**************
DIM_10 ; $ca5f
**************

          JSR   CHRGET

*****************
BASIC_DIM ; $ca61
*****************

          BSR   Create_Array
          JSR   CHRGOT
          CMPA  #','
          BEQ   DIM_10        ; -> next array
          RTS

****************
FUNC_FRE ; $ca6a
****************

          JSR   Test_ACA_Type
          BNE   FRE_10             ; -> numeric argument
          JSR   Load_XB_DSD_ACA
          BSR   Garbage_Collection
          LDD   STRTAB
          SUBD  FRETOP        ; free = STRTAB - FRETOP
          BRA   FRE_20

FRE_10    TFR   S,D
          SUBD  VAREND        ; free = stackpointer - end of arrays

FRE_20    JMP   Integer_To_Real

***********************
Allocate_String ; $ca80
***********************

          CLR   GARBFL        ; clear garbage collection flag
AlSt_10   CLRA
          PSHS  D             ; push length of string
          LDD   STRTAB        ; D = start of strings
          SUBD  ,S+           ; D -= length
          TFR   D,X           ; X = new start of strings
          CMPX  FRETOP        ; compare with limit
          BLO   Squeeze       ; -> garbage collection
          STX   STRTAB        ; update start of strings
          LEAX  1,X
          STX   FRESPC        ; start of reserved space
          PULS  PC,B          ; return

*********************
Search_String ; $ca97
*********************

          TST   -1,X          ;
          BMI   SStr_20       ;

SStr_10   LDA   ,X            ; length
          BEQ   SStr_20       ; zero length ->  advance X
          LDD   1,X           ; D = string address
          CMPD  STRTAB        ; start of string variables
          BHI   SStr_20       ; -> string is outside string space
          CMPD  INDEXD        ;
          BLS   SStr_20       ; -> string is outside string space
          STX   FAC3_EX       ; save string var
          STD   INDEXD        ; save stringaddress

SStr_20   LEAX  3,X

SStr_Ret  RTS

*******
Squeeze
*******
          LDB   #14           ; OUT OF STRING SPACE
          COM   GARBFL
          BEQ   Jmp_Err
          BSR   Garbage_Collection
          PULS  B
          BRA   AlSt_10

**************************
Garbage_Collection ; $cabe
**************************

          LDX   MEMSIZ        ; top of string space

GaCo_10   STX   STRTAB        ; start of string table
          CLRA
          CLRB                ; D = 0
          STD   FAC3_EX       ; pointer = 0
          LDX   FRETOP
          STX   INDEXD        ; save FRETOP
          LDX   #STRSTK       ; start of descriptor stack

GaCo_20   CMPX  TEMPPT        ; next available descriptor
          BEQ   GaCo_30       ; -> on top of stack
          BSR   SStr_10       ; search string
          BRA   GaCo_20       ; keep checking

GaCo_30   CLRA
          LDX   VARTAB        ; X = start of variables

GaCo_40   LEAX  A,X           ; X += A

GaCo_50   CMPX  VAREND        ; end of variables
          BEQ   GaCo_90       ; -> finished vvariables
          LDB   ,X+           ; B = type size namelength
          TFR   B,A
          ANDB  #15           ; B = namelength
          ABX                 ; X += namelength
          LSRA
          LSRA
          LSRA
          LSRA                ; A = type size
          BITA  #8            ; test array bit
          BNE   GaCo_60       ; -> array
          CMPA  #3            ; is string ?
          BNE   GaCo_40       ; -> no
          BSR   Search_String
          BRA   GaCo_50       ; loop

GaCo_60   CMPA  #11           ; is string array (8+3) ?
          BEQ   GaCo_70       ; -> yes
          LDD   ,X++          ; D = array size
          LEAX  D,X           ; put X after array
          BRA   GaCo_50       ; loop

GaCo_70   LDD   ,X++          ; D = size of string array
          LEAU  D,X           ; U = end of string array + 1
          STU   INDEXA        ; save end of array pointer
          LDB   ,X+           ; # of dimensions
          ASLB                ; * 2
          ABX                 ; X = 1st. descriptor

GaCo_80   CMPX  INDEXA        ; at end of array ?
          BEQ   GaCo_50       ; -> loop
          BSR   SStr_10       ; search string
          BRA   GaCo_80       ; next array element

GaCo_90   LDX   FAC3_EX       ; string found ?
          BEQ   SStr_Ret      ; -> no
          CLRA
          LDB   ,X            ; string length
          DECB                ; - 1
          ADDD  INDEXD        ; D points to last char
          STD   INDEXB        ; end of string
          LDX   STRTAB
          STX   INDEXA        ; target address
          JSR   Move_XAXBXD   ; (XD-XB) -> XA (backwards)
          LDU   FAC3_EX
          LDX   INDEXC
          STX   1,U
          LEAX  -1,X
          BRA   GaCo_10

***************************
Formula_Too_Complex ; $cb2e
***************************

          LDB   #$10
Jmp_Err   JMP   Print_Error_B

**********************
Scan_ZT_String ; $cb32
**********************

          CLRA
          CLRB

**********************
Scan_DT_String ; $cb34
**********************

          STD   ENDCHR ; CHARAC
          STX   RESSGN
          STX   DSA_ADR
          LDB   #$ff
ScSt_10   INCB
          LDA   ,X+
          BEQ   ScSt_30
          CMPA  ENDCHR
          BEQ   ScSt_20
          CMPA  CHARAC
          BNE   ScSt_10
ScSt_20   CMPA  #$22 ; '"' ; Quote
          BEQ   ScSt_40
ScSt_30   LEAX  -1,X
ScSt_40   STX   COEFPT
          LDA   CHARAC
          CMPA  #','
          BNE   ScSt_60
          INCB
ScSt_50   DECB
          BEQ   ScSt_60
          LDA   ,-X
          CMPA  #' '
          BEQ   ScSt_50
ScSt_60   STB   DSA_LEN
          RTS

****************
FUNC_STR ; $cb64
****************

          JSR   Assert_ACA_Numeric
          JSR   Format_ACA
          BSR   Scan_ZT_String
          BRA   Save_String

********************************
Create_String_Descriptor ; $cb6d
********************************

          LEAX  -1,X

**************************
Scan_Quoted_String ; $cb6f
**************************

          LDA   #QUOTE

*********************
Scan_A_String ; $cb71
*********************

          TFR   A,B

**********************
Scan_AB_String ; $cb73
**********************

          LEAX  1,X
          BSR   Scan_DT_String
          LDU   RESSGN
          CMPU  #$2554
          BHI   Push_Descriptor

*******************
Save_String ; $cb7f
*******************

          BSR   Allocate_String_B
          LDX   RESSGN

*****************************
Store_Push_Descriptor ; $cb83
*****************************

          BSR   Copy_String_X_FRESPC

***********************
Push_Descriptor ; $cb85
***********************

          LDX   TEMPPT
          CMPX  #STREOS
          BEQ   Formula_Too_Complex
          LDA   #3
          STA   ACA_SZ
          STX   TEMPST
          STX   ACA_M2
          LDA   DSA_LEN
          STA   ,X+
          LDU   DSA_ADR
          STU   ,X++
          STX   TEMPPT
          RTS

****************
FUNC_VAL ; $cb9f
****************

          BSR   Eval_String_Desc
          LBEQ  BAS_B_To_ACA
          LDU   TXTPTR
          STX   TXTPTR
          ABX
          LDA   ,X ; A = string terminator
          STA   STR_TERM_VALUE
          STX   STR_TERM_INDEX
          PSHS  U,X,A
          CLR   ,X
          JSR   String_To_Float
          PULS  U,X,A
          STA   ,X ; restore string terminator
          STU   TXTPTR

************************
Clear_TERM_INDEX ; $cbbd
************************

          CLRA
          CLRB
          STD   STR_TERM_INDEX
          RTS

**********************
Concat_Strings ; $cbc2
**********************

          LDB   [ACB_M2]
          LDX   ACA_M2
          ADDB  ,X
          BCC   ConS_10
          LDB   #15 ; TOO COMPLEX
          JMP   Print_Error_B

****************************
Copy_String_X_FRESPC ; $cbd0
****************************

          LDU   FRESPC
          INCB
          BRA   CSXF_20
CSXF_10   LDA   ,X+
          STA   ,U+
CSXF_20   DECB
          BNE   CSXF_10
          STU   FRESPC
          RTS

ConS_10   BSR   Allocate_String_B
          BSR   Load_XB_DSD_ACB
          BSR   Load_XB_DSD_ACA
          BSR   Copy_String_X_FRESPC
          BSR   Load_XB_DSD_ACB
          BSR   Copy_String_X_FRESPC

***************************
Bra_Push_Descriptor ; $cbeb
***************************

          BRA   Push_Descriptor

*************************
Allocate_String_B ; $cbed
*************************

          JSR   Allocate_String

*******************
BX_To_DESCA ; $cbf0
*******************

          STX   DSA_ADR
          STB   DSA_LEN
          RTS

*******************
Eval_String ; $cbf5
*******************

          JSR   Dec_Eval_Exp

************************
Eval_String_Desc ; $cbf7
************************

          JSR   Assert_ACA_Desc

***********************
Load_XB_DSD_ACA ; $cbf9
***********************

          LDU   ACA_M2
          SKIP2

***********************
Load_XB_DSD_ACB ; $cbfc
***********************

          LDU   ACB_M2

*******************
Load_Desc_U ; $cbfe
*******************

          CMPU  TEMPST
          BNE   LoDU_10
          STU   TEMPPT
          LEAX  -3,U
          STX   TEMPST
LoDU_10   LDX   1,U
          LDB   ,U
          RTS

****************
FUNC_ASC ; $cc0e
****************

          BSR   LDB_FChar
          FCB   $8c ; SKIP2

****************
FUNC_LEN ; $cc11
****************

          BSR   Eval_String_Desc
          JMP   B_To_ACA

*******************
Need_String ; $cc15
*******************

          JSR   Dec_Eval_Exp

*****************
LDB_FChar ; $cc17
*****************

          BSR   Eval_String_Desc
          BEQ   MID_Err
          LDB   ,X
          RTS

******************
FUNC_RIGHT ; $cc1e
******************

          BSR   Get_String_Arg
          LDA   STR_B1
          SUBA  ACA_M3
          FCB   $8c ; skip

*****************
FUNC_LEFT ; $cc25
*****************

          BSR   Get_String_Arg
          CMPB  STR_B1
          BLS   LEFT_10
          CLRA
          LDB   STR_B1
LEFT_10   PSHS  D
          CMPX  TXTTAB
          BCS   LEFT_20
          CMPX  VARTAB
          BCS   LEFT_30
LEFT_20   BSR   Allocate_String_B
LEFT_30   LDU   STR_B3
          BSR   Load_Desc_U
          PULS  B
          ABX
          PULS  B
          CMPX  TXTTAB
          BCS   LEFT_40
          CMPX  VARTAB
          BCS   LEFT_50
LEFT_40   JMP   Store_Push_Descriptor
LEFT_50   BSR   BX_To_DESCA
LEFT_60   BRA   Bra_Push_Descriptor

***************
FUNC_GR ; $cc52
***************

          BSR   Eval_Byte
          ADDB  #$80
          BCS   MID_Err
FUGR_10   STB   ACA_M3
          SKIP2

****************
FUNC_CHR ; $cc5b
****************

          BSR   Eval_Byte
          LDB   #1
          BSR   Allocate_String_B
          LDA   ACA_M3
          STA   ,X
          BRA   LEFT_60

****************
FUNC_MID ; $cc67
****************

          JSR   Get_Arg_Desc
          STB   STR_B2
          BEQ   MID_Err
          LDB   #$ff
          STB   ACA_M3
          JSR   CHRGOT
          CMPA  #$29 ; ')'
          BEQ   MID_10
          BSR   Get_Comma_And_Byte
MID_10    JSR   Need_Right
          DEC   STR_B2
          LDA   STR_B2
          LDB   STR_B1
          SUBB  STR_B2
          BCC   MID_20
          CLRB
MID_20    CMPB  ACA_M3
          BLS   LEFT_10
          LDB   ACA_M3
          BRA   LEFT_10
MID_Err   JMP   Illegal_Quantity

**********************
Get_String_Arg ; $cc90
**********************

          JSR   Get_Arg_Desc
          JSR   Need_Right
          LDD   ACA_M2
          RTS

          FILL $cca3-* ($15)

***********************
Get_Desc_Assert ; $cca3
***********************

          JSR   Dec_Eval_Exp
          JMP   Assert_ACA_Desc

*******************
Get_LINNUM_And_Byte
*******************

          BSR   Get_Number
          STX   LINNUM

**************************
Get_Comma_And_Byte ; $ccab
**************************

          JSR   Need_Comma
          SKIP2

********************
Get_Byte_Var ; $ccae
********************

          JSR   CHRGET

************************
BAS_Byte_Var ; $ccb0
************************

          JSR   Eval_Numeric

*****************
Eval_Byte ; $ccb2
*****************

          JSR   Eval_Positive_Integer
          TSTA
          BNE   MID_Err
          JMP   CHRGOT

******************
Get_Number ; $ccba
******************

          JSR   Eval_Numeric
NUMB_10   JSR   Cast_ACA_Real
          LDA   ACA_SI
          BPL   NUMB_20
          LDX   #MAXINT
          JSR   ACA_PLUS_X
NUMB_20   LDA   ACA_EX
          CMPA  #$90
          BHI   MID_Err
          JSR   ACA_TO_INT
          LDX   ACA_M2
          RTS

*****************
FUNC_PEEK ; $ccd4
*****************

          JSR   Protected
          BSR   NUMB_10
          LDB   ,X
          JMP   B_To_ACA

******************
BASIC_POKE ; $ccdd
******************

          JSR   Protected
          BSR   Get_LINNUM_And_Byte
          LDX   LINNUM
          STB   ,X
          RTS

******************
FUNC_INSTR ; $cce7
******************

          JSR   Dec_Eval_Exp
          LDB   #1            ; default start index
          PSHS  B
          JSR   Test_ACA_Type
          BEQ   INST_10       ; 1st. arg = string
          BSR   Eval_Byte     ; get start index
          STB   ,S            ; overwrite default
          BEQ   MID_Err       ; must be non zero
          JSR   Need_Comma
          BSR   Get_Desc_Assert

INST_10   LDD   ACA_M2       ; haystack descriptor
          PSHS  D
          JSR   Need_Comma
          JSR   Eval_To_Par
          JSR   Eval_String_Desc
          STX   COEFPT        ; address of needle
          STB   Needle        ; length  of needle
          PULS  U             ; haystack descriptor
          JSR   Load_Desc_U
          STB   Haystack      ; length of haystack
          PULS  B             ; start index
          STB   IFCTR
          CMPB  Haystack
          BHI   INST_60       ; index > length
          TST   Needle
          BEQ   INST_50       ; empty needle string
          DECB
          ABX                 ; add offset to haystack

INST_20   STX   RESSGN        ; haystack search start
          LDU   COEFPT        ; needle   search start
          LDA   Haystack      ; haystack length
          SUBA  IFCTR         ; minus start index
          INCA
          CMPA  Needle
          BCS   INST_60       ; less than needle length
          LDB   Needle

INST_30   LDA   ,X+           ; compare
          CMPA  ,U+
          BEQ   INST_40
          INC   IFCTR
          LDX   RESSGN
          LEAX  1,X           ; advance search start
          BRA   INST_20       ; repeat

INST_40   DECB
          BNE   INST_30       ; -> next char

INST_50   LDB   IFCTR         ; success, load index
          SKIP1

INST_60   CLRB
          JMP   B_To_ACA     ; store result

MAXINT    REAL $91000000     ; 65536.0

*********
Print_TAB
*********

          JSR   Eval_Expression
          JSR   FUNC_CINT     ; TAB argument
          JSR   Need_Right
          JSR   Dec_TXTPTR
          CLRA
          CLRB                ; D = 0
          TST   ACA_M2
          BPL   PTAB_10       ; arg positive -> OK
          STD   ACA_M2       ; set negative values to zero

PTAB_10   INCA                ; A = 1
          STD   ACB_M2
          JSR   Device_Context
          BEQ   PTAB_20
          CLR   ACB_M2
          LDA   COLMAX
          STA   ACB_M3

PTAB_20   CLRA
          JSR   OP_MOD
          LDB   ACA_M3       ; target  position
          SUBB  DEVPOS        ; current position
          BCC   PTAB_30       ; -> below target
          JSR   Print_CRLF
          LDB   ACA_M3

PTAB_30   JMP   Print_B_Blanks

*******************
BASIC_PRINT ; $cd7a
*******************

          BEQ   Print_CRLF
          BSR   PRIN_10
          CLR   CHANNEL
          RTS

***************
PRIN_10 ; $cd81
***************

          CMPA  #'#' ; PRINT#
          BNE   PRIN_15
          JSR   Set_Channel
          JSR   Device_Column
          JSR   CHRGOT
          BEQ   Print_CRLF
          JSR   Need_Comma
PRIN_15   CMPA  #TK_USING
          LBEQ  Print_Using
PRIN_20   BNE   PRIN_30
PRIN_Ret  RTS

***************
PRIN_30 ; $cd9a
***************

          CMPA  #TK_TAB
          BEQ   Print_TAB
          CMPA  #TK_SPC
          BEQ   Print_SPC
          CMPA  #','
          BEQ   Print_Comma_Space
          CMPA  #';'
          BEQ   PBB_10
          JSR   Dec_Eval_Exp
          JSR   Test_ACA_Type
          PSHS  A
          BEQ   PRIN_35
          JSR   Format_ACA
          JSR   Create_String_Descriptor

PRIN_35   JSR   Device_Context
          LDD   DEVPOS
          MUL
          BEQ   PRIN_40
          LDX   ACA_M2
          ADDA  ,X
          CMPA  COLMAX
          BLS   PRIN_40
          BSR   Print_CRLF

PRIN_40   BSR   Print_ACA_String
          PULS  A
          TST   PRTDEV
          BEQ   PRIN_50
          BSR   Print_Return
          JSR   CHRGOT

PRIN_45   BRA   PRIN_20

PRIN_50   TSTA
          BEQ   PRIN_55
          JSR   CHRGOT
          CMPA  #','
          BEQ   PRIN_55
          BSR   Print_Blank

PRIN_55   JSR   CHRGOT
          BNE   PRIN_30
          BRA   Print_CRLF

*********************
Print_Newline ; $cde8
*********************

          JSR   Device_Context
          BEQ   Print_CRLF
          LDA   DEVPOS
PrNe_10   BEQ   PRIN_Ret

******************
Print_CRLF ; $cdf0
******************

          BSR   Print_Return
          LDA   #10
          JSR   Device_Context
          TST   PRTDEV
          BEQ   Jmp_Chrout
          RTS


*****************
Print_Comma_Space
*****************

          JSR   Device_Context
          BEQ   PCS_10        ; -> cassette
          LDB   DEVPOS
          CMPB  DEVLCF
          BLO   PCS_20
          SUBB  COLMAX
          BRA   PCS_30

PCS_10    LDB   DEVPOS

PCS_20    SUBB  DEVCFW        ; TAB field width
          BCC   PCS_20

PCS_30    NEGB
          BRA   Print_B_Blanks

*********
Print_SPC
*********

          JSR   Get_Byte_Var
          CMPA  #')'
          BNE   SynErr

**************
Print_B_Blanks
**************

          JSR   Device_Context
          TST   PRTDEV
          BNE   PBB_10
          BSR   PBB_30

PBB_10    JSR   CHRGET
          BRA   PRIN_45

PBB_20    BSR   Print_Blank
          DECB

PBB_30    TSTB
          BNE   PBB_20
          RTS

*******************
Print_Msg_X ; $ce2c
*******************

          JSR   Scan_Quoted_String

*************************
Print_ACA_String ; $ce2f
*************************

          JSR   Load_XB_DSD_ACA

PFS_10    INCB

PFS_20    DECB
          BEQ   PrNe_10
          LDA   ,X+
          BSR   Jmp_Chrout
          BRA   PFS_20

**************
Print_QM_Blank
**************

          BSR   Print_Question_Mark

*******************
Print_Blank ; $ce3e
*******************

          LDA   #' '
          SKIP2

*******************
Print_Question_Mark
*******************

          LDA   #'?'
          SKIP2

************
Print_Return
************

          LDA   #CR

******************
Jmp_Chrout ; $ce46
******************

          JMP   CHROUT

SynErr    JMP   Syntax_Error

**********
List_Range
**********

          LDA   CHANNEL
          BNE   LiRa_10
          LDB   #CAN          ; clear line
          CALL  PUTC
          JSR   Check_Keyboard

LiRa_10   JSR   Print_CRLF
          CMPX  Range_T
          BNE   LiRa_20
          JSR   Close_File
          JMP   Main

LiRa_20   STX   Range_F
          LDD   2,X
          JSR   Print_Integer_D
          JSR   Print_Blank
          LDX   Range_F
          JSR   Uncrunch_Line
          LDX   #BUF_TXT+1

LiRa_30   LDA   ,X+
          BEQ   LiRa_40
          JSR   CHROUT
          BRA   LiRa_30

LiRa_40   LDX   Range_F
          LDX   ,X
          BRA   List_Range

**********************
Get_Line_Range ; $ce82
**********************

          CLRA
          CLRB
          STD   Range_F    ; from 0
          LDX   #63999
          STX   Range_T      ; to   63999
          JSR   CHRGOT
          BEQ   GLR_20
          BSR   GLR_40
          LDX   LINNUM
          STX   Range_F
          JSR   CHRGOT
          BNE   GLR_10
          STX   Range_T
          BRA   GLR_20

GLR_10    LDB   #TK_MINUS
          JSR   Need_B
          BEQ   GLR_20
          BSR   GLR_40
          BSR   Need_EOS
          LDX   LINNUM
          STX   Range_T

GLR_20    LDX   Range_T
          CMPX  Range_F
          BCS   IllQuan
          LEAX  1,X
          STX   LINNUM
          BSR   GLR_30
          STX   Range_T
          LDX   Range_F
          STX   LINNUM

GLR_30    JMP   Find_BASIC_Line

GLR_40    JSR   CHRGOT
          JMP   Scan_Linenumber

********************
BASIC_DELETE ; $cec5
********************

          BNE   DELE_10
IllQuan   JMP   Illegal_Quantity
DELE_10   BSR   Get_Line_Range
          BSR   Delete_Range
          JSR   Clear_Relink
          JMP   Main

****************
Need_EOS ; $ced3
****************

          BEQ   DPL_Ret
Syn_Err   JMP   Syntax_Error

************
Delete_Range
************

          LDU   Range_T

***************************
Delete_Program_Line ; $ced9
***************************

          STX   INDEXD
DPL_10    CMPU  VARTAB
          BEQ   DPL_20
          LDA   ,U+
          STA   ,X+
          BRA   DPL_10
DPL_20    STX   VARTAB
DPL_Ret   RTS

********************
BASIC_DEFSNG ; $cee9
********************

          LDB   #4
          SKIP2

********************
BASIC_DEFSTR ; $ceec
********************

          LDB   #3
          SKIP2

********************
BASIC_DEFINT ; $ceef
********************

          LDB   #2
          STB   PRECED        ; type size

DEF_10    BSR   DEF_50        ; from char
          LDX   #IMPLICIT-'A'
          ABX
          PSHS  B
          CMPA  #TK_MINUS
          BNE   DEF_20
          BSR   DEF_40        ; to char

DEF_20    SUBB  ,S+           ; to - from
          BMI   Syn_Err       ; -> illegal
          LDA   PRECED

DEF_30    STA   ,X+           ; store type in range
          DECB
          BPL   DEF_30
          JSR   CHRGOT
          BEQ   DPL_Ret
          JSR   Need_Comma
          BRA   DEF_10        ; another declaration

DEF_40    JSR   CHRGET

DEF_50    JSR   A_Is_Alpha
          BCC   Syn_Err
          TFR   A,B
          JMP   CHRGET

******************
BASIC_TRON ; $cf1f
******************

          FCB   $86 ; LDA #

*******************
BASIC_TROFF ; $cf20
*******************

          CLRA
          STA   TRCFLG
TRO_Ret   RTS

*******************
BASIC_ERROR ; $cf24
*******************

          JSR   Byte_Var
          BNE   TRO_Ret
          TSTB
          BEQ   IllQuan
Err_B     JMP   Print_Error_B

********************
BASIC_RESUME ; $cf2d
********************

          LDB   #$14          ; Error CAN'T RESUME
          TST   ENDFLG
          BEQ   Err_B         ; -> error
          CLR   ERRNO
          CMPA  #TK_NEXT      ; RESUME NEXT
          BEQ   RESU_40
          JSR   CHRGOT
          BCC   RESU_10       ; -> RESUME
          JSR   Scan_Linenumber
          BNE   RESU_Ret
          JSR   GO_50
          BRA   RESU_20

RESU_10   BSR   Need_EOS
          LDX   ERRLIN
          STX   CURLIN
          LDX   SAVTXT
          STX   TXTPTR

RESU_20   CLR   ENDFLG

RESU_Ret  RTS

RESU_40   JSR   CHRGET        ; RESUME NEXT
          BSR   RESU_10
          TST   ,X+
          BNE   RESU_50
          LEAX  3,X

RESU_50   STX   TXTPTR
          JMP   BASIC_DATA    ; skip line

*****************************************************************
* SEARCH THE STACK FOR FOR/NEXT STRUCTURE.                    *
* THE FOR/NEXT INDEX VARIABLE DESCRIPTOR ADDRESS BEING        *
* SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 19 *
* BYTES WITH A $81 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA   *
* IS CONSIDERED GOSUB/RETURN                                  *
*****************************************************************

********************
Search_Stack ; $cf63
********************

* Output: X = pointer to FOR/NEXT or GOSUB/RETURN structure
*         A = identifier token (flags set with TST A)

          LEAX  4,S            ; point X to 3rd. address on stack

**********************
Search_Stack_X ; $cf65
**********************

          STX   XSAV           ; save pointer
          LDA   ,X             ; identifier token
          LDB   #19            ; size of loop structure on stack
          SUBA  #TK_FOR        ; A = 0 for match
          BNE   SeSt_20        ; -> not FOR/NEXT
          LDX   1,X            ; address of index variable
          STX   TMPTR1         ; save it
          LDX   VARDES         ; get index variable being searched for
          BEQ   SeSt_10        ; -> not specified
          CMPX  TMPTR1         ; compare with stack variable
          BEQ   SeSt_20        ; -> match
          LDX   XSAV           ; restore pointer to loop structure
          ABX                  ; add loop structure size (19)
          BRA   Search_Stack_X ; -> compare next structure

SeSt_10   LDX   TMPTR1         ; address of index variable
          STX   VARDES         ; define VARDES

SeSt_20   LDX   XSAV           ; X = pointer to structure
          TSTA                 ; A = identfier token
          RTS

***************
R_VALUE ; $cf88
***************

          LDB   #TK_EQ
RVAL_B    JSR   Need_B
RVAL_1    LDA   ACA_SZ
          PSHS  A             ; save size/type
          JSR   Dec_Eval_Exp
          PULS  A             ; restore size/type
          JMP   Type_Cast

***********************************
* loop structure stored on stack  *
* ------------------------------  *
* 17-18 : loop body address       *
* 15-16 : loop body line #        *
* 11-14 : TO   value   packed [4] *
*  5-10 : STEP value unpacked [6] *
*  3- 4 : NEXT address            *
*  1- 2 : index variable          *
*  0    : $81 FOR token           *
***********************************

*****************
BASIC_FOR ; $cf97
*****************

          JSR   Parse_Name     ; get index variable
          STX   VARDES         ; store address
          JSR   Assert_ACA_Numeric
          BSR   R_VALUE        ; get initial value
          LDX   #LOOPV
          JSR   Store_ACA_X   ; save initial value
          LEAS  2,S            ; purge return address
          JSR   Skip_To_EOS    ; skip to loop body
          STX   LPBODY          ; save loop body index
          TFR   S,X            ; X = current stack pointer

FOR_10    JSR   Search_Stack_X ; search FOR/NEXT structure
          ABX                  ; add loop structure size (19)
          BNE   FOR_15         ; -> index variable not in use
          LDD   -2,X           ; D = LS[17/18]
          SUBD  LPBODY          ; compare with body index
          BNE   FOR_10         ; -> loop to next
          LEAS  ,X             ; overwrite old loop structure
          STX   SP_DEF         ; save index

FOR_15    LDB   #10            ; need 10 words = 20 bytes
          JSR   Stack_Free_B   ; check availability
          LDX   LPBODY
          LDD   CURLIN
          PSHS  X,D            ; push loop body and current line #
          LDB   #TK_TO         ; find TO token
          BSR   RVAL_B         ; get end value
          LEAS  -4,S           ; reserve space for TO value
          TFR   S,X
          JSR   Real_ACA_To_X   ; LS[11-14] = end value
          LDX   #1             ; default STEP value
          STX   ACA_M2
          JSR   Test_ACA_Type
          BMI   FOR_20         ; integer loop control
          LDX   #Real_1        ; address of 1.0
          JSR   Load_ACA      ; ACA = 1.0

FOR_20    JSR   CHRGOT
          CMPA  #TK_STEP
          BNE   FOR_25         ; -> use default STEP value
          JSR   CHRGET
          BSR   RVAL_1         ; get step value

FOR_25    JSR   Get_Sign       ; forward or backward step ?
          STB   ACA_SI
          JSR   Push_ACA      ; LS[xx-xx] = step value
          JSR   CHRGOT
          JSR   Need_EOS       ; nothing after STEP value
          CLRB
          LDX   CURLIN
          STX   LPBODY
          JSR   Dec_TXTPTR

FOR_30    INCB                ; # of NEXT statements

FOR_35    JSR   CHRGET
          BEQ   FOR_40        ; -> EOS
          INCA                ; check for $ff
          BNE   FOR_50        ; -> no $FF
          JSR   CHRGET        ; char after $ff
          BRA   FOR_35        ; continue

FOR_40    TSTA
          BNE   FOR_35        ; ':' ->  continue counting
          LDX   TXTPTR
          LDU   1,X           ; link
          BNE   FOR_45        ; -> not at end of program
          LDB   #$17          ; FOR without NEXT error
          JMP   Print_Error_B

FOR_45    LEAX  3,X           ; X = next line
          LDU   ,X+           ; U = link
          STU   LPBODY
          STX   TXTPTR        ; update TXTPTR
          BRA   FOR_35        ; -> scan next line

FOR_50    CMPA  #TK_NEXT
          BEQ   FOR_30
          CMPA  #TK_DATA
          BNE   FOR_35

FOR_55    DECB                ; # of NEXT statements
          BEQ   FOR_60        ; -> all found: OK
          JSR   CHRGET
          BEQ   FOR_40
          LDX   LPBODY
          STX   CURLIN
          PSHS  B
          JSR   Parse_Name    ; variable name after NEXT
          PULS  B
          LDX   10,S
          STX   CURLIN
          JSR   CHRGOT
          BEQ   FOR_40        ; -> end of next statement
          CMPA  #','          ; more NEXT variables ?
          BEQ   FOR_55        ; -> get another NEXT variable
          JMP   Syntax_Error

FOR_60    JSR   CHRGET
          LDU   TXTPTR        ; LS[3-4] NEXT address
          LDX   VARDES        ; LS[1-2] index variable
          LDA   #TK_FOR       ; LS[0]   marker
          PSHS  U,X,A         ; complete loop structure 0-4
          LDX   LPBODY
          STX   CURLIN
          BSR   FOR_65
FOR_65    FCB   $86           ; LDA #$4f -> start loop execution

******************
BASIC_NEXT ; $d05c
******************

          CLRA                ; A = 0
          STA   NXTFLG        ; not zero -> initial execution
          LDX   ZERO_W        ; X = 0

NEXT_10   STX   VARDES        ; initialize index variable
          LDX   TXTPTR
          STX   LPBODY        ; save pointer to NEXT
          JSR   CHRGOT
          BEQ   NEXT_20       ; -> no variable given
          JSR   Parse_Name
          STX   VARDES

NEXT_20   JSR   Search_Stack
          BEQ   NEXT_40

NEXT_30   LDB   #1            ; NEXT WITHOUT FOR ERROR
          JMP   Print_Error_B

NEXT_40   TFR   X,S           ; S = loop structure
          LDX   3,X
          CMPX  LPBODY        ; compare with current NEXT
          BNE   NEXT_30       ; -> error
          LDA   5,S           ; size/type STEP value
          STA   ACA_SZ
          STA   ACB_SZ
          LDA   NXTFLG
          BEQ   NEXT_70       ; -> normal pass
          LDX   #LOOPV
          JSR   Load_ACA     ; load initial value

NEXT_50   JSR   ACA_To_VARDES ; update index variable
          LEAX  11,S
          JSR   Load_ACB      ; load TO value
          JSR   Cmp_ACA_ACB  ; compare variable with TO value
          ADDB  10,S           ; add sign of STEP
          BEQ   NEXT_80        ; -> end loop
          LDX   15,S           ; loop body line #
          STX   CURLIN
          LDX   17,S           ; loop body address
          STX   TXTPTR

NEXT_60   JMP   Interpret      ; next pass

NEXT_70   LDX   VARDES
          JSR   Load_ACA      ; ACA = index value
          LEAX  6,S
          JSR   Load_ACB      ; ACB = STEP value
          LDB   10,S           ; STEP sign
          STB   ACB_SI
          LDA   ACA_SZ
          PSHS  A              ; save size/type
          JSR   OP_PLUS        ; ACA += ACB
          LDA   ACA_SZ
          CMPA  ,S+            ; ACA type == TO type ?
          BEQ   NEXT_50        ; -> compare

NEXT_80   LEAS  19,S           ; advance stack pointer
          LEAX  ,S
          STX   SP_DEF         ; new starting point for stack search
          JSR   CHRGOT
          CMPA  #','
          BNE   NEXT_60        ; -> resume execution after NEXT
          JSR   CHRGET         ; another variable after NEXT
          CLR   NXTFLG
          BSR   NEXT_10        ; -> go to outer loop

*******************
FUNC_VARPTR ; $d0d9
*******************

          JSR   Parse_Name
          STX   ACA_M2
          JSR   LDD_ACA_Integer
          JMP   Need_Right

***********
Print_Using
***********

          JSR   CHRGET
          JSR   Eval_String
          LDB   #';'
          JSR   Need_B
          LDB   ,U
          CLRA
Usi_10    PSHS  X,B
Usi_15    STA   Use_Flag
          TSTB
          BEQ   Usi_45
          CLR   Use_Dot
          CLR   Use_Befo
Usi_20    LDA   ,X+
          CMPA  #'^'
          BEQ   Usi_40
          CMPA  #'+'
          BNE   Usi_25
          LDA   #8            ; use '+' sign
          BRA   Usi_30
Usi_25    CMPA  #'*'
          BNE   Usi_35
          LDA   #$20          ; use '*' as leading zeroes
Usi_30    ORA   Use_Flag
          STA   Use_Flag
          BRA   Usi_40
Usi_35    CMPA  #'#'
          BEQ   Usi_60
          CMPA  # '.'
          BEQ   Usi_90
          JSR   CHROUT
Usi_40    DECB
          BNE   Usi_20
Usi_45    PULS  X,B
          JSR   CHRGOT
          LBEQ  Print_CRLF
          CMPA  #';'
          BNE   Usi_50
          JMP   CHRGET
Usi_50    LDA   Use_Flag
          BEQ   Usi_55
          BRA   Usi_10
Usi_55    JMP   Illegal_Quantity
Usi_60    INC   Use_Befo
          DECB
          BEQ   Usi_75
          LDA   ,X+
          CMPA  #'#'
          BEQ   Usi_60
          CMPA  #'.'
Usi_65    BEQ   Usi_90
          CMPA  #'^'
          BNE   Usi_70
          INC   Use_Flag
Usi_70    LEAX  -1,X
Usi_75    LDA   Use_Flag
          BITA  #8
          BEQ   Usi_80        ; -> suppress '+' sign
          INC   Use_Befo    ; count space for sign
Usi_80    LDA   Use_Befo
          ADDA  Use_Dot
          CMPA  #$18
          BCC   Usi_55        ; -> format too long
          LDA   #$80          ; set bit 7 of flag
          ORA   Use_Flag
          STA   Use_Flag   ; finished format scan
          JSR   CHRGOT
          BEQ   Usi_45
          PSHS  X,B
          JSR   Eval_Numeric
          JSR   Form_10
          LEAX  -1,X
          JSR   Print_Msg_X
          PULS  X,B
          JSR   CHRGOT
          BEQ   Usi_85
          CMPA  #';'
          BEQ   Usi_85
          CMPA  #','
          LBNE  Syntax_Error
          JSR   CHRGET
Usi_85    LDA   #$80
          LBRA  Usi_15        ; set bit 7
Usi_90    INC   Use_Dot
          DECB
          BEQ   Usi_75
          LDA   ,X+
          CMPA  #'#'
          BRA   Usi_65

************
Hex_Constant
************

          JSR   CHRGET        ; skip &
          JSR   CHRGET        ; read base identifier
          CMPA  #'H'          ; hex ?
          BNE   IF1I_Ret      ; -> return if not hex

Hex_10    JSR   CHRGET
          BCS   Hex_20
          CMPA  #'G'          ; 'F'+1
          JSR   A_Is_Alpha_Range
          LBCC  INT1_TO_ACA  ; -> convert and return
          SUBA  #7            ; subtract gap 'A' - '9'

Hex_20    SUBA  #'0'
          LDB   #4            ; shift ACA 4 times

Hex_30    ASL   ACA_M3
          ROL   ACA_M2
          LBCS  OVERFLOW
          DECB
          BNE   Hex_30
          ADDA  ACA_M3       ; add digit
          STA   ACA_M3
          BRA   Hex_10

*************
Add_Dec_Digit
*************

          CMPA  #2            ; integer ?
          BNE   ADDI_10       ; -> no
          LDA   ACA_M3
          ANDA  #15
          BEQ   ADDI_10
          JSR   Cast_ACA_Real

ADDI_10   JSR   ACA_MULT_10

ADDI_20   JSR   ACA_TO_ACB
          PULS  B
          CLRA
          JSR   D_To_Real
          JSR   ACA_PLUS_ACB
          BRA   RRTF_10

***************
Is_ACA_Integer
***************

          LDA   ACA_SZ
          SUBA  #2
IF1I_Ret  RTS

*************************
Read_Real_To_ACA ; $d1e3
*************************

          CLRB
          JSR   BAS_B_To_ACA ; preset value with zero
          STD   INDEXD
          STD   INDEXC
          BSR   Read_Sign
          CMPA  #'&'          ; special prefix
          BEQ   Hex_Constant  ; -> hex
          STB   COEFCT        ; $00 = +, $ff = -

RRTF_10   JSR   CHRGET
          BCC   RRTF_20       ; -> not numeric
          LDB   INDEXC        ; load decimal counter
          SUBB  INDEXC+1      ;
          STB   INDEXC        ; save decimal counter
          SUBA  #'0'          ; ASCII -> binary
          PSHS  A             ; save digit
          BSR   Is_ACA_Integer
          BNE   Add_Dec_Digit ; -> multiply with 10.0
          LDB   #10
          STD   ACB_M2       ; ACB = 10
          JSR   Mult_Integer
          BSR   Is_ACA_Integer
          BNE   ADDI_20
          PULS  B
          STD   ACB_M2
          JSR   ADD_Integer   ; value = value * 10 + digit
          BRA   RRTF_10       ; -> loop

RRTF_20   CMPA  #'.'          ; decimal point ?
          BEQ   RRTF_40         ; -> yes
          CMPA  #'!'          ; single precision marker
          BEQ   RRTF_45
          CMPA  #'E'          ; start of exponent ?
          BNE   RRTF_50
          JSR   Cast_ACA_Real
          BSR   Read_Sign     ; sign of exponent
          STB   INDEXD+1

RRTF_30   JSR   CHRGET
          BCS   RRTF_65         ; -> numeric
          TST   INDEXD+1      ; test exponent sign
          BEQ   RRTF_50         ; -> positive
          NEG   INDEXD        ; negate exponent value
          BRA   RRTF_50

*****************
Read_Sign ; $d237
*****************

          JSR   CHRGET
          CLRB
          CMPA  #'-'
          BEQ   ReSi_10
          CMPA  #TK_MINUS
          BEQ   ReSi_10
          CMPA  #'+'
          BEQ   ReSi_Ret
          CMPA  #TK_PLUS
          BEQ   ReSi_Ret
          JMP   Dec_TXTPTR
ReSi_10   COMB
ReSi_Ret  RTS

RRTF_40   COM   INDEXC+1      ; toggle point flag
          BEQ   RRTF_50       ; 2nd. decimal point
          BSR   Is_ACA_Integer
          BNE   RRTF_10
          BSR   ACA_Int_To_Real
          BRA   RRTF_10

RRTF_45   JSR   Cast_ACA_Real
          JSR   CHRGET

RRTF_50   LDA   INDEXD        ; load exponent
          SUBA  INDEXC        ; decimal digits
          STA   INDEXD        ; save exponent
          BEQ   RRTF_60       ; -> exponent is zero
          BPL   RRTF_55
          JSR   Apply_Neg_Exp
          BRA   RRTF_60

RRTF_55   JSR   ACA_MULT_10  ; apply positive exponent
          DEC   INDEXD
          BNE   RRTF_55

RRTF_60   LDA   COEFCT        ; sign flag
          BMI   Negate_Real_Or_Int
          RTS

RRTF_65   LDB   #10
          CMPB  INDEXD
          BLS   RRTF_70
          PSHS  A
          LDA   INDEXD
          MUL                 ; D = exponent * 10
          ADDB  ,S+           ; add digit
          SUBB  #'0'          ; subtract ASCII offset
          SKIP2

RRTF_70   LDB   #$32
          STB   INDEXD        ; store new exponent
          BRA   RRTF_30

**************************
Negate_Real_Or_Int ; $d28f
**************************

          JSR   Test_ACA_Type
          BMI   Nega_10

*******************
Negate_ACA ; $d293
*******************

          TST   ACA_EX
          BEQ   NeF1_Ret
          COM   ACA_SI
NeF1_Ret  RTS

OPMI_10   BSR   Cast_Both_FAC
OPMI_20   JMP   ACB_MINUS_ACA

****************
OP_MINUS ; $d29f
****************

          JSR   Test_ACA_Type
          BPL   OPMI_20
          LDD   ACA_M2
          SUBD  ACB_M2
          BVS   OPMI_10

***************************
Return_ACA_Integer ; $d2a9
***************************

          STD   ACA_M2
          RTS

***************
OP_PLUS ; $d2ac
***************

          JSR   Test_ACA_Type
          BPL   OPPL_10

*******************
ADD_Integer ; $d2b0
*******************

          LDD   ACA_M2
          ADDD  ACB_M2
          BVC   Return_ACA_Integer
          BSR   Cast_Both_FAC
OPPL_10   JMP   ACA_PLUS_ACB

*********************
Cast_Both_FAC ; $d2bb
*********************

          BSR   ACA_Int_To_Real
          LDD   ACB_M2
          PSHS  D
          JSR   ACA_TO_ACB
          BRA   Pushed_To_Real

***********************
ACA_Int_To_Real ; $d2c6
***********************

          LDD   ACA_M2

*****************
D_To_Real ; $d2c8
*****************

          PSHS  D

**********************
Pushed_To_Real ; $d2ca
**********************

          BSR   Jmp_Clear_ACA
          LDD   #$0490        ; type = 4  exp = $90
          STD   ACA_SZ
          LDD   ,S++          ; get integer from stack
          BEQ   Jmp_Clear_ACA
          BPL   PuTR_10
          COM   ACA_SI        ; flip sign
          JSR   NEGATD        ; make integer positive
PuTR_10   STD   ACA_M1        ; insert integer
          JMP   Normalize_ACA

*************
Jmp_Clear_ACA
*************

          JMP   Clear_ACA

Nega_10   BSR   Negate_Integer
          BVS   Mult_60
Nega_Ret  RTS
Mult_60   CLRA
          CLRB
          BRA   ACA_Int_To_Real


Mult_10   BSR   Cast_Both_FAC
Mult_20   JMP   Mult_Real

***************
OP_MULT ; $d2ee
***************

          JSR   Test_ACA_Type
          BPL   Mult_20

* Try from simple to complex multiplications

* 1. 16 x  8 bit using MUL with ACA 16 bit and ACB 8 bit
* 2. 16 x  8 bit using MUL with ACB 16 bit and ACA 8 bit
* 3. 16 x 16 bit real multiplication

********************
Mult_Integer ; $d2f2
********************

* Q = [D,W]= ACA_M2 * ACB_M2 (16 x 16 multiplication)
* The result is in valid signed integer range if either
* D is $0000 and W is positive
* D is $ffff and W is negative
* If this is not the case, branch to real multiplication

          LDD   ACA_M2
          MULD  ACB_M2
          BMI   Mult_30       ; -> negative result
          TSTD
          BNE   Mult_10       ; -> integer overflow
          TSTW
          BMI   Mult_10       ; -> integer overflow
          BRA   Mult_40       ; -> OK

Mult_30   INCD                ; -> $ffff -> $0000 ?
          BNE   Mult_10       ; -> integer overflow
          TSTW
          BPL   Mult_10       ; -> integer overflow

Mult_40   STW   ACA_M2        ; OK
          RTS

************
Get_Arg_Desc
************

          JSR   Get_Desc_Assert
          JMP   Get_Comma_And_Byte

          FILL $d32f-* ($15)

* prepare integer for signed multiplication

* ACA pos   ACB pos   -> OK
* ACA pos   ACB neg   -> negate ACB
* ACA neg   ACB pos   -> negate ACA
* ACA neg   ACB neg   -> negate both

* return with D = integer 1

**************
Prep_Int_Signs
**************

          LDA   ACA_M2
          EORA  ACB_M2
          STA   SGNEOR
          LDA   ACB_M2
          BPL   PIS_10
          CLRA                ; negate ACB
          CLRB
          SUBD  ACB_M2
          STD   ACB_M2
PIS_10    LDD   ACA_M2
          BPL   NegI_Ret

**********************
Negate_Integer ; $d343
**********************

          CLRA
          CLRB
          SUBD  ACA_M2
          STD   ACA_M2
NegI_Ret  RTS


* integer division

*************
OP_AT ; $d34a
*************

          LDD   ACB_M2        ; load divisor
          LBEQ  DIV_ZERO
          CLRD                ; clear upper half of Q
          LDW   ACA_M2        ; load dividend
          BPL   OPAT_10
          DECD                ; extend sign
OPAT_10   DIVQ  ACB_M2
          STW   ACA_M2        ; store quotient
          RTS

          FILL $d377-* (0)

**************
OP_MOD ; $d377
**************

          BSR   OP_AT
          STD   ACA_M2
          RTS

          FILL $d385-* (0)

*****************
Load_ACB ; $d385
*****************

          LDD   ,X++
          STA   ACB_EX
          STB   ACB_SI
          ORB   #$80
          STB   ACB_M1
          LDD   ,X++
          STD   ACB_M2
LFA2_Ret  RTS

********************
X_MINUS_ACA ; $d394
********************

          BSR   Load_ACB

***********************
ACB_MINUS_ACA ; $d396
***********************

          COM   ACA_SI
          FCB   $8c

*******************
ACA_PLUS_X ; $d399
*******************

          BSR   Load_ACB

********************
ACA_PLUS_ACB ; $d39b
********************

          LDA   ACB_EX
          BEQ   LFA2_Ret      ; ACB = 0 -> return
          LDB   ACA_EX
          LBEQ  ACB_TO_ACA    ; ACA = 0 -> result = ACB
          CLR   ACA_RN        ; clear rounding byte
          LDB   ACB_SI
          EORB  ACA_SI
          STB   SGNEOR        ; signs
          LDX   #ACB_EX
          LDB   ACB_EX
          SUBB  ACA_EX
          BEQ   FPF_20        ; -> equal exponents
          BCS   FPF_10        ; -> ACA > ACB
          STA   ACA_EX
          LDA   ACB_SI
          STA   ACA_SI
          LDX   #ACA_EX
          NEGB
FPF_10    JSR   Adjust_Exponent
          STA   ACA_RN
FPF_20    CLRB
          ORB   SGNEOR
          BPL   FPF_30
          COM   1,X
          COM   2,X
          COM   3,X
          LDA   ACA_RN
          COMA
          ADCA  #0
          STA   ACA_RN
FPF_30    LDD   ACA_M2        ; add mantissas
          ADCB  ACB_M3
          ADCA  ACB_M2
          STD   ACA_M2
          LDA   ACA_M1
          ADCA  ACB_M1
          STA   ACA_M1
          LDB   SGNEOR
          BPL   Norm_60

**************************
Normalize_On_Carry ; $d3eb
**************************

          BCS   Normalize_ACA
          BSR   Complement_ACA

**********************
Normalize_ACA ; $d3ef
**********************

          LDA   ACA_M1
          BMI   Norm_50       ; -> normalized already
          CLRB
          STB   COUNT

Norm_10   LDA   ACA_M1
          BNE   Norm_20
          LDD   ACA_M2        ; shift mantissa bytewise
          STD   ACA_M1
          LDA   ACA_RN
          STA   ACA_M3
          DEC   COUNT
          CLR   ACA_RN
          LDB   COUNT
          CMPB  #$fc           ; shifted more than 3 bytes ?
          BNE   Norm_10
          BRA   Clear_ACA      ; mantissa was zero

Norm_20   ASLB                 ; byte count -> bit count
          ASLB
          ASLB
          TSTA
          BRA   Norm_40

Norm_30   DECB
          ASL   ACA_RN        ; shift mantissa 1 bit
          ROL   ACA_M3
          ROL   ACA_M2
          ROL   ACA_M1

Norm_40   BPL   Norm_30       ; -> repeat
          ADDB  ACA_EX        ; adjust exponent
          STB   ACA_EX
          BCC   Clear_ACA     ; -> underflow

Norm_50   CLRA
          ASL   ACA_RN        ; rounding bit -> carry
          STA   ACA_RN
          BRA   Norm_80

Norm_60   BCC   Norm_50

Norm_70   INC   ACA_EX
          LBEQ  OVERFLOW
          ROR   ACA_M1
          ROR   ACA_M2
          ROR   ACA_M3

Norm_80   BCC   Norm_Ret
          BSR   Round_Up
          BEQ   Norm_70
Norm_Ret  RTS

***************
Complement_ACA
***************

          COM   ACA_SI

***********************
Complement_Mant ; $d443
***********************

          COM   ACA_M1
          COM   ACA_M2
          COM   ACA_M3

********
Round_Up
********

          INC   ACA_M3
          BNE   Round_Ret
          INC   ACA_M2
          BNE   Round_Ret
          INC   ACA_M1
Round_Ret RTS

******************
Clear_ACA ; $d454
******************

          CLR   ACA_M2
          CLR   ACA_M3

*****************************
Clear_ACA_except_INT ; $d458
*****************************

          CLRA
          CLRB
          STD   ACA_EX
          STD   ACA_SI
          RTS

***********************
Adjust_Exponent ; $d45f
***********************

          CMPB  #$f8
          BLE   AdEx_30       ; -> use byte shift
          CLRA
          ASR   FPCARY
          ROR   1,X
          BRA   AdEx_50       ; -> use bit shift

AdEx_10   LDX   #ACC_M1-1      ; work space

AdEx_20   LDA   3,X           ; LSB of mantissa
          PSHS  B             ; save B
          STA   ACA_RN        ; to rounding byte
          LDD   1,X           ; shift mantissa 1 byte right
          STD   2,X
          LDA   FPCARY        ; all 0 or all 1
          STA   1,X           ; store as MSB of mantissa
          PULS  B             ; restore B

AdEx_30   ADDB  #8
          BLE   AdEx_20       ; -> exp diff < -8
          LDA   ACA_RN
          SUBB  #8            ; cast out previous addition
          BEQ   AdEx_Ret      ; -> finished

AdEx_40   ASR   1,X

AdEx_50   ROR   2,X
          ROR   3,X
          RORA
          INCB
          BNE   AdEx_40       ; repeat bit shift

AdEx_Ret  RTS

* multiply ACA mantissa by ACB
* normalize high order bytes of product in ACA
* low order bytes are stored in ACD

*************
MUL_ACA_ACB ; $d492
*************

          CLRA                ; zero out mantissa of ACC
          CLRB
          STD   ACC_M1
          STD   ACC_M2
          LDB   ACA_M3        ; load LSB of ACA
          BSR   ADD_MUL       ; multiply by ACB
          LDB   ACA_RN        ; load rounding byte
          STB   ACD_M3        ; save temporarily
          LDB   ACA_M2
          BSR   ADD_MUL
          LDB   ACA_RN
          STB   ACD_M2
          LDB   ACA_M1
          BSR   ADMU_10
          LDB   ACA_RN
          STB   ACD_M1
          RTS

********************
ACA_MULT_10 ; $d4b1
********************

          LDX   #Real_10

*******************
ACA_MULT_X ; $d4b4
*******************

          JSR   Load_ACB

*********
Mult_Real
*********

          BSR   Load_Exponents

MuRe_10   BEQ   Clear_ACA
          TSTA
          BEQ   Clear_ACA
          PSHS  B
          BSR   MUL_ACA_ACB

MuRe_20   JSR   ACC_M_TO_ACA
          LDA   #$80
          STA   ACA_EX
          JSR   Normalize_ACA
          CLRA
          LDB   ACB_EX
          ADDB  ,S+
          ADCA  #0
          ADDB  ACA_EX
          STB   ACA_EX
          ADCA  #0

MuRe_30   BEQ   MuRe_10
          DECA
          BEQ   LoEx_Ret

****************
OVERFLOW ; $d4de
****************

          LDB   #6
          SKIP2

********
DIV_ZERO
********

          LDB   #11
          JMP   Print_Error_B

* multiply ACB mantissa by register B and
* add product to ACC mantissa

***************
ADD_MUL ; $d4e5
***************

          BEQ   AdEx_10       ; shift ACC 1 byte right

ADMU_10   COMA                ; set carry

ADMU_20   RORB                ; rotate shift counter and value
          BEQ   AdEx_Ret      ; -> branch if 8 shifts done
          PSHS  B             ; push B
          BCC   ADMU_30       ; -> do not add
          LDD   ACC_M2
          ADDB  ACB_M3
          ADCA  ACB_M2
          STD   ACC_M2
          LDA   ACC_M1
          ADCA  ACB_M1
          STA   ACC_M1

ADMU_30   ROR   ACC_M1
          ROR   ACC_M2
          ROR   ACC_M3
          ROR   ACA_RN
          CLRB                ; clear carry
          ORB   ,S+
          BRA   ADMU_20       ; branch with carry cleared

**********************
Load_Exponents ; $d50a
**********************

          LDA   ACB_SI
          EORA  ACA_SI
          STA   ACA_SI
          LDA   ACB_EX
          LDB   ACA_EX
LoEx_Ret  RTS

DIV_15    RORB
          RORB
          RORB
          STB   ACA_RN
          BRA   MuRe_20

**************
OP_DIV ; $d51c
**************

          JSR   Test_ACA_Type
          BPL   ACB_DIV_ACA
          JSR   Cast_Both_FAC
          BRA   ACB_DIV_ACA

******************
X_DIV_ACA ; $d525
******************

          JSR   Load_ACB

*********************
ACB_DIV_ACA ; $d528
*********************

          BSR   Load_Exponents
          BEQ   DIV_ZERO
          TSTA
          BEQ   MuRe_30
          NEGB
          INCB
          PSHS  B
          LDX   #ACC_M1
          LDD   #$0301
          STA   COUNT
DIV_20    BSR   DIV_40
          BNE   DIV_25
          COMA
DIV_25    TFR   CC,A
          ROLB
          BCC   DIV_30
          TST   COUNT
          BEQ   DIV_15
          STB   ,X+
          LDB   #1
          DEC   COUNT
          BNE   DIV_30
          LDB   #$40 ; '@'
DIV_30    PSHS  B
          TFR   A,CC
          BCC   DIV_35
          LDD   ACB_M2
          SUBB  ACA_M3
          SBCA  ACA_M2
          STD   ACB_M2
          LDA   ACB_M1
          SBCA  ACA_M1
          STA   ACB_M1
DIV_35    ASL   ACB_M3
          ROL   ACB_M2
          ROL   ACB_M1
          PULS  B
          BCS   DIV_25
          BMI   DIV_20
          BRA   DIV_25
DIV_40    PSHS  B
          LDD   ACA_M1
          SUBD  ACB_M1
          BNE   DIV_45
          LDA   ACA_M3
          SUBA  ACB_M3
DIV_45    PULS  PC,B

****************
Get_Sign ; $d583
****************

          JSR   Assert_ACA_Numeric
          BPL   GeSi_40
          LDD   ACA_M2
          BNE   GeSi_50

GeSi_10   CLRA
          CLRB

GeSi_Ret  RTS

GeSi_Pos  LDD   #1
          RTS

GeSi_40   LDB   ACA_EX
          BEQ   GeSi_10
          LDB   ACA_SI

GeSi_50   BPL   GeSi_Pos
          LDD   #-1
          RTS

****************
FUNC_ABS ; $d59e
****************

          BSR   Get_Sign
          BPL   GeSi_Ret
ABS_10    JMP   Negate_Real_Or_Int

CmpAB_10  LDB   ACB_M2
          LDA   ACA_M2
          EORA  ACB_M2
          BMI   CmpAB_30
          LDD   ACB_M2
          SUBD  ACA_M2
CmpAB_20  BEQ   GeSi_10
          RORB
CmpAB_30  TSTB
          BRA   GeSi_50

*******************
Cmp_ACA_ACB ; $d5b7
*******************

          JSR   Test_ACA_Type
          BMI   CmpAB_10
          LDB   ACB_SI
          LDA   ACA_SI
          EORA  ACB_SI
          BMI   CmpAB_30
          LDA   ACA_EX
          CMPA  ACB_EX
          BNE   CmpAB_40
          TSTA
          BEQ   GeSi_10
          BSR   DIV_40
CmpAB_40  BSR   CmpAB_20
          BEQ   FATOI_Ret
          TST   ACB_SI
          BMI   FATOI_Ret
          JMP   NEGATD

****************
FUNC_SGN ; $d5d9
****************

          BSR   Get_Sign

*********************
BAS_B_To_ACA ; $d5db
*********************

          SEX

*********************
BAS_D_To_ACA ; $d5dc
*********************

          STD   ACA_M2
          BRA   LDD_ACA_Integer

****************
FUNC_FIX ; $d5e0
****************

          JSR   Test_ACA_Type
          BMI   FATOI_Ret
          BSR   Get_Sign
          BPL   FUNC_INT
          COM   ACA_SI
          BSR   FUNC_INT
          BRA   ABS_10

*******************
ACA_TO_INT ; $d5ee
*******************

          LDB   ACA_EX
          LBEQ  Clear_ACA
          SUBB  #$98
          LDA   ACA_SI
          BPL   FATOI_10
          COM   FPCARY
          JSR   Complement_Mant
FATOI_10  LDX   #ACA_EX
          JSR   Adjust_Exponent
          CLR   FPCARY

*****************
FATOI_Ret ; $d607
*****************

          RTS

****************
FUNC_INT ; $d608
****************

          LDB   ACA_EX
          BSR   BAS_Assert_ACA_Num
          BMI   FATOI_Ret
          CMPB  #$98
          BCC   FATOI_Ret
          BSR   ACA_TO_INT
          STB   ACA_RN
          LDA   ACA_SI
          STB   ACA_SI
          SUBA  #$80
          LDA   #$98
          STA   ACA_EX
          LDA   ACA_M3
          STA   ENDCHR
          JMP   Normalize_On_Carry

*****************
FUNC_CINT ; $d627
*****************

          BSR   BAS_Assert_ACA_Num
          BMI   LDD_Integer
          LDB   ACA_EX
          BEQ   BAS_B_To_ACA
          CMPB  #$90
          BCS   CINT_10
CINT_Err  JMP   OVERFLOW
CINT_10   LDA   ACA_SI
          PSHS  A
          CLR   ACA_SI
          BSR   ACA_TO_INT
          TSTA
          BPL   CINT_20
          LDD   ACA_M2
          ADDD  #$0001
          BVS   CINT_Err
          STD   ACA_M2
CINT_20   LDA   ,S+
          BPL   LDD_ACA_Integer
          JSR   Negate_Integer

************************
LDD_ACA_Integer ; $d651
************************

          LDA   #2
          STA   ACA_SZ

*******************
LDD_Integer ; $d655
*******************

          LDD   ACA_M2
LFI_Ret   RTS

*******************************
BAS_Assert_ACA_Num ; $d658
*******************************

          JSR   Test_ACA_Type
          BNE   LFI_Ret ; -> numeric

*********************
TYPE_MISMATCH ; $d65c
*********************

          LDB   #13
          JMP   Print_Error_B

****************************
BAS_Assert_ACA_Desc ; $d660
****************************

          JSR   Test_ACA_Type
          BNE   TYPE_MISMATCH
          RTS

*****************
Type_Cast ; $d665
*****************

          JSR   Set_Type_Flags
          BEQ   BAS_Assert_ACA_Desc
          BMI   FUNC_CINT

**************************
BAS_Cast_ACA_Real ; $d66b
**************************

          BSR   BAS_Assert_ACA_Num
          BVS   LFI_Ret ; already REAL
          JMP   ACA_Int_To_Real

**********
ACB_TO_ACA
**********

          CLRB                ; rounding byte
          LDA   ACB_SI
          STD   ACA_SI
          LDQ   ACB_EX
          STQ   ACA_EX
          RTS

********************
ACA_TO_ACB ; $d680
********************

          LDA   ACA_SI
          STA   ACB_SI
          LDQ   ACA_EX
          STQ   ACB_EX
          RTS

          FILL $d68d-* (0)

*****************
Load_ACA ; $d68d
*****************

          JSR   Test_ACA_Type
          BMI   LACA_10       ; -> integer
          LDD   2,X
          STD   ACA_M2
          CLR   ACA_RN
          LDD   ,X
          STA   ACA_EX
          LBEQ  Clear_ACA
          STB   ACA_SI
          ORB   #$80
          STB   ACA_M1
          RTS

LACA_10   LDD   ,X
          STD   ACA_M2
          RTS

****************
FUNC_SQR ; $d6ab
****************

          JSR   Cast_ACA_Real
          BSR   ACA_TO_ACB
          LDX   #Real_0_5
          BSR   Load_ACA

**************
OP_EXP ; $d6b4
**************

          LDA   ACA_EX
          BEQ   FUNC_EXP
          LDA   ACB_EX
          BNE   OPEX_10
          TST   ACA_SI
          BPL   LOG_30
          JMP   DIV_ZERO
OPEX_10   LDX   #FAC3_EX
          JSR   Store_ACA_X
          CLRB
          LDA   ACB_SI
          BPL   OPEX_20
          JSR   FUNC_INT
          LDX   #FAC3_EX
          JSR   Cmp_ACA_X
          BNE   OPEX_20
          COM   ACB_SI
          LDB   ENDCHR
OPEX_20   PSHS  B
          BSR   ACB_TO_ACA
          BSR   FUNC_LOG
          LDX   #FAC3_EX
          BSR   LOG_20
          BSR   FUNC_EXP
          ROR   ,S+
          LBCS  Negate_Real_Or_Int
          RTS

****************
FUNC_LOG ; $d6f1
****************

          JSR   Cast_ACA_Real
          JSR   Get_Sign
          LBLE  Illegal_Quantity
          LDX   #Sqrt2half
          LDA   ACA_EX
          SUBA  #$80
          PSHS  A
          LDA   #$80
          STA   ACA_EX
          BSR   Jmp_ACA_Plus_X
          LDX   #Sqrt2
          JSR   X_DIV_ACA
          LDX   #Real_1
          JSR   X_MINUS_ACA
          LDX   #logcn2
          BSR   Series_Evaluation
          LDX   #Minus0_5
          BSR   Jmp_ACA_Plus_X
          BSR   Store_ACA_XA
          PULS  B
          SEX
          JSR   D_To_Real
          LDX   #INDEXA
LOG_10    BSR   Jmp_ACA_Plus_X
          LDX   #Ln2
LOG_20    BRA   Jmp_ACA_Mult_X
LOG_30    JMP   Clear_ACA

****************
FUNC_EXP ; $d734
****************

          BSR   Cast_ACA_XA
          LDX   #Rev_Log_2
          BSR   Jmp_ACA_Mult_X
          LDA   ACA_EX
          CMPA  #$88
          BCC   EXP_10
          JSR   FUNC_INT
          LDA   ENDCHR
          ADDA  #$81
          BEQ   EXP_10
          PSHS  A
          LDX   #Real_1
          BSR   LOG_10
          LDX   #INDEXA
          JSR   X_MINUS_ACA
          JSR   Negate_ACA
          LDY   #expcon
          BSR   Eval_Series
          LDA   ACA_EX
          SUBA  #$80
          ADDA  ,S+
          BVS   EXP_Err
          BEQ   LOG_30
          STA   ACA_EX
          CLR   ACA_SI
          RTS

*********************
ACA_Plus_0_5 ; $d76f
*********************

          LDX   #Real_0_5

***********************
Jmp_ACA_Plus_X ; $d772
***********************

          JMP   ACA_PLUS_X

EXP_10    LDA   ACA_SI
          BMI   LOG_30
EXP_Err   JMP   OVERFLOW

*************************
Series_Evaluation ; $d77c
*************************

          TFR   X,Y
          BSR   Store_ACA_XA
          BSR   Jmp_ACA_Mult_X
          BSR   Eval_Series
          LDX   #INDEXA

***********************
Jmp_ACA_Mult_X ; $d787
***********************

          JMP   ACA_MULT_X

************
Store_ACA_XC
************

          LDX   #INDEXC
          BRA   Real_ACA_To_X

***********
Cast_ACA_XA
***********

          JSR   Cast_ACA_Real

************
Store_ACA_XA
************

          LDX   #INDEXA
          BRA   Real_ACA_To_X

* CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
* EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
* OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
* NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
* OF PACKED FLOATING POINT NUMBERS. THE
* POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
* (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0YN)

***********
Eval_Series
***********

          BSR   Store_ACA_XC
          LDB   ,Y+
          STB   COEFCT
          TFR   Y,X

EvSe_10   BSR   Jmp_ACA_Mult_X
          LEAY  4,Y
          TFR   Y,X
          BSR   Jmp_ACA_Plus_X
          LDX   #INDEXC
          DEC   COEFCT
          BNE   EvSe_10

EvSe_Ret  RTS

****************
FUNC_COS ; $d7ae
****************

          JSR   Cast_ACA_Real
          LDX   #PI_Half
          BSR   Jmp_ACA_Plus_X

****************
FUNC_SIN ; $d7b5
****************

          JSR   Cast_ACA_Real
          LDA   ACA_EX
          CMPA  #$77          ; low exp ?
          BLO   EvSe_Ret      ; -> value = argument
          LDX   #Two_Pi_Rev
          BSR   Jmp_ACA_Mult_X
          JSR   ACA_TO_ACB
          JSR   FUNC_INT
          JSR   ACB_MINUS_ACA
          LDX   #Real_0_25
          JSR   X_MINUS_ACA
          LDA   ACA_SI
          PSHS  A
          BPL   SIN_10
          BSR   ACA_Plus_0_5
          LDA   ACA_SI
          BMI   SIN_20
SIN_10    JSR   Negate_ACA
SIN_20    LDX   #Real_0_25
          BSR   Jmp_ACA_Plus_X
          LDA   ,S+
          BPL   SIN_30
          JSR   Negate_ACA
SIN_30    LDX   #VAR_SIN
          BRA   Series_Evaluation

**********************
ACA_To_VARDES ; $d7f1
**********************

          LDX   VARDES

********************
Store_ACA_X ; $d7f3
********************

          JSR   Test_ACA_Type
          BVC   INT1_TO_X

*********************
Real_ACA_To_X ; $d7f7
*********************

          LDA   ACA_EX
          LDB   ACA_SI
          ORB   #$7f          ; B = sign & $7f
          ANDB  ACA_M1        ; B = sign & M1
          STD   ,X            ; store EXP and M
          LDD   ACA_M2
          STD   2,X           ; store M2 and M3
          RTS

*****************
INT1_TO_X ; $d806
*****************

          LDD   ACA_M2
          STD   ,X
          RTS

****************
FUNC_TAN ; $d80b
****************

          JSR   Push_ACA
          BSR   FUNC_SIN
          LDX   #FAC3_EX
          JSR   Store_ACA_X
          JSR   Pull_ACA
          BSR   FUNC_COS
          LDX   #FAC3_EX
          JMP   X_DIV_ACA

**************************
BAS_Set_Type_Flags ; $d821
**************************

          DECA  ; 4 = real
          DECA  ; 3 = descriptor
          DECA  ; 2 = integer
          BLE   SVTF_Ret
          ORCC  #2
SVTF_Ret  RTS

**********************
BAS_Dec_TXTPTR ; $d829
**********************

          TST   TXTPTR+1
          BNE   BDT_10
          DEC   TXTPTR
BDT_10    DEC   TXTPTR+1
          RTS

**************
Msg_in ; $d832
**************

          FCB   " in ",0

*********************
Print_in_Line ; $d837
*********************

          LDX   #Msg_in-1
          BSR   Jmp_Print_Msg_X
          LDD   CURLIN

***********************
Print_Integer_D ; $d83e
***********************

          BSR   Integer_To_Real
          BSR   Format_ACA

***********************
Jmp_Print_Msg_X ; $d842
***********************

          JMP   Print_Msg_X

***********************
Integer_To_Real ; $d845
***********************

          STD   ACA_M2

*******************
INT1_TO_ACA ; $d847
*******************

          JSR   Clear_ACA_except_INT
          LDD   #$0498
          STD   ACA_SZ
          JMP   Normalize_ACA

******************
Format_ACA ; $d852
******************

          CLR   Use_Flag

***************
Form_10 ; $d854
***************

          LDX   #Format_Buffer
          STX   COEFPT
          LDB   #' '
          LDA   Use_Flag
          BITA  #8
          BEQ   Form_15
          LDB   #'+'

Form_15   PSHS  B
          JSR   Get_Sign
          PULS  A
          PSHS  B
          BPL   Form_20
          JSR   Negate_Real_Or_Int
          LDA   #'-'

Form_20   JSR   A_TO_COEFPT
          LDX   COEFPT
          LDB   #'0'
          STB   ,X+
          LDA   Use_Flag
          PULS  B
          LBMI  U_Format
          TSTB
          BNE   Form_25
          CLR   ,X
          LEAX  -2,X
          RTS

Form_25   CLR   INDEXC
          JSR   Test_ACA_Type
          BPL   Form_60
          JSR   Format_Word

Form_30   LDX   #Format_Buffer
          LDB   ,X
          LDA   #' '
          PSHS  B
          LDB   Use_Flag
          BITB  #$20
          PULS  B
          BEQ   Form_35
          LDA   #'*'
          CMPB  #' '
          BNE   Form_35
          TFR   A,B

Form_35   PSHS  B

Form_40   STA   ,X+
          LDB   ,X
          BEQ   Form_45
          CMPB  #'E'
          BEQ   Form_45
          CMPB  #'0'
          BEQ   Form_40
          CMPB  #','
          BEQ   Form_40
          CMPB  #'.'
          BNE   Form_50

Form_45   LDA   #'0'
          STA   ,-X

Form_50   PULS  B
          STB   ,-X
          RTS

Form_55   DECA
          STA   INDEXD
          JSR   Push_ACA
          BSR   Form_75
          JSR   Pull_ACA
          LDB   INDEXD
          COMB
          LDA   INDEXC
          PSHS  B
          CMPA  ,S+
          BCS   FExp_30
          PSHS  B
          LDX   #Format_Buffer+1
          STX   COEFPT
          JSR   DOT_TO_COEFPT
          LDA   ,S+
          JSR   Leading_Zeroes
          BRA   Form_65

Form_60   BSR   Scale_ACA
          LDA   INDEXD
          LDB   #2
          STB   INDEXC
          ADDA  #6
          BMI   Form_55
          CMPA  #6
          BGT   Form_70
          INCA

Form_65   STA   INDEXC
          LDA   #1

Form_70   DECA
          STA   INDEXD

Form_75   BSR   Format_Integer
          LDB   #$ff

Form_80   INCB
          LDA   ,-X
          CMPA  #'0'
          BEQ   Form_80
          CMPA  #'.'
          BEQ   Form_85
          LEAX  1,X

Form_85   STB   INDEXC
          CLR   ,X
          LDB   INDEXD
          BEQ   FExp_30

****************
Form_Exp ; $d927
****************

          LDA   #'+'
          TSTB
          BPL   FExp_10
          LDA   #'-'
          NEGB

FExp_10   STA   1,X
          LDA   #'E'
          STA   ,X++
          LDA   #'0'-1

FExp_20   INCA
          SUBB  #10
          BCC   FExp_20
          ADDB  #'9'+1
          STD   ,X++
          CLR   ,X
          STX   COEFPT

FExp_30   LDX   #Format_Buffer

FExp_Ret  RTS

*****************
Scale_ACA ; $d948
*****************

          CLRA
SACA_10   STA   INDEXD
          LDB   ACA_EX
          LDX   #R1E6-1
          CMPB  ,X+
          BHI   SACA_20
          JSR   ACA_MULT_X    ; 1.0E6
          LDA   #-6           ; adjust exponent
          ADDA  INDEXD
          BRA   SACA_10

SACA_20   LDX   #Nine6        ; 999999
          JSR   Cmp_ACA_X
          BLS   SACA_30
          JSR   ACA_DIV_10
          INC   INDEXD
          BRA   SACA_20

SACA_30   LDX   #Nine5        ; 99999.9
          JSR   Cmp_ACA_X
          BHI   FExp_Ret
          JSR   ACA_MULT_10
          DEC   INDEXD
          BRA   SACA_30

**********************
Format_Integer ; $d97b
**********************

          JSR   ACA_Plus_0_5  ; round
          JSR   ACA_TO_INT    ; convert
          LDX   #MANTEN
          LDB   #$80

FoIn_10   BSR   Dec_Digit_Count

FoIn_20   CLRA
          BSR   Comp_Digit
          BVC   FoIn_20
          BSR   FoIn_30
          CMPX  #MANTEN+6
          BNE   FoIn_10
          LEAX  2,X
          BRA   FoWo_10

* CONVERT ACA INTO A STRING OF ASCII DIGITS
* BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
* IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
* THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF REG B IS HOW
* THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.

**********
Comp_Digit
**********

          LDA   ACA_M3
          ADCA  2,X
          STA   ACA_M3
          LDA   ACA_M2
          ADCA  1,X
          STA   ACA_M2
          LDA   ACA_M1
          ADCA  ,X
          STA   ACA_M1
          INCB                ; increment digit counter
          RORB                ; rotate carry into nit 7
          ROLB                ; set overflow flag
          RTS

FoIn_30   LEAX  3,X
          BCC   FoIn_40
          SUBB  #11
          NEGB

FoIn_40   ADDB  #'0'-1
          TFR   B,A
          ANDA  #$7f
          BSR   A_TO_COEFPT
          COMB
          ANDB  #$80
          RTS

*******************
Format_Word ; $d9c1
*******************

* Format 16 bit word to string

* Input : ACA_M2 = 16 bit unsigned integer
*         COEFPT = pointer to string buffer
*         INDEXC = number of digits

          LDX   #POWTEN
FoWo_10   BSR   Dec_Digit_Count
          LDA   #'0'-1
          PSHS  A
          LDD   ACA_M2
FoWo_20   INC   ,S
          STD   ACA_M2
          SUBD  ,X
          BCC   FoWo_20
          LEAX  2,X
          LDA   ,S+
          BSR   A_TO_COEFPT
          CMPX  #POWTEN+10
          BNE   FoWo_10
          BSR   Dec_Digit_Count
          LDX   COEFPT
          CLR   ,X
FoWo_Ret  RTS

***********************
Dec_Digit_Count ; $d9e6
***********************

          DEC   INDEXC
          BNE   FoWo_Ret

*********************
DOT_TO_COEFPT ; $d9ea
*********************

          LDA   #'.'
          PSHS  X
          BSR   A_TO_COEFPT
          LDX   COEFPT
          LEAX  -1,X
          STX   VARPTR
          PULS  PC,X

*******************
A_TO_COEFPT ; $d9f8
*******************

          PSHS  X
          LDX   COEFPT
          STA   ,X+
          STX   COEFPT
          PULS  PC,X

****************
U_Format ; $da02
****************

          STX   COEFPT
          JSR   Test_ACA_Type
          LBPL  R_Format         ; -> real
          LDA   Use_Flag
          RORA                ; exponential bit -> carry
          LBCS  E_Format      ; -> use exponential format
          LDA   #6
          STA   INDEXC        ; max 6 digits
          LDA   Use_Befo
          SUBA  #5
          BSR   Leading_Zeroes
          BSR   Format_Word

UFor_10   LDA   Use_Dot
          BNE   UFor_20
          LEAX  -1,X
          STX   COEFPT

UFor_20   DECA
          BSR   Leading_Zeroes

UFor_30   JSR   Form_30
          CLRA
          BSR   A_TO_COEFPT
          LDX   #Format_Buffer-1

UFor_40   LEAX  1,X
          STX   XSAV
          LDA   VARPTR+1
          SUBA  XSAV+1
          SUBA  Use_Befo
          BEQ   FoWo_Ret
          LDA   ,X
          CMPA  #' '
          BEQ   UFor_40       ; -> skip blank
          CMPA  #'*'
          BEQ   UFor_40       ; -> skip '*'
          CLRA                ; start PUSH sequence with zero

UFor_50   PSHS  A
          LDA   ,X+
          CMPA  #'-'
          BEQ   UFor_50       ; push '-'
          CMPA  #'+'
          BEQ   UFor_50       ; push '+'
          CMPA  #'0'          ; skip leading '0'
          BNE   UFor_70
          LDA   1,X
          JSR   ISNUM
          BCC   UFor_70

UFor_60   PULS  A             ; reinsert sign
          STA   ,-X
          BNE   UFor_60
          BRA   UFor_40

UFor_70   LDA   ,S+
          BNE   UFor_70       ; pop stack until zero byte
          LDX   XSAV

UFor_80   LDA   #'%'          ; insert '%' = format overflow
          STA   ,-X
          RTS

LeZe_10   BSR   Zero_To_COEFPT

**********************
Leading_Zeroes ; $da73
**********************

          DECA
          BPL   LeZe_10
          RTS

********************
XD_B_1_TO_XC ; $da77
********************

          LDA   INDEXD
          PSHS  B
          ADDA  ,S+
          INCA
          STA   INDEXC
          RTS

EAZ_10    PSHS  A
          JSR   Dec_Digit_Count
          PULS  A

*********************
Emit_A_Zeroes ; $da88
*********************

          DECA
          BMI   EAZ_Ret
          BSR   Zero_To_COEFPT
          TSTA
          BNE   EAZ_10
EAZ_Ret   RTS

**************
Zero_To_COEFPT
**************

          PSHS  A
          LDA   #'0'
          JSR   A_TO_COEFPT
          PULS  PC,A

****************
R_Format ; $da9a
****************

          LDA   Use_Flag
          RORA
          LBCS  EFor_10
          LDX   #Nine16
          JSR   Cmp_ACA_X
          BCS   RFor_10
          JSR   Format_ACA
          BRA   UFor_80

RFor_10   LDB   #6
          LDA   ACA_EX
          STA   INDEXD
          BEQ   RFor_20
          JSR   Scale_ACA
          LDB   #6

RFor_20   LDA   INDEXD
          BMI   Form_Fract
          NEGA
          ADDA  Use_Befo
          PSHS  B
          SUBA  ,S+
          BSR   Leading_Zeroes
          BSR   XD_B_1_TO_XC
          JSR   Format_Integer
          LDA   INDEXD
          BSR   Emit_A_Zeroes
          LDA   INDEXD
          JSR   Dec_Digit_Count
          LDX   COEFPT
          JMP   UFor_10

*************
A_B_XD_Zeroes
*************

          PSHS  B
          SUBA  ,S+           ; A - B
          SUBA  INDEXD        ; A - B - INDEXD
Jmp_LeZe  JMP   Leading_Zeroes

**********
Form_Fract
**********

          LDA   Use_Dot
          BEQ   FoFr_10
          DECA

FoFr_10   ADDA  INDEXD
          BMI   FoFr_20
          CLRA

FoFr_20   PSHS  D
          BSR   Apply_Neg_Exp
          LDA   INDEXD
          SUBA  ,S+
          STA   INDEXD
          ADDA  ,S
          PULS  B
          BMI   FoFr_30
          LDA   Use_Befo
          BSR   A_B_XD_Zeroes
          JSR   XD_B_1_TO_XC
          BRA   FoFr_40

FoFr_30   LDA   Use_Befo
          BSR   Jmp_LeZe
          JSR   DOT_TO_COEFPT
          CLRA
          BSR   A_B_XD_Zeroes
          CLR   INDEXC

FoFr_40   JSR   Format_Integer
          LDA   Use_Dot
          BNE   FoFr_50
          LDX   VARPTR
          STX   COEFPT

FoFr_50   ADDA  INDEXD
          JMP   UFor_20

ApNE_10   PSHS  A
          BSR   ACA_DIV_10
          PULS  A
          INCA

*********************
Apply_Neg_Exp ; $db2a
*********************

          BMI   ApNE_10
          RTS

****************
E_Format ; $db2d
****************

          JSR   ACA_Int_To_Real

EFor_10   LDA   ACA_EX
          PSHS  A
          BEQ   EFor_20
          JSR   Scale_ACA

EFor_20   LDA   Use_Dot
          BEQ   EFor_30
          DECA

EFor_30   ADDA  Use_Befo
          DECA
          SUBA  #6
          PSHS  A
          BSR   Apply_Neg_Exp
          LDA   ,S
          BMI   EFor_40
          CLRA

EFor_40   NEGA
          ADDA  Use_Befo
          STA   INDEXC
          JSR   Format_Integer
          PULS  A
          JSR   Emit_A_Zeroes
          LDX   COEFPT
          LDA   Use_Dot
          BNE   EFor_50
          LEAX  -1,X

EFor_50   LDB   ,S+
          BEQ   EFor_60
          LDB   INDEXD
          ADDB  #6
          SUBB  Use_Befo
          INCB

EFor_60   JSR   Form_Exp
          LDX   COEFPT
          JMP   UFor_30

MANTEN    FCB   $fe,$79,$60   ; -100000 : 24 bit integer
          FCB   $00,$27,$10   ;   10000 : 24 bit integer

POWTEN    FDB   10000
          FDB    1000
          FDB     100
          FDB      10
          FDB       1

          FCB   $80
R1E6      REAL 1000000.0
Nine5     REAL $91434ff8; 99999.9
Nine6     REAL $947423f7; 999999.
Nine16    REAL $b60e1bc9; 9999999999999999.

*******************
ACA_DIV_10 ; $db95
*******************

          JSR   ACA_TO_ACB
          LDX   #Real_10
          JSR   Load_ACA
          JMP   ACB_DIV_ACA

********************
ACC_M_TO_ACA ; $dba1
********************

          LDD   ACC_M1
          STD   ACA_M1
          LDA   ACC_M3
          STA   ACA_M3
          RTS



RND_ONE   LDA   #4            ; RND(1.0)
          STA   ACA_SZ
          LDX   #Real_1
          JSR   Load_ACA
          BRA   RND_10

****************
FUNC_RND ; $dbb6
****************

          JSR   CHRGOT
          CMPA  #'('
          BNE   RND_ONE
          JSR   Eval_In_Pars
          JSR   Cast_ACA_Real

RND_10    LDY   #SEED
          JSR   Get_Sign
          BMI   RND_20
          BEQ   RND_30
          LDD   1,Y           ; RND(-x) use SEED
          STD   ACA_M1
          LDA   3,Y
          STA   ACA_M3

RND_20    LDD   #$40e6        ; ACB_M1 = $40
          STD   ACB_M1        ; ACB_M2 = $e6
          LDA   #$4d          ; ACB_M3 = $4d
          STA   ACB_M3
          JSR   MUL_ACA_ACB
          LDD   ACD_M2        ; add $05b065
          ADDD  #$b065
          STD   2,Y           ; store new seed
          LDB   ACD_M1
          ADCB  #5
          LDA   ACC_M2
          STD   ,Y

RND_30    LDD   ,Y            ; RND(0)
          STA   ACA_RN
          LDA   #$80
          STD   ACA_EX
          LDD   2,Y
          STD   ACA_M2
          CLR   ACA_SI
          JMP   Normalize_ACA

*****************
Cmp_ACA_X ; $dc00
*****************

          PSHS  A
          LDD   ACA_EX
          ANDB  #$7f
          CMPD  ,X
          BNE   CAX_Ret
          LDD   ACA_M2
          CMPD  2,X
CAX_Ret   PULS  PC,A

***************
PI_Half ; $dc12
***************

          REAL $81490fdb;    1.57079642918

******************
Two_Pi_Rev ; $dc16
******************

          REAL $7e22f983;    0.15915494406

*****************
Real_0_25 ; $dc1a
*****************

          REAL $7f000000;    0.25000000047

*******
VAR_SIN
*******

          FCB   4
          REAL $861ed7ba;   39.71067248285
          REAL $87992664;  -76.57498571277
          REAL $87233458;   81.60223788023
          REAL $86a55de0;  -41.34167675674
          REAL $83490fda;    6.28318524547

Real_1    REAL $81000000;    1.00000000093

******
logcn2
******

          FCB   2
          REAL $801956aa;    0.59897866845
          REAL $807622f1;    0.96147069382
          REAL $8238aa45;    2.88539254665

Sqrt2half REAL $803504f3;    0.70710679912
Sqrt2     REAL $813504f3;    1.41421359777
Minus0_5  REAL $80800000;   -0.50000002980
Ln2       REAL $80317218;    0.69314721250
Rev_Log_2 REAL $8138aa3b;    1.442695

******
expcon
******
          FCB   7
          REAL $74942e40;   -0.000141
          REAL $772e4f70;    0.001329
          REAL $7a88026e;   -0.008301
          REAL $7c2aa0e6;    0.041657
          REAL $7eaaaa50;   -0.166665
          REAL $7f7fffff;    0.499999
          REAL $81800000;   -1.0
          REAL $81000000;    1.0

Real_0_5  REAL $80000000;    0.5
Real_10   REAL $84200000;   10.0

**********
LINE_INPUT
**********

          JSR   CHRGET        ; LINE INPUT = a5 ff a1
          LDB   #$a1          ; part 3 of LINE INPUT tokens
          JSR   Need_B
          BSR   Input_No_QM
          BSR   Echo_String
          CLR   CHANNEL
          JSR   Parse_Name    ; receiving string variable
          STX   VARDES
          JSR   Assert_ACA_Desc
          LDX   #BUF_TXT
          CLRA
          JSR   Scan_A_String
          JMP   Assign_String_Variable

*********
QM_Prompt
*********

          JSR   CHRGET
QMP_10    LDB   SQMFLG
          LBNE  Print_QM_Blank
QMP_Ret   RTS



********
Input_QM
********

          FCB   $c6 ; LDB

***********
Input_No_QM
***********

          CLRB
          STB   SQMFLG
          LDB   #12           ; NOT DIRECT
          LDX   CURLIN
          LEAX  1,X
          BEQ   Inpu_Err      ; CURLIN was $ffff
          CMPA  #';'
          BNE   Inpu_10
          JSR   CHRGET        ; skip ;

Inpu_10   CMPA  #'#'          ; INPUT#
          BNE   Inpu_20
          JSR   Set_Channel
          JSR   Need_Comma
          JSR   Device_Input

**************************************
* referenced from disk BASIC : $dcc4 *
**************************************

          JSR   CHRGOT

Inpu_20   CMPA  #QUOTE
          BNE   QMP_10        ; -> no prompt
          JSR   TXTPTR_String
          JSR   Print_ACA_String
          JSR   CHRGOT
          CMPA  #';'          ; prompt separator
          BEQ   QM_Prompt
          JMP   Need_Comma

Inpu_30   LDX   DATTXT
          STX   CURLIN
          JMP   Syntax_Error

Inpu_40   STX   TXTPTR

Inpu_50   JSR   Skip_To_EOS   ; DATA read
          TST   ,X+
          BNE   Inpu_60
          LDB   #4
          LDU   ,X++
          BEQ   Inpu_Err      ; end of program
          LDD   ,X++
          STD   DATTXT

Inpu_60   STX   TXTPTR
          JSR   CHRGOT
          CMPA  #TK_DATA
          BNE   Inpu_50
          BRA   READ_35

***********
Echo_String
***********

          JSR   Edit_Get_Line
          LBCS  STOP_20

**********************
INPUT_PAST_END ; $dd02
**********************

          LDB   #$36          ; INPUT PAST END
          TST   CINBFL
          BEQ   QMP_Ret
Inpu_Err  JMP   Print_Error_B

**********
Line_Input
**********

          JSR   CHRGET
          BSR   Input_QM
          CLRA
          JSR   Test_Input_Char
          BMI   Linp_10
          BSR   Echo_String
          LDA   #','

Linp_10   LDX   #BUF_TXT
          STA   ,X
          BRA   READ_10

          FILL $dd25-* (0)

Linp_20   LDB   #':'
          JSR   Test_Input_Char
          BNE   Inpu_Err
          LDA   INPFLG
          BNE   Inpu_30

Linp_30   LDX   #Msg_Redo-1
          JSR   Print_Msg_X
          LDX   OLDTXT
          STX   TXTPTR
          RTS

******************
BASIC_READ ; $dd3b
******************

          LDX   DATPTR
          FCB   $86           ; LDA #$4f

READ_10   CLRA                ; LDA #$00
          STA   INPFLG
          STX   INPPTR
          SKIP2

READ_15   JSR   Need_Comma
          JSR   Parse_Name
          STX   VARDES        ; target variable
          LDX   TXTPTR
          STX   LINNUM
          LDX   INPPTR        ; DATA pointer
          LDA   ,X
          JSR   ISNUM
          BNE   READ_30
          LDA   INPFLG
          BNE   Inpu_40       ; -> input
          JSR   Test_Input_Char

READ_20   BEQ   Linp_20
          BPL   READ_25
          JSR   J226c         ; JMP Device_Not_Present
          SKIP2

READ_25   BSR   Echo_String

READ_30   STX   TXTPTR

READ_35   JSR   Test_ACA_Type
          BEQ   READ_55       ; -> String
          LDX   TXTPTR
          JSR   CHRGET
          LDU   TXTPTR
          PSHS  U
          STX   TXTPTR
          LDA   ACA_SZ
          PSHS  A
          JSR   Read_Real_To_ACA
          PULS  A
          JSR   Type_Cast
          LDX   TXTPTR
          CMPX  ,S++
          BEQ   READ_20
          JSR   ACA_To_VARDES ; store value

READ_40   JSR   CHRGOT
          BEQ   READ_45       ; -> finish
          CMPA  #','
          BNE   Linp_20       ; -> error

READ_45   LDX   TXTPTR        ; next variable
          STX   INPPTR
          LDX   LINNUM
          STX   TXTPTR
          JSR   CHRGOT
          BNE   READ_15
          LDX   INPPTR
          LDB   INPFLG
          BEQ   READ_50
          STX   DATPTR
          RTS

READ_50   LDA   ,X
          BNE   Linp_30
          CLR   CHANNEL
          RTS

READ_55   CLRA                ; read string
          CLRB
          JSR   Device_Context
          TST   PRTDEV
          BNE   READ_60
          JSR   CHRGET
          LDX   TXTPTR
          TFR   A,B
          CMPA  #QUOTE
          BEQ   READ_60
          LEAX  -1,X
          LDD   #$3a2c        ; A=':'  B=','

READ_60   JSR   Scan_AB_String
          JSR   COEFPT_TXTPTR
          JSR   Assign_String_Variable
          BRA   READ_40

Msg_Redo  FCB   "?Redo\r\n",0

*********************
Uncrunch_Line ; $ddda
*********************

          JSR   Check_Protection
          LEAX  4,X ; skip link & linenumber
          LDY   #$2452
Uncr_10   LDD   ,X+ ; load next 2 chars
          TSTA
          BEQ   SKC_10 ; -> RTS
          BMI   Uncr_30 ; -> token
          CMPA  #':'
          BNE   Uncr_20
          CMPB  #$8f
          BEQ   Uncr_10
          CMPB  #$8d
          BEQ   Uncr_10
Uncr_20   BSR   Store_Key_Char
          FCB   $8c
Uncr_30   BSR   Decode_Token
          BRA   Uncr_10

********************
Decode_Token ; $ddfd
********************

          LDU   #$21f7 ; keyword table
          CMPA  #$ff
          BNE   DeTo_10
          TFR   B,A ; A = next char
          LEAU  5,U ; U += 5
          LEAX  1,X ; X++
DeTo_10   ANDA  #$7f ; remove high bit
DeTo_20   LEAU  10,U ; U += 10
          SUBA  ,U
          BPL   DeTo_20
          ADDA  ,U
          LDU   1,U
DeTo_30   DECA  ; --token count
          BMI   DeTo_50
DeTo_40   TST   ,U+
          BPL   DeTo_40 ; skip until end of keyword
          BRA   DeTo_30 ; next keyword
DeTo_50   LDA   ,U ; next key char
          ANDA  #$7f
          BSR   Store_Key_Char
          TST   ,U+
          BPL   DeTo_50 ; not finished yet
          RTS

**********************
Store_Key_Char ; $de2a
**********************

          CMPY  #$2551 ; end of buffer ?
          BCC   SKC_10
          STA   ,Y+
          CLR   ,Y
SKC_10    RTS
SKC_20    LDA   #TK_PRINT
SKC_30    STA   ,U+
          RTS

**************
CRUNCH ; $de3a
**************

          LDU   #BUF_TXT

CRUN_10   LDA   ,X+           ; get input character

CRUN_12   STA   ,U+           ; store into buffer
          BEQ   CRUN_20         ; -> end of line
          JSR   ISNUM         ; numeric ?
          BCS   CRUN_10       ; loop if numeric
          LEAU  -1,U          ; backspace write position
          LDY   #CRUTAB

CRUN_14   CMPA  ,Y++          ; special character ? : ' \ space
          BLO   CRUN_14
          BNE   CRUN_36       ; -> look for keyword
          LDB   ,-Y
          TFR   PC,Y
CRUN_16   JSR   B,Y           ; call translate routine

CRUN_18   BNE   CRUN_10       ; loop

CRUN_20   CLRB                ; set end of line marker
          STD   ,U++          ; store last char and zero
          TFR   U,D
          SUBD  #BUF_NUM      ; D = length of crunched line
          LDX   #BUF_TXT-1
          STX   TXTPTR
          RTS                 ; done

CRUN_22   LDD   #$3a8d        ; ':' and TK_APO
          STD   ,U++

CRUN_24   CLRA
          SKIP2

CRUN_26   STA   ,U+

CRUN_28   STA   CRUCNT

CRUN_30   LDA   ,X+           ; copy until delimiter
          STA   ,U+
          BEQ   CRUN_34
          CMPA  CRUCNT
          BNE   CRUN_30

CRUN_32   COMA

CRUN_34   RTS

CRUN_36   LEAX  -1,X
          PSHS  U,X           ; save I/O pointer
          CLR   INDEXA
          LDU   #Crunch_Tab-10

CRUN_38   CLR   CRUCNT

CRUN_40   LEAU  10,U          ; next table structute
          LDB   ,U
          BEQ   CRUN_52         ; -> continue at functions
          LDY   1,U           ; Y = dictionary

CRUN_42   LDX   ,S            ; X = input string

CRUN_44   LDA   ,X+           ; A = next input character
          BSR   TO_UPPER      ; convert to upper case
          SUBA  ,Y+           ; subtract dictionary character
          BEQ   CRUN_44       ; -> continue on match
          CMPA  #$80          ; last character match ?
          BNE   CRUN_56         ; -> next keyword
          PULS  U,Y           ; restore I/O pointer
          ORA   CRUCNT        ; create token
          LDB   INDEXA        ;
          BNE   CRUN_46       ; precede token with $ff
          CMPA  #TK_ELSE
          BNE   CRUN_48
          LDB   #':'          ; put a colon before else

CRUN_46   STB   ,U+           ; insert pre token

CRUN_48   STA   ,U+           ; insert token
          INCB                ; increment pre token
          BEQ   CRUN_10       ; -> pre token was $ff
          BSR   CRUN_50       ; special cases
          BRA   CRUN_18       ; -> loop

CRUN_50   CMPA  #TK_REM
          BEQ   CRUN_24       ; -> copy rest of line
          CMPA  #TK_DATA
          BNE   CRUN_32       ; -> return
          LDA   #0
          BRA   CRUN_28       ; -> copy until delimiter

CRUN_52   LDU   #Crunch_Tab-5 ; function tokens
          COM   INDEXA
          BNE   CRUN_38
          PULS  U,X           ; illegal data or token
          LDA   ,X+           ; 1st. char of illegal token
          BSR   CRUN_60       ; convert to upper and check
          BCC   CRUN_48       ; -> continue

CRUN_54   STA   ,U+
          BEQ   CRUN_20       ; -> end of line
          LDA   ,X+
          BSR   CRUN_60       ; convert to upper and check
          BCS   CRUN_54       ; -> copy
          JSR   ISNUM
          BCS   CRUN_54       ; -> copy
          JMP   CRUN_12       ; -> crunch

CRUN_56   INC   CRUCNT        ; increment token counter
          DECB                ; decrement command counter
          BEQ   CRUN_40       ; -> next keyword table
          LEAY  -1,Y          ; compensate next statement

CRUN_58   LDA   ,Y+
          BPL   CRUN_58       ; skip to end of keyqord
          BRA   CRUN_42       ; -> next keyword

CRUN_60   BSR   TO_UPPER
          JMP   A_Is_Alpha

****************
TO_UPPER ; $def9
****************

          CMPA  #'a'
          BLO   TOUP_Ret
          CMPA  #'z'
          BHI   TOUP_Ret
          EORA  #$20
TOUP_Ret  RTS

          FILL $df0c-* (0)

**************
CRUTAB ; $df0c
**************

* special character for CRUNCH routine in descending order
* used for a JSR relative to CRUN_16

          FCB   "?" , (SKC_20 - CRUN_16) & $ff ; PRINT
          FCB   ":" , (SKC_30 - CRUN_16) & $ff ; :
          FCB   "'" , CRUN_22 - CRUN_16        ; REM
          FCB   "\"", CRUN_26 - CRUN_16        ; \
          FCB   " " , (SKC_30 - CRUN_16) & $ff ; SPACE
          FCB   0

********************
Program_Stop ; $df17
********************

          LDA   CURLIN
          INCA
PrSt_10   LBEQ  STOP_30
          TST   ENDFLG
          BEQ   PrSt_10
          LDB   #$13 ; NO RESUME
          JMP   Print_Error_B

*****************
Interpret ; $df26
*****************

          STS   SP_DEF
          JSR   Check_Keyboard
          LDX   TXTPTR
          STX   OLDTXT
          LDA   ,X+
          BEQ   Inte_20
          CMPA  #':'
          BEQ   Execute
Inte_Err  JMP   Syntax_Error
Inte_10   COM   ENDFLG
Inte_20   CLRA
          LDD   ,X++ ; D = link
          BEQ   Program_Stop
          LDD   ,X+ ; D = number
          STD   CURLIN
          STX   TXTPTR
          LDA   TRCFLG
          BEQ   Execute
          LDA   #'[' ; trace output
          JSR   Jmp_Chrout
          LDA   CURLIN
          JSR   Print_Integer_D
          LDA   #']'
          JSR   Jmp_Chrout

***************
Execute ; $df5a
***************

          JSR   CHRGET
          BSR   Process
          BRA   Interpret

***************
Process ; $df60
***************

          BEQ   TOUP_Ret
          CMPA  #$80          ; 1st. action token
          LBLO  LET           ; -> not a token
          CMPA  #$b9          ; last token
          BHI   Proc_10       ; -> not standard BASIC command
          LDX   Crunch_Tab+3  ; Action_Switch

********************************
* Entry for disk BASIC : $df6f *
********************************

          ASLA                ; A = index from token
          TFR   A,B
          ABX                 ; X = Switch + Index
          JSR   CHRGET
          JMP   [,X]          ; -> call token routine
Proc_10   CMPA  #$ff
          BEQ   Proc_20       ; -> BASIC extension
          CMPA  #$d5          ; token before functions
          BLS   Inte_Err
          JMP   [$220e]       ; -> extended command
Proc_20   JSR   CHRGET        ; extension token after $ff
          CMPA  #$a1          ; $ffa1 = LINE INPUT
          LBEQ  Line_Input
          CMPA  #TK_COLOR     ; $ffa4 = SCREEN
          LBEQ  BASIC_SCREEN
          JMP   Hook_227b

********************
Set_Filename ; $df94
********************

          LDA   INPSTD

**********************
Set_Filename_A ; $df96
**********************

          STA   INPDEV
          LDX   #FILENAME
          CLR   ,X+
          LDD   #$2008        ; A = ' '   B = 8

SeFi_10   STA   ,X+           ; store 8 blanks
          DECB
          BNE   SeFi_10
          PULU  Y,B           ; B,Y = extension
          STB   ,X
          STY   1,X
          JSR   CHRGOT
          BEQ   SeFi_65
          JSR   Eval_String   ; get filename
          CMPB  #2
          BLO   SeFi_25       ; -> length < 2
          LDA   #':'
          CMPA  1,X
          BEQ   SeFi_35       ; disk file "n:..."
          CMPB  #5
          BLO   SeFi_25       ; -> length < 5
          CMPA  4,X
          BNE   SeFi_25       ; -> colon not at pos 4
          PSHS  X,B
          LDB   #15
          STB   INPDEV

SeFi_15   LDU   #Device_Tab   ; table of device structure pointer
          LDB   INPDEV        ; device #
          ASLB                ; -> index
          LDU   B,U           ; device structure pointer
          BEQ   SeFi_30       ;-> unknown device
          LDX   1,S
          LDB   #4            ; device name length

SeFi_20   LDA   ,U+           ; compare device name
          CMPA  ,X+
          BNE   SeFi_30
          DECB
          BNE   SeFi_20
          PULS  X,B           ; match
          LEAX  5,X           ; X = filename
          SUBB  #5

SeFi_25   BRA   SeFi_40

SeFi_30   DEC   INPDEV
          BPL   SeFi_15
          JMP   Device_Not_Present

SeFi_35   LDA   ,X++          ; load unit
          SUBA  #'0'          ; convert to binary
          BCS   SeFi_Err      ; -> error
          CMPA  #9
          BHI   SeFi_Err
          ORA   #$80
          STA   INPDEV        ; $80-$89 = disk unit 0-9
          SUBB  #2            ; subtract "u:" from length

SeFi_40   LDU   #FILEDESC
          TSTB
          BEQ   SeFi_55         ; -> name length = 0
          LDA   ,X
          CMPA  #'('
          BNE   SeFi_55
          LEAX  1,X

SeFi_45   DECB
          BEQ   SeFi_Err
          LDA   ,X+
          CMPA  #')'
          BEQ   SeFi_50
          STA   ,U+
          CMPU  #FILEDESC+33
          BCS   SeFi_45

SeFi_Err  LDB   #$37          ; wrong file descriptor
          JMP   Print_Error_B

SeFi_50   DECB

SeFi_55   CLR   ,U
          LDU   #FILENAME+1
          INCB

SeFi_60   DECB

SeFi_65   BEQ   PFC_Ret
          LDA   ,X+
          CMPA  #'.'
          BEQ   SeFi_70
          CMPU  #FILENAME+9
          BEQ   SeFi_Err
          BSR   Put_Filename_Char
          INC   FILENAME
          BRA   SeFi_60

SeFi_70   LDU   #FILEDESC
          LDA   #' '

SeFi_75   STA   ,-U
          CMPU  #FILENAME+9
          BNE   SeFi_75

SeFi_80   DECB
          BEQ   PFC_Ret
          LDA   ,X+
          CMPU  #FILEDESC
          BEQ   SeFi_Err
          BSR   Put_Filename_Char
          BRA   SeFi_80

*****************
Put_Filename_Char
*****************

          STA   ,U+
          LDY   #FORBID
PFC_10    CMPA  ,Y+
          BEQ   SeFi_Err
          BHI   PFC_10
PFC_Ret   RTS

******************
BASIC_LIST ; $e06a
******************

          CMPA  #$22 ; '"'
          BNE   LIST_40
          BSR   Set_BAS_File
          BEQ   LIST_40
          JSR   Need_Comma
          BRA   LIST_40

************
Set_BAS_File
************

          LDU   #F_BAS

**************
Build_Filename
**************

          JSR   Set_Filename
          LDB   #$11
          STB   CHANNEL
          CLR   SAVDEV
          CLR   PROCHK
          CLR   D2196
          JMP   CHRGOT

LIST_30   JSR   CHRGET
          BNE   Scra_Ret

LIST_40   JSR   Get_Line_Range
          PSHS  X
          BSR   Check_Protection
          COM   PROCHK
          COM   D2196
          TST   CHANNEL
          BEQ   LIST_50
          JSR   Assert_Output

LIST_50   PULS  U,X
          JMP   List_Range

******************
BASIC_SAVE ; $e0a3
******************

          CMPA  #'M'
          LBEQ  SAVEM
          BSR   Set_BAS_File
          BEQ   LoPr_20
          JSR   Need_Comma
          CMPA  #'A'          ; ASCII
          BEQ   LIST_30
          LDB   #'P'          ; protected
          JSR   Need_B
          BNE   Scra_Ret
          JSR   Assert_Output
          BSR   SAVE_20

SAVE_10   CMPX  VARTAB
          BEQ   SAVE_30
          LDA   ,X
          SUBA  ACA_EX
          BSR   Scramble_1
          BSR   Scramble_2
          ADDA  ACA_M1
          STA   ,X+
          BSR   Scramble_Cnt
          BRA   SAVE_10

SAVE_20   LDD   #$0b0d
          STD   ACA_EX
          LDX   TXTTAB
          RTS

**********
Scramble_1
**********

          LDU   #logcn2
          LDB   ACA_EX
          BRA   Scra_10

**********
Scramble_2
**********

          LDU   #VAR_SIN
          LDB   ACA_M1
Scra_10   EORA  B,U
Scra_Ret  RTS

************
Scramble_Cnt
************

          LDD   #$0b0d        ; A = 11   B = 13
          DEC   ACA_EX
          BNE   Scra_20
          STA   ACA_EX        ; reset counter to 11
Scra_20   DEC   ACA_M1
          BNE   Scra_Ret
          STB   ACA_M1        ; reset counter to 13
          RTS

********************
Set_BIN_File ; $e0f9
********************

          JSR   CHRGET
          LDU   #F_BIN
          JSR   Build_Filename

*****************
Protected ; $e101
*****************

          LDX   CURLIN
          LEAX  1,X
          BNE   Scra_Ret

************************
Check_Protection ; $e107
************************

          TST   PROTECT
          BEQ   Scra_Ret
          LDB   #$3d          ; NO SUCH LINE
          JMP   Print_Error_B

SAVE_30   LDA   #$fe
          BSR   LoPr_30

**********************
Load_Protected ; $e113
**********************

          BSR   SAVE_20
LoPr_10   CMPX  VARTAB
          BEQ   Scra_Ret
          LDA   ,X
          SUBA  ACA_M1
          BSR   Scramble_2
          BSR   Scramble_1
          ADDA  ACA_EX
          STA   ,X+
          BSR   Scramble_Cnt
          BRA   LoPr_10
LoPr_20   BSR   Check_Protection
          JSR   Assert_Output
          LDA   #$ff
LoPr_30   JSR   CHROUT
          LDD   VARTAB
          SUBD  TXTTAB
          BSR   D_OUT
          LDX   TXTTAB
LoPr_40   LDA   ,X+
          JSR   CHROUT
          CMPX  VARTAB
          BNE   LoPr_40
          BRA   Close_File

*****************
Get_Word_To_Stack
*****************

          JSR   Need_Comma
          JSR   Get_Number
          LDU   ,S            ; U = return address
          STX   ,S            ; replace return address with X
          TFR   U,PC          ; jump back to caller

*****
D_OUT
*****

          JSR   CHROUT
          EXG   A,B

*****
A_OUT
*****

          JMP   CHROUT

*****
SAVEM
*****

          BSR   Set_BIN_File
          BSR   Get_Word_To_Stack ; start address
          BSR   Get_Word_To_Stack ; end   address
          CMPX  2,S
          LBCS  Illegal_Quantity  ; end < start
          BSR   Get_Word_To_Stack ; exec address
          JSR   CHRGOT
          BNE   CCB_Ret             ; return
          LDA   #2
          STA   SAVDEV
          JSR   Assert_Output
          CLRA
          BSR   A_OUT
          LDD   2,S               ; end
          SUBD  4,S               ; end - start
          ADDD  #1                ; + 1
          TFR   D,Y               ; Y = byte count
          BSR   D_OUT             ; write byte count
          LDD   4,S
          BSR   D_OUT             ; write start address
          LDX   4,S               ; X = start address

SAVEM_10  LDA   ,X+
          JSR   CHROUT            ; write next byte
          LEAY  -1,Y              ; count down
          BNE   SAVEM_10          ; loop
          LDA   #$ff
          BSR   A_OUT             ; write end marker $ff
          CLRA
          CLRB
          BSR   D_OUT             ; write zero word $0000
          PULS  Y,X,D
          BSR   D_OUT             ; write D

******************
Close_File ; $e196
******************

          LDB   CHANNEL

***************
Close_Channel_B
***************

          CLR   CHANNEL
          LDX   #Channel_Tab
          LDA   B,X
          BEQ   Clall_Ret
          LBMI  Close_Error
          PSHS  X,B
          ANDA  #$30
          STA   ACTDEV
          LDB   B,X
          JSR   LDX_Dev_Func
          JSR   [6,X]
          PULS  X,B
          CLR   B,X
CCB_Ret   RTS

*******************
BASIC_CLOSE ; $e1b8
*******************

          BEQ   Close_All
          BSR   Set_Channel
CLOSE_10  BSR   Close_File
          JSR   CHRGOT
          BEQ   Clall_Ret
          BSR   Comma_Channel
          BRA   CLOSE_10

*****************
Close_All ; $e1c6
*****************

          LDB   #$11          ; close all channels from 17 to 1
Clall_10  BSR   Close_Channel_B
          DECB
          BPL   Clall_10
Clall_Ret RTS

*********************
Comma_Channel ; $e1ce
*********************

          JSR   Need_Comma

*******************
Set_Channel ; $e1d0
*******************

          JSR   CHRGOT
          CMPA  #'#'
          BNE   SeCh_10
          JSR   CHRGET
SeCh_10   JSR   Eval_Numeric

*******************
Set_CHANNEL ; $e1da
*******************

          JSR   Eval_Byte

*********************
Set_CHANNEL_B ; $e1dd
*********************

          CMPB  #$10
          BHI   SeCH_Err
          STB   CHANNEL
          BNE   Clall_Ret
SeCH_Err  LDB   #$32          ; WRONG CHANNEL NUMBER
          JMP   Print_Error_B

******************
BASIC_OPEN ; $e1e9
******************

          JSR   Need_String
          PSHS  B
          BSR   Comma_Channel
          LDX   #Channel_Tab
          TST   B,X
          BNE   ALREADY_OPEN
          JSR   Need_Comma
          LDU   #F_DAT
          JSR   Set_Filename
          JSR   J226f
          JSR   CHRGOT
          BNE   SAD_Ret
          LDD   #$01ff
          STD   SAVDEV
          STB   D2196
          PULS  B
          BSR   AsOu_10
          CLR   CHANNEL
          INC   D2196
          BEQ   SAD_Ret
          JSR   CASS_Stop
          BRA   BAD_FILE_MODE

********************
Assert_Input ; $e21c
********************

          LDB   #'I'
          SKIP2

*********************
Assert_Output ; $e21f
*********************

          LDB   #'O'
AsOu_10   TST   INPDEV
          LBMI  Mode_Error
          LDA   #$10
          CMPB  #'I'
          BEQ   Set_Active_Device
          LDA   #$20
          CMPB  #'O'
          BEQ   Set_Active_Device

*********************
BAD_FILE_MODE ; $e233
*********************

          LDB   #$33
          FCB   $8c

********************
ALREADY_OPEN ; $e236
********************

          LDB   #$34
          SKIP2

**************************
Device_Not_Present ; $e239
**************************

          LDB   #$3c
          JMP   Print_Error_B

*****************
Set_Active_Device
*****************

          STA   ACTDEV
          LDB   INPDEV
          JSR   X_Dev_Func
          BEQ   Device_Not_Present
          JSR   [4,X]
          LDA   ACTDEV
          ORA   INPDEV
          JSR   LDX_Channel_Tab
          STA   B,X
SAD_Ret   RTS

********************
Load_And_Run ; $e253
********************

          LDD   #$0200
          BRA   LOAD_20

*******************
BASIC_MERGE ; $e258
*******************

          LDD   #$00ff        ; A = $00   B = $ff
          BRA   LOAD_20

LOAD_10   LDA   INPDEV
          CMPA  #2            ; cassette
          BNE   LOAD_12
          TST   D2196
          BEQ   LOAD_Err

LOAD_12   TST   MRGFLG
          BNE   LOAD_Fin
          JSR   NEW_10
LOAD_Fin  JMP   Main_10

* LOADM branches to this code

* Input : D = 0

LOAD_14   STD   RUNADR        ; clear
          STD   LDRUN         ; clear LDRUN and MRGFLG
          INCB                ; B = 1
          STB   LOADMF        ; set LOADM flag
          JSR   Set_BIN_File
          JSR   CHRGOT
          BEQ   LOAD_24       ; -> no more parameter
          JSR   Need_Comma
          CMPA  #','
          BEQ   LOAD_22       ; -> check for 'R' (RUN)
          JSR   Get_Number
          STX   RUNADR        ; define RUN address
          BRA   LOAD_22

******************
BASIC_LOAD ; $e28c
******************

          CLRB                ; B = 0
          SUBA  #'M'          ; A = char after LOAD - 'M'
          BEQ   LOAD_14       ; -> LOADM   A = 0   B = 0
          CLRA

LOAD_20   CLR   LOADMF
          STD   LDRUN
          JSR   Set_BAS_File

LOAD_22   JSR   CHRGOT
          BEQ   LOAD_24
          JSR   Need_Comma
          LDB   #'R'
          JSR   Need_B
          BNE   SAD_Ret
          LDA   #3
          STA   LDRUN

LOAD_24   LDA   INPDEV
          BMI   LOAD_26       ; -> load from disk
          CMPA  #2            ; tape ?
          LBNE  Load_Error    ; no -> syntax error

LOAD_26   JSR   Assert_Input
          LDD   SAVDEV
          TST   LOADMF
          BNE   LOAD_70         ; -> LOADM
          TSTB
          BNE   LOAD_10
          TSTA
          BEQ   LOAD_30

LOAD_Err  JMP   BAD_FILE_MODE

LOAD_30   TST   MRGFLG
          BNE   LOAD_Err
          JSR   NEW_10
          COM   WRMFLG
          BSR   Checked_CHRIN ; read protect flag
          INCA
          STA   PROTECT
          BSR   DEV_WORDIN
          ADDD  TXTTAB
          JSR   Mem_Avail
          LDX   TXTTAB

LOAD_32   JSR   DEV_CHRIN     ; read loop
          LDB   CINBFL
          BNE   LOAD_34
          STA   ,X+
          BRA   LOAD_32

LOAD_34   STX   VARTAB        ; load end address + 1
          TST   PROTECT
          BEQ   LOAD_36
          JSR   Load_Protected

LOAD_36   LDB   #3

LOAD_38   TST   ,-X
          BNE   LOAD_40
          DECB
          BNE   LOAD_38

LOAD_40   LDX   VARTAB

LOAD_42   STX   VARTAB
          CLR   ,X+
          DECB
          BPL   LOAD_42

LOAD_50   JSR   Close_File
          JSR   Clear_Variables
          LDX   TXTTAB
          JSR   Relink
          ASR   LDRUN
          BCS   LOAD_60
          JSR   Close_All

LOAD_60   ASR   LDRUN
          LBCS  Interpret
          JMP   Main

**********
DEV_WORDIN
**********

          BSR   DEWO_10
DEWO_10   BSR   Checked_CHRIN
          EXG   A,B
DEWO_Ret  RTS

*************
Checked_CHRIN
*************

          BSR   DEV_CHRIN
          TST   CINBFL
          BEQ   DEWO_Ret         ; -> OK

IO_Err    LDB   #$35          ; error 53 I/O error
          JMP   Print_Error_B

LOAD_70   TSTB

LOAD_72   BNE   LOAD_Err
          CMPA  #2
          BNE   LOAD_72

LOAD_74   BSR   Checked_CHRIN
          PSHS  A
          BSR   DEV_WORDIN
          TFR   D,Y
          BSR   DEV_WORDIN
          ADDD  RUNADR
          STD   EXEC_Pointer
          TFR   D,X
          LDA   ,S+
          BEQ   LOAD_76
          JSR   Close_File
          TST   LDRUN
          BEQ   DEWO_Ret
          JMP   EXEC_10

LOAD_76   BSR   DEV_CHRIN
          LDB   CINBFL
          BNE   IO_Err
          STA   ,X+
          LEAY  -1,Y
          BNE   LOAD_76
          BRA   LOAD_74

*****************
DEV_CHRIN ; $e362
*****************

          PSHS  U,Y,X,B
          CLR   CINBFL
          BSR   LDB_First_Char
          LBMI  M2263
          BSR   LDX_Dev_Func
          JSR   [8,X]
          PULS  PC,U,Y,X,B

******************
DEV_CHROUT ; $e373
******************

          PSHS  U,Y,X,D
          BSR   LDB_First_Char
          BITB  #$10
          BEQ   DECO_10
          BITB  #15
          BNE   DECO_20

DECO_10   TSTB
          LBMI  M2260
          BSR   LDX_Dev_Func
          JSR   [10,X]
DECO_20   PULS  PC,U,Y,X,D

**************************
BAS_Device_Context ; $e38b
**************************

          PSHS  X,D
          CLR   PRTDEV
          BSR   LDB_First_Char
          LBMI  M2266
          BSR   LDX_Dev_Func
          JSR   [12,X]
          STX   DEVPOS
          STD   DEVCFW
          TST   COLMAX
          PULS  PC,X,D

********************
LDX_Dev_Func ; $e3a2
********************

          ANDB  #15

******************
X_Dev_Func ; $e3a4
******************

          ASLB
          LDX   #Device_Tab
          LDX   B,X
          RTS

**********************
LDB_First_Char ; $e3ab
**********************

          BSR   LDX_Channel_Tab
          LDB   B,X
          RTS

***********************
LDX_Channel_Tab ; $e3b0
***********************

          LDX   #Channel_Tab
          LDB   CHANNEL
          RTS

***********************
Test_Input_Char ; $e3b6
***********************

          PSHS  X,B
          BSR   LDB_First_Char
          ANDB  #$8f
          PULS  PC,X,B

****************
FUNC_EOF ; $e3be
****************

          LDA   CHANNEL
          PSHS  A
          JSR   Set_CHANNEL
          LDX   #Channel_Tab
          TST   B,X
          LBMI  M2269
          BSR   Device_Input
          PULS  A
          STA   CHANNEL
          LDB   B,X
          BSR   LDX_Dev_Func
          JSR   [14,X]
          JMP   BAS_B_To_ACA

******************
FUNC_INPUT ; $e3de
******************

          LDB   #'$'
          JSR   Need_B        ; A$ = INPUT$(I,#J)
          JSR   Need_Left_Par
          JSR   Byte_Var
          LDA   CHANNEL
          PSHS  D
          CLR   CHANNEL
          JSR   CHRGOT
          CMPA  #')'
          BEQ   FINP_10
          JSR   Comma_Channel

FINP_10   JSR   Need_Right
          BSR   Device_Input
          LDB   1,S
          JSR   Allocate_String_B
          INC   1,S

FINP_20   DEC   1,S
          BEQ   FINP_30
          JSR   DEV_CHRIN
          JSR   INPUT_PAST_END
          STA   ,X+
          BRA   FINP_20

FINP_30   PULS  D
          STA   CHANNEL
          JMP   Push_Descriptor

*********************
Device_Column ; $e416
*********************

          LDA   #$20
          SKIP2

********************
Device_Input ; $e419
********************

          LDA   #$10
          PSHS  X,D
          BSR   LDX_Channel_Tab
          BEQ   DeIn_10
          LDA   B,X
          BEQ   FILE_NOT_OPEN
          JSR   Hook_2287
          ANDA  #$30

********************************
* entry for disk BASIC : $e42a *
********************************

          CMPA  ,S
          LBNE  BAD_FILE_MODE
DeIn_10   PULS  PC,X,D

*********************
FILE_NOT_OPEN ; $e432
*********************

          LDB   #$39
          JMP   Print_Error_B

****************
FUNC_POS ; $e436
****************

          JSR   CHRGOT
          CLRB
          CMPA  #'('
          BNE   FPOS_10
          JSR   Eval_In_Pars
          JSR   Eval_Byte

FPOS_10   LDA   CHANNEL
          PSHS  A
          TSTB
          BEQ   FPOS_20
          JSR   Set_CHANNEL_B

FPOS_20   BSR   Device_Column

**************************************
* referenced from disk BASIC : $e44f *
**************************************

          JSR   Device_Context
          PULS  A
          STA   CHANNEL
          LDB   DEVPOS
          JMP   B_To_ACA

FORBID    FCB   $00,$16
          FCB   "().:"
          FCB   $ff
F_BAS     FCB   "BAS"
F_DAT     FCB   "DAT"
F_BIN     FCB   "BIN"

*******************
FUNC_CSRLIN ; $e469
*******************

          LDB   Row
          JMP   B_To_ACA

******************
FUNC_INKEY ; $e46e
******************

          CLR   DSA_LEN
          CALL  GETC
          LBEQ  Push_Descriptor
          JMP   FUGR_10

**********************
Check_Keyboard ; $e479
**********************

          PSHS  U,D
          LDU   #PRB
          LDD   #$6e6a
          STA   ,U
          LDA   ,U
          BPL   CKBD_10
          STB   ,U
          LDA   ,U
          BMI   CKBD_Ret
          LDA   #$64 ; 'd'
          STA   ,U
          LDA   ,U
          BMI   CKBD_Ret
CKBD_10   CALL  GETC
          BEQ   CKBD_10
          CMPB  #2
          BEQ   CKBD_10
          CMPB  #3
          LBEQ  STOP_00
CKBD_Ret  PULS  PC,U,D

KGK_00    JSR   [$2255]
          SKIP2

***********
Kbd_Get_Key
***********

          PSHS  U,Y,X,A

KGK_10    LDY   #KBDBUF
          LDB   ,Y
          BEQ   KGK_40

KGK_20    LDA   1,Y
          STA   ,Y+
          BNE   KGK_20

KGK_30    TSTB
          PULS  PC,U,Y,X,A

KGK_40    CALL  GETC
          BPL   KGK_30         ; -> normal key
          LDU   #Ext_Token-$80
          LDA   B,U
          BPL   KGK_50
          CMPA  #$ff
          BEQ   KGK_00
          TFR   A,B
          SEX
          SKIP2

KGK_50    ORA   #$80
          JSR   Decode_Token
          BRA   KGK_10

****
KYBD
****

          FCB   "KYBD"        ; 0
          FDB   KYBD_Open     ; 4
          FDB   KYBD_Close    ; 6
          FDB   KYBD_Chrin    ; 8
          FDB   SCRN_Chrout   ; a
          FDB   SCRN_Status   ; c
          FDB   KYBD_EOF      ; e

*********
KYBD_Open
*********

          CMPA  #$10
          BNE   Bad_File_Mode

**********
KYBD_Close
**********

          RTS

**********
KYBD_Chrin
**********

          BSR   Kbd_Get_Key
          BEQ   KYBD_Chrin
          TFR   B,A
          RTS

****************
KYBD_EOF ; $e4f3
****************

          CLRB
          RTS

****
SCRN
****

          FCB   "SCRN"           ; 0
          FDB   SCRN_Open        ; 4
          FDB   SCRN_Close       ; 6
          FDB   KYBD_Chrin       ; 8
          FDB   SCRN_Chrout      ; a
          FDB   SCRN_Status      ; c
          FDB   BAD_FILE_MODE    ; e

*********
SCRN_Open
*********

          CMPA  #$20
          BNE   Bad_File_Mode

**********
SCRN_Close
**********

          RTS

*******************
SCRN_Chrout ; $e50a
*******************

          TFR   A,B
          JUMP  PUTC

***********
SCRN_Status
***********

************************************************
* Output: A  = CR
*         B  = 26 (right margin - number size) *
*         XH = Column    [0..39]               *
*         XL = Right Margin [40]               *
************************************************

          LDA   Col
          LDB   #RIMA
          TFR   D,X
          LDD   #$0d1a
          RTS

          FILL $e540-*($15)

*************
Bad_File_Mode
*************

          JMP   BAD_FILE_MODE

****
LPRT
****

          FCB   "LPRT"        ; 0
          FDB   LPRT_Open     ; 4
          FDB   LPRT_Close    ; 6
          FDB   BAD_FILE_MODE ; 8 Chrin
          FDB   LPRT_Chrout   ; a
          FDB   LPRT_Status   ; c
          FDB   BAD_FILE_MODE ; e EOF

*********
LPRT_Open
*********

          BSR   SCRN_Open
          TST   PRTBUSY
          LBNE  DEVICE_BUSY
          LDU   #FILEDESC
          BSR   LPRT_Set_Margin

LPOP_10   COM   PRTBUSY
          LDB   #4

LPOP_20   STB   PR.OPC

********
PRT_BIOS
********

          CALL PRCO
          BCC   LPRT_Ret
          BSR   LPCL_10
          JMP   CRB_Err

***********
LPRT_Chrout
***********

          CMPA  #CR
          BNE   LPCL_20
          CLR   PRTCOL
          BRA   PRT_OUT

          FILL $e583-* (0)

**********
LPRT_Close
**********

          BSR   LPRT_Finish_Line

LPCL_10   CLR   PRTBUSY
          LDB   #$10
          BRA   LPOP_20

LPCL_20   CMPA  #' '
          BCS   PRT_OUT       ; -> control code
          LDB   PRTCOL
          CMPB  PRT_MARGIN
          BLO   LPCL_30
          PSHS  A             ; enforce new line
          BSR   LPRT_CRLF
          PULS  A
          CLR   PRTCOL

LPCL_30   INC   PRTCOL

*******
PRT_OUT
*******

          LDB   #1
          STB   PR.OPC
          TFR   A,B
          BRA   PRT_BIOS

***********
LPRT_Status
***********

          LDX   PRTCOL
          LDA   #13
          LDB   PRT_TAB_END
LPRT_Ret  RTS

***************
LPRT_Set_Margin
***************

          CLR   PRTCOL
          LDB   #40           ; default margin
          LDA   ,U
          BEQ   LPSM_10       ; -> use default
          LDX   TXTPTR
          PSHS  X
          STU   TXTPTR
          JSR   CHRGOT
          JSR   Scan_Linenumber
          LDD   LINNUM
          TSTA
          BNE   ILLQUA
          PULS  X
          STX   TXTPTR

LPSM_10   STB   PRT_MARGIN
          CLRA

LPSM_20   ADDA  #13
          CMPA  PRT_MARGIN
          BLS   LPSM_20
          SUBA  #26
          STA   PRT_TAB_END
LPSM_Ret  RTS

****************
LPRT_Finish_Line
****************

          TST   PRTCOL
          BEQ   LPSM_Ret

*********
LPRT_CRLF
*********

          CLR   PRTCOL
          LDA   #CR
          BSR   PRT_OUT
          LDA   #LF
          BRA   PRT_OUT

***********
SCREENPRINT
***********

          JSR   CHRGET
          LDA   PRTBUSY
          PSHS  A
          BNE   StPr_10
          LBSR  LPOP_10

StPr_10   BSR   LPRT_Finish_Line
          LDB   #2
          LBSR  LPOP_20
          LDA   ,S+
          BEQ   LPRT_Close

StPr_Ret  RTS

********************
BASIC_LOCATE ; $e5fe
********************

          JSR   Get_Clip_XY
          JSR   Set_Cursor
          JSR   CHRGOT
          BEQ   StPr_Ret
          BSR   Comma_1_or_0
          LBEQ  Cursor_On

******************
Cursor_Off ; $e60e
******************

          LDB   #DC4
          JUMP  PUTC

********************
Comma_1_or_0 ; $e612
********************

          JSR   Need_Comma

******************
Get_1_or_0 ; $e614
******************

          JSR   Byte_Var

********************
Assert_B_1_0 ; $e616
********************

          CMPB  #1
          BLS   StPr_Ret
ILLQUA    JMP   Illegal_Quantity

*******************
BASIC_ATTRB ; $e61c
*******************

          RTS

*************
BASIC_CONSOLE
*************

          LDB   Win_Top
          CMPA  #','
          BEQ   CONS_20
          JSR   Byte_Var
          CMPB  #24
CONS_10   BHI   ILLQUA
CONS_20   PSHS  B
          LDB   Win_Bot
          JSR   CHRGOT
          BEQ   CONS_30
          JSR   Need_Comma
          LDB   Win_Bot
          CMPA  #','
          BEQ   CONS_30
          JSR   Byte_Var
          CMPB  #24
          BHI   ILLQUA
CONS_30   CMPB  ,S
          BLO   ILLQUA        ; error if (bottom < top)
          STB   Win_Bot
          PULS  B
          STB   Win_Top
          JMP   Edit_Home

********************
BASIC_SCREEN ; $e6aa
********************

* SCREEN foreground, background, frame

          JSR   CHRGET
          CMPA  #TK_PRINT
          BEQ   SCREENPRINT
          BSR   Store_FG
          LDB   #3            ; Control C = Color
          CALL  PUTC          ; set window color
          BSR   Comma_Ret
          BEQ   SCRE_Ret
          BSR   Store_BG
          LDB   #2            ; Control B = Background
          CALL  PUTC
SCRE_Ret  RTS

***********
BASIC_COLOR
***********

* COLOR foreground, background

          BSR   Store_FG
          BSR   Comma_Ret
          BEQ   COLO_Ret
          BRA   Store_BG
COLO_Ret  RTS


*********
Comma_Ret
*********

          JSR   CHRGOT
          BEQ   Comma_Pop
          JSR   Need_Comma
          CMPA  #','
          RTS
Comma_Pop PULS  PC,D

********
Store_FG
********

          JSR   Byte_Var
          LSLB
          LSLB
          LSLB
          LSLB
          LDA   COLOUR
          ANDA  #15
          ORR   B,A
          STA   COLOUR
          RTS

********
Store_BG
********

          JSR   Byte_Var
          ANDB  #15
          LDA   COLOUR
          ANDA  #$f0
          ORR   B,A
          STA   COLOUR
          RTS

**********
FUNC_POINT
**********

          JSR   Get_XY_In_Pars
          CALL  GETP
          JMP   BAS_B_To_ACA

***********
FUNC_SCREEN
***********

* Char = SCREEN(Column,Row)

          JSR   Get_XY_In_Pars
          JSR   Clip_XY_To_D
          CALL  GETS
          JMP   B_To_ACA


**********
BASIC_IDSK
**********

          TST   DKFLG
          BEQ   IDSK_Err
          JSR   Byte_Var
          CLRA
          STD   DK.TRK
          JSR   Get_Comma_And_Byte
          STB   DK.SEC
          JSR   Need_Comma
          JSR   Get_Number
          STX   DK.BUF
          LDD   #$0200
          STD   DK.OPC
          JUMP  DKCO
IDSK_Err  JMP   Syntax_Error

*********
BASIC_DOS
*********

          TST   DKFLG
          BEQ   IDSK_Err
          LDX   #Basic_Coldstart
          STX   Boot_Error_Vector
          LDS   #$7FFF
          JMP   DKBOOT

          FILL $e749-* (0)

FSCR_Err  JMP   Illegal_Quantity


******
Get_XY
******

          LDD   #319
          BSR   Get_Word_Max_D
          PSHS  D
          JSR   Need_Comma
          LDD   #199
          BSR   Get_Word_Max_D
          TFR   D,Y
          PULS  PC,X

**********************
Get_Word_Max_D ; $e75d
**********************

          STD   Range_F
          JSR   Eval_Word
          CMPD  Range_F
          BLS   GWMD_Ret
          LDD   Range_F
GWMD_Ret  RTS

**********
Get_End_XY
**********

          LDB   #TK_MINUS     ; -(X,Y)
          JSR   Need_B

*************
Get_XY_In_Pars
*************

          JSR   Need_Left_Par
          BSR   Get_XY
          JMP   Need_Right

*******************
Get_Clip_XY ; $e775
*******************

          BSR   Get_XY

********************
Clip_XY_To_D ; $e777
********************

          CMPX  #RIMA
          BLO   CXYD_10
          LDX   #RIMA-1
CXYD_10   CMPY  #24
          BLS   CXYD_20
          LDY   #24
CXYD_20   TFR   Y,D
          PSHS  B
          TFR   X,D
          PULS  PC,A

******************
BASIC_PSET ; $e793
******************

* PSET(X,Y,),color

          BSR   Get_XY_In_Pars
          BSR   PSET_SUB
          RTS

*********
Get_Color
*********

          JSR   Need_Comma
          JSR   Eval_Numeric
          JSR   FUNC_CINT
          CMPD  #DIV0
          BLT   FSCR_Err
          CMPD  #$000f
          BGT   FSCR_Err
          BRA   BDOT_10

********
UXY_To_D
********

          PULU  Y,X
          BSR   Clip_XY_To_D
          PSHU  Y,X
UXY_Ret   RTS

**********************
Get_Line_Coord ; $e7b4
**********************

          LDU   #GRAX
          PULU  Y,X
          CMPA  #TK_MINUS
          BEQ   GLC_10
          BSR   Get_XY_In_Pars

GLC_10    LDU   #GRAX
          PSHU  Y,X
          PSHS  Y,X
          BSR   Get_End_XY
          SKIP2

********
PSET_SUB
********

          PSHS  Y,X           ; save X,Y
          LDU   #GRAX+4
          PSHU  Y,X           ; GRAX=X   GRAY=Y
          JSR   CHRGOT
          BEQ   BIOS_DOT
          CMPA  #','
          BEQ   Get_Color
          JSR   Need_String   ; PSET(X,Y),String
          STB   CHDRAW
          JSR   CHRGOT
          BEQ   PSET_10
          JSR   Need_Comma
          JSR   BASIC_COLOR

PSET_10   LDU   #GRBX
          BSR   UXY_To_D
          LEAU  4,U           ; U = #GRAX
          BSR   UXY_To_D
          PULS  U,Y,X
          BSR   Clip_XY_To_D
          PSHS  U
          JUMP  CHPL

********
BIOS_DOT
********

          LDB   COLOUR
          LSRB
          LSRB
          LSRB
          LSRB

BDOT_10   STB   FORME
          PULS  Y,X
          CLR   CHDRAW

BDOT_20   JUMP  PLOT

**********
BASIC_LINE
**********

          CMPA  #$ff
          LBEQ  LINE_INPUT
          BSR   Get_Line_Coord
          LDX   GRAX
LINE_10   LDY   GRAY

LINE_DRAW JUMP  DRAW

*********
BASIC_BOX
*********

          CLR   BOXFILL
          CMPA  #'F'          ; BOXF
          BNE   BOX_10
          STA   BOXFILL
          JSR   CHRGET

BOX_10    BSR   Get_Line_Coord
          LDU   #GRBX
          LDA   BOXFILL
          BNE   BOX_20
          LDX   4,U
          BSR   LINE_DRAW
          BSR   LINE_10
          LDX   ,U
          BSR   LINE_DRAW
          LDY   2,U
          BRA   LINE_DRAW

BOX_20    LDY   2,U

BOX_30    LDX   ,U
          BSR   BDOT_20
          LDX   4,U
          BSR   LINE_DRAW
          CMPY  6,U
          BEQ   BOX_Ret
          BHI   BOX_40
          LEAY  1,Y
          SKIP2

BOX_40    LEAY  -1,Y
          BRA   BOX_30
BOX_Ret   RTS

          FILL $e868-* (0)

*****************
BASIC_DEF ; $e868
*****************

          JSR   Get_FN
          LDB   #$ff
          JSR   Need_B
          LDB   #$99          ; DEFFN = $ff99
          JSR   Need_B
          JSR   Eval_In_Pars
          LDB   #TK_EQ
          JSR   Need_B
          JSR   Eval_Byte
          CMPB  USRCHR
          BCC   BDEF_Err
          LDA   #8
          MUL
          ADDD  MEMSIZ
          TFR   D,X
          LEAX  9,X
          LDA   #8
          PSHS  X,A

BDEF_10   JSR   Byte_Var
          PULS  X,A
          STB   ,-X
          DECA
          BEQ   BOX_Ret
          PSHS  X,A
          JSR   Need_Comma
          BRA   BDEF_10

BDEF_Err  JMP   Illegal_Quantity

******************
FUNC_STICK ; $e89f
******************

          BSR   STICK_10
          JMP   B_To_ACA

STICK_10  JSR   Eval_Byte
          JSR   Assert_B_1_0
          TFR   B,A
          JUMP  JOYS

******************
FUNC_PTRIG ; $e8ad
******************

          LDB   #0            ; always false
          BRA   STRIG_20

******************
FUNC_STRIG ; $e8b1
******************

          BSR   STICK_10
STRIG_10  LDB   #0
          SBCB  #0
STRIG_20  JMP   BAS_B_To_ACA

          FILL $e8e9-* (0)

******************
BASIC_EXEC ; $e8e9
******************

          JSR   Protected
          JSR   CHRGOT
          BEQ   EXEC_10
          JSR   Get_Number
          STX   EXEC_Pointer
EXEC_10   JMP   [EXEC_Pointer]

******************
BASIC_BEEP ; $e8fa
******************

          JUMP  BIIP

*****************
BASIC_CLS ; $e8fc
*****************

          LDB   #FF
          JUMP  PUTC

          FILL $e935-* (0)

***********************
Basic_Coldstart ; $e935
***********************

          LDB   #$21
          TFR   B,DP           ; BASIC DP = $2100
          CLR   MOTOR
          AIM   #%11100001,PRA ; black frame
          LDA   #$20           ; green on black
          STA   COLOUR
          BSR   BASIC_CLS      ; clear screen
          LDB   #$a5
          CMPB  WRMTST
          BEQ   Basic_Warmstart

*         LDX   #Basic_Coldstart
*         STX   Boot_Error_Vector
*         TST   DKFLG
*         BEQ   Cold_10
*         JUMP  DKBO          ; boot from disk

          FILL $e95d-* ($12) ; NOP

Cold_10   LDS   #$5fff
          BSR   Basic_Init
          LDX   #Msg_Start-1

          FILL $e966-* ($12) ; NOP

* Disk BASIC entry !!!

Cold_20   JSR   Print_Msg_X
          JSR   NEW_10
          BRA   Warm_20

          FILL $e96e-* ($15)

***********************
Basic_Warmstart ; $e96e
***********************

          LDS   FRETOP
          LDB   WRMFLG
          BEQ   Warm_10
          JSR   NEW_10
Warm_10   JSR   NEW_40
          JSR   Close_All
          JSR   Hook_228a
Warm_20   ANDCC #$af
          JSR   Cursor_On
          JMP   Main_10

          FILL $e989-* ($15)

**************************************************
* This entry point is used by the MO5 disk BASIC *
* So don't change the address !!!                *
**************************************************

******************
Basic_Init ; $e989
******************

          LDX   #ENDCHR
Init_10   CLR   ,X+
          CMPX  #RAMBOT
          BLS   Init_10
          STX   TXTTAB        ; = $2600
          LDB   #$a5
          STB   WRMTST
          LDX   #$97fe        ; top of RAM
          STX   TOPRAM
          STX   MEMSIZ
          STX   STRTAB
          LEAX  -300,X
          STX   FRETOP
          LDA   #2
          STA   INPSTD
          LDX   #Crunch_ROM_A
          LDU   #Crunch_Tab
          LDB   #10
          BSR   COPY_XUB
          LDX   #Syntax_Error
          STX   3,U        ; $220e Extension
          STX   8,U        ; $2213 Disc
          LDU   #$2233     ; store JMP Syntax_Error at $2233/6/9/c
          LDD   #$7e04     ; A = JMP   B = 4 times
          BSR   STORE_AXUB ; no AUTO and HEX$
          LDX   #Illegal_Quantity
          LDB   #12    ; store address at $223f - $2256
Init_30   STX   ,U++
          DECB
          BNE   Init_30
          LDB   #1     ; store JMP Illegal_Quantity at $2257
          BSR   STORE_AXUB
          LDX   #Device_Not_Present
          LDB   #7     ; store JMP Device_Not_Present at $225a - $226f
          BSR   STORE_AXUB
          LDD   #$390b ; A = RTS   B = 11
          BSR   STORE_AXUB
          LDX   #DATA_2390
          LDU   #$2390
          LDB   #$40 ; '@'
          BSR   COPY_XUB
          COM   BUF_LNK+1
          LDX   #ROM_CHRGET
          LDU   #CHRGET
          LDB   #$54 ; 'T'
          BRA   COPY_XUB

          FILL $ea00-* ($39)

******************
STORE_AXUB ; $ea00
******************

          STA   ,U+
          STX   ,U++
          DECB
          BNE   STORE_AXUB
          RTS

******************
Init_Sound ; $ea08
******************

          BSR   MEM_UCHR_X
InSo_10   CLR   1,X
          LEAX  -1,X
          CMPX  MEMSIZ
          BHS   InSo_10
          LDX   #Sound
          LDU   #TEMPO
          LDB   #7

****************
COPY_XUB ; $ea1a
****************

          LDA   ,X+
          STA   ,U+
          DECB
          BNE   COPY_XUB
          RTS

******************
MEM_UCHR_X ; $ea22
******************

          LDX   MEMSIZ
          LDB   USRCHR
          LDA   #8
          MUL
          LEAX  D,X
          RTS

********************
Crunch_ROM_A ; $ea2c
********************

          FCB   $56,KEYWORD_TAB_A
          FDB   Action_Switch ; -> $2204

********************
Crunch_ROM_B ; $ea31
********************

          FCB   $27,KEYWORD_TAB_B
          FDB   BASIC_Function_A ; -> $2209

********************************************************
* Following routines are copied to BASIC's direct page *
* From ROM_CHRGET to $21ac - $21ff                     *
********************************************************

******************
ROM_CHRGET ; $ea36
******************

          INC   TXTPTR+1             ; $ac = CHRGET
          BNE   ROM_CHRGOT           ; $ae
          INC   TXTPTR               ; $b0

******************
ROM_CHRGOT ; $ea3c
******************

          LDA   0                    ; $b2 = CHRGOT
          CMPA  #' '                 ; $b5
          BEQ   ROM_CHRGET           ; $b7
          CMPA  #':'                 ; $b9 = ISNUM
          BCC   CHRG_RTS             ; $bb
          SUBA  #'0'                 ; $bd
          SUBA  #$d0                 ; $bf
CHRG_RTS  RTS                        ; $c0

          JMP   BAS_Need_Comma       ; $c2 = Need_Comma
          LDA   ACA_SZ               ; $c5 = Test_ACA_Type
          JMP   BAS_Set_Type_Flags   ; $c7 = Set_Type_Flags
          JMP   BAS_Dec_TXTPTR       ; $ca = Dec_TXTPTR
          JSR   Dec_TXTPTR           ; $cd = Eval_Numeric
          JSR   Eval_Expression      ; $cf
          JMP   BAS_Assert_ACA_Num   ; $d1 = Assert_ACA_Num
          JSR   Eval_Expression      ; $d4 - unused
          JMP   BAS_Assert_ACA_Desc  ; $d6 = Assert_ACA_Desc
          JSR   Dec_TXTPTR           ; $d9 = Dec_Eval_Exp
          JMP   BAS_Eval_Expression  ; $db = Eval_Expression
          LDB   #')'                 ; $de = Need_Right
          JMP   BAS_Need_B           ; $e0 = Need_B
          JMP   DEV_CHROUT           ; $e3 = CHROUT
          JMP   BAS_Byte_Var         ; $e6 = Byte_Var
          JMP   BAS_Cast_ACA_Real    ; $e9 = Cast_ACA_Real
          CLRA                       ; $ec = B_To_ACA
          JMP   BAS_D_To_ACA         ; $ed = D_To_ACA
          JMP   BAS_Parse_Name       ; $f0 = Parse_Name
          JMP   BAS_Device_Context   ; $f3 = Device_Context
          LDB   #5                   ; $f6 = Illegal_Quantity
          FCB   $8c                  ; $f8
          LDB   #2                   ; $f9 = Syntax_Error
          JMP   BAS_Print_Error_B    ; $fb = Print_Error_B
          FDB   0                    ; $fe = ZERO_W

* End of routines in direct page

*****************
Msg_Start ; $ea8a
*****************

          FCB   FF,"Green Basic\r\n\n"
          FILL $eaad-* (0)

Vocals    FCB   "aeiou",$ff   ; OBSOLETE

Sound     FDB    5            ; tempo
          FDB   24            ; duree
          FCB    0            ; timbre
          FDB    2            ; octave

*****************
DATA_2390 ; $eaba
*****************

          FCB   $9d,$a0 ; copied to $2390 - $23cf
          FCB   $06,$a2
          FCB   $1d,$1e
          FCB   $2c,$83
          FCB   $99,$0a,$0b,$39,$28,$25,$10,$22
          FCB   $9a,$03,$1c,$2b,$a4,$26,$21,$24
          FCB   $9c,$05,$0f,$1f,$1b,$2e,$11,$2a
          FCB   $9b,$98,$08,$16,$01,$2d,$34,$8a
          FCB   $a1,$97,$3b,$09,$07,$9f,$33,$20
          FCB   $37,$a6,$46,$04,$3c,$44,$32,$02

***************************
* Device_Tab $eaf2 -> $23c8
***************************

          FDB   KYBD          ; $23c8  0:keyboard
          FDB   SCRN          ; $23ca  1:screen
          FDB   CASS          ; $23cc  2:cassette
          FDB   LPRT          ; $23ce  3:printer

****
CASS
****

          FCB   "CASS"        ; 0:
          FDB   CASS_Open     ; 4:
          FDB   CASS_Close    ; 6:
          FDB   CASS_Chrin    ; 8:
          FDB   CASS_Chrout   ; a:
          FDB   CASS_Status   ; c:
          FDB   CASS_EOF      ; e:

***********
CASS_Status
***********

          COM   PRTDEV
          LDD   #$0100
          LDX   ZERO_W
          RTS

CACI_10   LDB   Bytes_Read
          SUBB  -1,Y          ; minus bytes in buffer
          LDA   D,Y           ; load byte
          DEC   -1,Y          ; dec bytes in buffer
          BNE   CACI_Ret      ; -> buffer not empty
          PSHS  A
          BSR   CASS_Read_Block         ; fill buffer
          PULS  PC,A

****************
CASS_EOF ; $eb22
****************

          BSR   Y_CASS_FN
          BNE   CEOF_10
          COMA
CEOF_10   EXG   A,B
          RTS

******************
CASS_Chrin ; $eb2a
******************

          BSR   Y_CASS_FN
          BNE   CACI_10
          COM   CINBFL
CACI_Ret  RTS

*****************
CASS_Open ; $eb31
*****************

          TST   CASS_BUSY
          BNE   DEVICE_BUSY
          CMPA  #$10
          BEQ   CACO_20
          LDX   #FILENAME
          TST   ,X+
          LBEQ  SeFi_Err
          LDU   #CASS_FN
          LDB   #11
          JSR   COPY_XUB
          LDD   SAVDEV
          STD   ,U++
          LDA   D2196
          STA   ,U+
          LDB   #14
          STB   -15,U
          LDA   #2
          STA   CASS_BUSY
          CLR   CASS_MODE
          STB   D2197
          JSR   CASS_Write_Block
          LDA   D2196
          STA   D2197

COpen_10  BSR   Y_CASS_FN
          CLR   -1,Y
          RTS

******************
CASS_Close ; $eb6a
******************

          TST   CASS_BUSY
          BEQ   CStop_Ret
          CMPA  #$20
          BNE   CASS_Stop
          BSR   Y_CASS_FN
          BEQ   Cclose_10
          BSR   CACO_30

Cclose_10 LDB   #$ff
          BSR   CACO_40

*****************
CASS_Stop ; $eb7c
*****************

          JSR   Motor_Off
          CLR   CASS_BUSY
CStop_Ret RTS

***************
CASS_Read_Block
***************

          BSR   CASS_Start
          BEQ   CRB_10
          BMI   CRB_Ret
          BSR   Y_CASS_FN
          BEQ   CASS_Read_Block ; -> buffer empty

CRB_Ret   RTS

CRB_10    BSR   CASS_Stop

CRB_Err   LDB   #$35          ; I/O error
          SKIP2

***********
DEVICE_BUSY
***********

          LDB   #$3b
          JMP   Print_Error_B

*********
Y_CASS_FN
*********

          LDY   #CASS_FN
          CLRA
          LDB   -1,Y
          RTS

*******************
CASS_Chrout ; $eb9e
*******************

          PSHS  A
          BSR   Y_CASS_FN
          ADDB  #2
          BNE   CACO_10       ; -> buffer not full
          BSR   CACO_30       ; -> flush buffer
          LDB   #2            ; init buffer pointer

CACO_10   DECB
          STB   -1,Y          ; update buffer pointer
          LEAY  D,Y           ; Y = write pos.
          PULS  A
          STA   -1,Y          ; store byte in buffer
          RTS

CACO_20   BSR   CASS_Search
          BSR   COpen_10
          LDD   11,Y
          STD   SAVDEV
          LDA   13,Y
          STA   D2196
          STA   D2197
          INC   CASS_BUSY
          BRA   CASS_Read_Block

CACO_30   LDB   #1

CACO_40   STB   CASS_MODE
          BSR   CASS_Write_Block
          BRA   COpen_10

*******************
BASIC_SDDSK ; $ebce
*******************

* SDDSK LBA, MEMORY

* ATTN: possibly timeout in A317 loop
*       waiting for handshake

          TST   DKFLG
          BEQ   SDDSK_Err
          JSR   Get_Number
          CLR   SD_LBA
          CLR   SD_LBA+1
          STX   SD_LBA+2
          JSR   Need_Comma
          JSR   Get_Number
          STX   DK.BUF
          PSHS  CC,DP
          LDA   #DIRECT
          TFR   A,DP
          ORCC  #$50
          JSR   $a02b         ; RS512
          PULS  PC,CC,DP

SDDSK_Err JMP   Syntax_Error

*         LDA   #2
*         LDU   #F_BAS
*         JSR   Set_Filename_A
*         LDA   INPDEV
*         CMPA  #2
*         LBNE  Illegal_Quantity
*         BSR   CACO_20
*
*SKIPF_10 TST   CASS_MODE
*         BMI   CASS_Stop
*         BSR   CASS_Read_Block
*         BRA   SKIPF_10

**********
CASS_Start
**********

*         BSR   Motor_On
*         LDY   #CASS_FN-1
*         CALL  K7CO
*         TSTA
*         BNE   CRB_10
*         LDA   ,Y+
*         SUBA  #2
*         STA   Bytes_Read
*         STA   -1,Y
*         BSR   CAWB_30
*         STB   CASS_MODE
          RTS

          FILL $ec00-* (0)

************************
CASS_Write_Block ; $ec00
************************

          BSR   Motor_On
          BSR   Y_CASS_FN
          LEAX  ,Y
          TSTB
          BEQ   CAWB_20

CAWB_10   ADDA  ,X+
          DECB
          BNE   CAWB_10

CAWB_20   NEGA
          STA   ,X
          INC   ,-Y
          INC   ,Y
          CLRA                ; A = 0 : write
          LDB   CASS_MODE         ; B =
          CALL  K7CO

CAWB_30   TST   D2197
          BEQ   Mon_Ret

*****************
Motor_Off ; $ec1e
*****************

          CLRA                ; motor off
Moff_10   STA   MOTOR
          CALL  K7MO
          BCC   Mon_Ret
          LDB   #$3c          ; DEVICE UNAVAILABLE
          JMP   Print_Error_B

********
Motor_On
********

          LDA   CASS_BUSY
          ORA   #1            ; motor on
          TST   MOTOR
          BEQ   Moff_10
Mon_Ret   RTS

***********
CASS_Search
***********

          LDA   CURLIN
          INCA
          STA   CASS_Msg_Flag ; 0 for direct mode

CASe_10   LDX   #Msg_Searching-1
          BSR   CASe_50

CASe_20   CLR   D2197
          BSR   CASS_Start
          BNE   CASe_20       ; -> loop
          BSR   Motor_Off
          LDX   #FILENAME
          TST   ,X+
          BEQ   CASe_40       ; -> no filename
          LDB   #11

CASe_30   LDA   ,X+           ; compare filenames
          CMPA  ,Y+
          BNE   CASe_70       ; -> no match
          DECB
          BNE   CASe_30

CASe_40   LDX   #Msg_Found-1  ; match
          BSR   Print_CASS_FN
          LDX   #Msg_Newline-1

CASe_50   TST   CASS_Msg_Flag

CASe_60   BNE   Mon_Ret
          JMP   Print_Msg_X

CASe_70   LDX   #Msg_Skip-1   ; skip message
          BSR   Print_CASS_FN
          BRA   CASe_10       ; -> try next

*************
BASIC_MONITOR
*************

          FCB   $15,$15       ; illegal instruction
*         TFR   A,B
*         JSR   CHRGET
          CMPB  #TK_ON
          BEQ   Motor_On
          CMPB  #TK_OFF
          BEQ   Motor_Off
          JMP   Syntax_Error

*************
Print_CASS_FN
*************

          BSR   CASe_50
          TST   CASS_Msg_Flag
          BNE   CASe_60
          LDX   #CASS_FN
          LDB   #8            ; filename
          BSR   PCFN_10
          JSR   Print_Blank
          LDB   #3            ; extension

PCFN_10   JMP   PFS_10

*********************
Msg_Searching ; $ec8f
*********************

          FCB   "\r\nSearching"

***********
Msg_Newline
***********

          FCB   "\r\n",0

*****************
Msg_Found ; $ec9d
*****************

          FCB   "Found: ",0
Msg_Skip  FCB   "Skip: ",0

          FILL $ecac-* ($15)

***********
Fill_Buffer
***********

          LDX   #BUF_TXT+1

FiBu_10   JSR   DEV_CHRIN
          TST   CINBFL        ; stop on EOF
          BNE   FiBu_30
          CMPA  #CR           ; stop on return
          BEQ   FiBu_30
          CMPA  #$1c          ; a umlaut
          BLO   FiBu_10       ; ignore unprintable
          STA   ,X+
          CMPX  #BUF_TXT+256  ; C = 1 for buffer full
          BLO   FiBu_10

FiBu_30   BRA   Terminate_Buffer

          FILL $eccf-* (0)

*********************
Edit_Get_Line ; $eccf
*********************

*********************************************
* read line from device selected by CHANNEL *
*                                           *
* return: C = 0 line is stored in BUF_TXT   *
*         C = 1 nothing read or EOF         *
*********************************************

          JSR   Test_Input_Char
          BNE   Fill_Buffer   ; fill buffer from device

          CLR   CINBFL        ; input buffer status
          LDD   Row           ; A=Row  B=Col
          STD   STR_B3        ; remember start
          BSR   Unlink_Prev_Row
          LDA   Win_Top
          BSR   Unlink_Prev_Row
          LDA   Win_Bot
          BSR   Unlink_Prev_Row

EGL_10    BSR   Cursor_On
          JSR   KYBD_Chrin
          JSR   Cursor_Off    ; stay in screen editor
          CMPA  #CR           ; until CR is hit
          BEQ   Screen_To_Buffer
          TFR   A,B           ; echo on screen
          CALL  PUTC
          CLR   [Wpt_Bot]
          BRA   EGL_10

****************
Screen_To_Buffer
****************

          BSR   Find_SOL      ; find start of line
          CMPA  STR_B3        ; where we started ?
          BNE   STB_10        ; no: start from column 0
          LDD   STR_B3        ; else start after prompt

STB_10    PSHS  D             ; push start of read
          BSR   Find_LNB
          STD   STR_B1        ; end of read
          LDD   ,S            ; D = start row/col
          LDX   #BUF_TXT+1    ; X = target buffer

STB_20    CMPD  STR_B1        ; beyond end
          BHI   CR_Terminate  ; -> finish
          JSR   Bios_Getchar  ; get char from screen
          CMPX  #BUF_TXT+256  ; buffer full ?
          BEQ   CR_Terminate  ; yes -> finish
          STB   ,X+           ; store in buffer
          LDD   ,S            ; D = current row/col
          INCB                ; cursor right
          CMPB  #RIMA         ; at right margin ?
          BLO   STB_30        ; -> no
          CLRB                ; left margin
          INCA                ; next row
STB_30    STD   ,S            ; save on stack
          BRA   STB_20        ; loop

***************
Unlink_Prev_Row
***************

          DECA
          BMI   UnRA_Ret

************
Unlink_Row_A
************

          LDX   #TERMIN
          CLR   A,X
UnRA_Ret  RTS


************
CR_Terminate
************

          STX   ,S            ; save buffer pointer on stack
          BSR   Advance_Line  ; next screen position
          JSR   Print_CRLF    ; return
          PULS  X             ; restore buffer pointer

****************
Terminate_Buffer
****************

          CLR   ,X+           ; put zero terminator
          LDX   #BUF_TXT      ; reset buffer pointer
          RTS

************
Advance_Line
************

          BSR   Find_End_Row
          BSR   Set_Cursor

*****************
Cursor_On ; $edc5
*****************

          LDB   #DC1
          JUMP  PUTC

*********
Edit_Home
*********

          LDB   #6            ; code for HOME
          JUMP  PUTC

**********
Set_Cursor
**********

          PSHS  D
          STD   Row           ; set Row/Col
          LSLA
          LDB   #160
          MUL
          ADDB  Col
          STD   SCRPT
          PULS  PC,D

************
Find_End_Row
************

*****************************
*       Find End Row        *
*****************************
* Input : current Row / Col *
* Output: A = Last Row      *
*       : B = Col           *
*       : X = TERMIN        *
*****************************
* No direct page access     *
*****************************

          LDX   #TERMIN
          LDD   Row           ; A = Row   B = Col
FER_10    TST   A,X
          BEQ   FER_Ret
          INCA
          BRA   FER_10
FER_Ret   RTS

********
Find_SOL
********

*****************************
*    Find Start Of Line     *
*****************************
* Input : current Row       *
* Output: A = Row of SOL    *
*       : B = Col = 0       *
*       : X = TERMIN        *
*****************************
* No direct page access     *
*****************************

          LDX   #TERMIN
          CLRB                ; Col = 0
          LDA   Row
FSOL_10   CMPA  Win_Top       ; at top of window ?
          BLS   FSOL_Ret      ; can't go further up
          DECA
          TST   A,X
          BNE   FSOL_10       ; -> linked row
          INCA                ; stay blow unlinked row
FSOL_Ret  RTS

********
Find_LNB
********

*****************************
*    Find Last Non Blank    *
*****************************
* Input : current Row / Col *
* Output: A = Row of EOL    *
*       : B = Col of EOL    *
*       : X = TERMIN        *
*****************************
* No direct page access     *
*****************************

          LDX   #TERMIN
          BSR   Find_End_Row  ; A = last row of line
FLNB_10   LDB   #RIMA-1       ; B = last col [39]
FLNB_20   BSR   Cell_Is_Empty
          BNE   FLNB_Ret      ; -> found non blank
          DECB                ; decrement Col
          BPL   FLNB_20       ; loop
          CLRB                ; Col = 0
          CMPA  Win_Top       ; at top of window ?
          BLS   FLNB_Ret      ; yes: finish
          DECA                ; one row up
          TST   A,X           ; loop if linked row
          BNE   FLNB_10       ; next row
          INCA                ; start row
FLNB_Ret  RTS



*************
Cell_Is_Empty
*************

***********************************
* Test if character cell is empty *
***********************************
* Input : A = Row (0..24)         *
*       : B = Col (0..39)         *
* Output: Z = 1 for empty cell    *
***********************************
* No direct page access           *
***********************************

          PSHS  D,X           ; S -> A,B,X
          JSR   Row_Address   ; D = Row  address
          ADDB  1,S           ; add Col = pushed B
          TFR   D,X           ; X = Cell address
          LDB   #8            ; test 8 bytes

CEI_10    TST   ,X
          BNE   CEI_Ret       ; -> not empty
          LEAX  40,X
          DECB
          BNE   CEI_10        ; loop finishes with Z=1

CEI_Ret   PULS  PC,D,X

********************
Bios_Getchar ; $eede
********************

          PSHS  X
          TFR   D,X
          CLRA
          EXG   D,X
          CALL  GETS
          PULS  PC,X

          SIZE

*               whi,red,ora,yel,gre,cya,mag,whi
ColTab    FCB   $70,$10,$f0,$30,$20,$60,$50,$70

********
Colorize
********

          CALL  FRM0
          LDB   #8
          LDX   #0
          LDY   #ColTab

Colo_10   LDA   ,Y+
          LDE   #40

Colo_20   STA   ,X+
          DECE
          BNE   Colo_20
          DECB
          BNE   Colo_10
          RTS


***************
PLAY_05 ; $ef22
***************

          JSR   CHRGOT
          BEQ   PLAY_Ret
          JSR   Need_Comma

******************
BASIC_PLAY ; $ef28
******************

          JSR   Eval_String   ; Read play string
          LEAY  ,X            ; Y = string
          STB   COUNT         ; length
PLAY_10   TST   COUNT
          BEQ   PLAY_05       ; -> next play string or return
          BSR   PLAY_GETC     ; get next char from play string
          CMPA  #' '
          BEQ   PLAY_10       ; -> ignore blanks
          CMPA  #';'
          BEQ   PLAY_10       ; optional delimiter
          BSR   PLAY_NOTE
          BRA   PLAY_10       ; -> loop

*********
PLAY_NOTE
*********

          CLRB
          CMPA  #'P'          ; Pause
          BEQ   PLAY_75
          LDX   #PLAYATT
          TST   COUNT
          BEQ   PLAY_25
          LDB   ,Y            ; get 2nd. char into B
          LEAX  -14,X         ; #DOREMI

PLAY_20   CMPD  ,X++          ; search for DO RE MI FA SO LA SI
          BEQ   PLAY_65       ; -> match
          CMPX  #PLAYATT      ; at end of list
          BNE   PLAY_20       ; no: -> loop

PLAY_25   CMPA  ,X            ; attribute character ?
          BEQ   PLAY_35       ; -> yes
          LEAX  5,X           ; -> point to next attribute character
          CMPX  #DOREMI       ; at end of list ?
          BNE   PLAY_25       ; -> loop

PLAY_Err  JMP   Illegal_Quantity

PLAY_35   BSR   PLAY_GETC     ; get attribute value
          BCC   PLAY_Err      ; -> not numeric
          CLRB

PLAY_40   SUBA  #'0'          ; ASCII -> binary
          PSHS  A             ; push digit
          LDA   #10
          MUL                 ; D = B * 10
          TSTA
          BNE   PLAY_Err      ; -> error: result > 256
          ADDB  ,S+           ; add pushed digit
          BCS   PLAY_Err      ; -> error: result > 256
          TST   COUNT
          BEQ   PLAY_45       ; -> end of string
          BSR   PLAY_GETC     ; get next character
          BCS   PLAY_40       ; loop for decoding value
          LEAY  -1,Y          ; unget
          INC   COUNT

PLAY_45   CMPB  1,X           ; minimum
          BCS   PLAY_Err
          CMPB  2,X           ; maximum
          BHI   PLAY_Err
          CMPX  #PLAYOCT      ; octave selector ?
          BNE   PLAY_50       ; -> no
          LDU   #OCTTBL-1     ; Sert pour la table d'octaves de MUS
          LDB   B,U
PLAY_50   STB   [3,X]         ; store in variable
PLAY_Ret  RTS

*********
PLAY_GETC
*********

          TST   COUNT
          BEQ   PLAY_Err
          LDA   ,Y+
          DEC   COUNT
          JMP   ISNUM         ; test for numeric and return

PLAY_65   BSR   PLAY_GETC     ; get next character
          TFR   X,D           ; D = match position
          SUBD  #DOREMI+1     ; minus absolute address
          CMPB  #5            ; MI ?
          BLS   PLAY_70       ; -> DO RE MI
          DECB
PLAY_70   TST   COUNT
PLAY_75   BEQ   PLAY_85       ; -> jump to monitor
          LDA   ,Y
          CMPA  #'#'          ; sharp ?
          BNE   PLAY_80
          INCB
          BSR   PLAY_GETC
PLAY_80   CMPA  #'b'          ; flat ?
          BNE   PLAY_85
          BSR   PLAY_GETC
          DECB
          BNE   PLAY_85
          LDB   #12
PLAY_85   JUMP  NOTE

*                0 1 2 3 4 5 6
DOREMI    FCB   "DOREMIFASOLASI"

*                  Min  Max  Variable
PLAYATT   FCB   'T', 1, 255, TEMPO  + 1
          FCB   'A', 0, 255, TIMBRE
          FCB   'L', 1,  96, DUREE  + 1
PLAYOCT   FCB   'O', 1,   5, OCTAVE + 1

********************
Store_String ; $efef
********************

          CMPX  FRETOP
          BCS   StSt_10
          CMPU  VARTAB
StSt_10   LBCS  Hook_2284
          JSR   Allocate_String_B
          JSR   Load_XB_DSD_ACA
          JSR   Store_Push_Descriptor
          JMP   Load_XB_DSD_ACA

          FILL $effe-* ($15)

APPLIC    FDB   Basic_Coldstart


******************
COLD_START ; $f000
******************

        SETDP   $20
        CLR     WRMTST        ; BASIC warm start flag

DEPART  LDB     #DIRECT       ; direct page
        TFR     B,DP

#if NATIVE
        LDMD    #1            ; 6309 native mode
#endif
        LDS     #COLDST       ; initial stack
        LDU     #TABADR       ; U -> ROM vector table
        LDX     #LATCLV       ; X -> RAM vector table
DEPA_20 PULU    D             ; D =  next vector
        CLR     ,-X           ; clear flag
        STD     ,--X          ; copy vector
        CMPX    #SWI1PT       ; until SWI1PT.
        BHI     DEPA_20

DEPA_30 CLR     ,-X
        CMPX    #TERMIN
        BHI     DEPA_30

        LDB     #DIRECT
        STB     Wpt_Row       ; B = direct page
        STB     Wpt_Top
        STB     Wpt_Bot

        LDD     #$070C
        STA     LATCLV        ; keyboard latency = 7
        STD     GRCODE        ; GRCODE = 7, DECALG = 12

        CLR     DKFLG         ; init to not present
        LDX     #IDDISK       ; disk ROM
        LDB     #$55
        ADDB    ,X+           ; checksum
        ADDB    ,X+
        ADDB    ,X+
        CMPB    ,X            ; match ?
        BNE     INIPIA
        DEC     DKFLG         ; disk ROM present flag

******
INIPIA
******

********************************
* Interrupt lines              *
* ---------------------------- *
* CA1 : liqhtpen               *
* CA2 : cassette motor (1=off) *
* CB1 : 50 Hz timer            *
* CB2 : overlay (1=normal)     *
********************************

*       LDA     #%01011111    ; 7: inp cassette read
*       STA     PRA           ; 6: out cassette write
                              ; 5: inp interruption photostyle
                              ; 4: out frame light
                              ; 3: out frame blue
                              ; 2: out frame green
                              ; 1: out frame red
                              ; 0: out character (1) or colour (0) RAM

*       LDA     #%01111111    ; 7  : inp keyboard read
*       STA     PRB           ; 6-1: out keyboard matrix

*       LDA     #%0011 1110   ; 54:11 write b3:set CA2 low(0)/high(1)
*       STA     CRA           ; 2: 0:PRA=DDR  , 1:PRA=DATA
                              ; 1: 0:high->low, 1:low->high transition
                              ; 0: 1:enable IRQA

*       LDA     #%0011 1111   ; 54:11 write b3:set CA2 low(0)/high(1)
*       STA     CRB           ; 2: 0:PRB=DDR  , 1:PRB=DATA
                              ; 1: 0:high->low, 1:low->high transition
                              ; 0: 1:enable IRQB

        CLRD
        STD     CRA           ; switch ports to DDR

*                  PRA       PRB       CRA       CRB
        LDQ     #% 0101 1111 0111 1111 0011 1110 0011 1111
        STQ     PRA

****************
* Gameport PIA *
****************

          LDD   #$0404        ; switch port A and B to DATA mode
          STD   CRA1
          DEC   ENACUR        ; enable cursor
          LDA   #24
          STA   Win_Bot

          TFR   V,D
          INCD
          LBNE  TRAPMON
          TFR   D,V

          JMP   [APPLIC]      ; Adresse de demarrage en $EFFE.

***************
* Stack       *
*-------------*
* 6809   6309 *
* c:     PC   *
* b:          *
* a: PC  U    *
* 9:          *
* 8: U   Y    *
* 7:          *
* 6: Y   X    *
* 5:     DP   *
* 4: X   F    *
* 3: DP  E    *
* 2: B   B    *
* 1: A   A    *
* 0: CC  CC   *
***************

******
SWITCH
******

        LDA     ,S            ; load  stacked CC register
        ANDA    #$F0          ; reset IRQ flags
        STA     ,S            ; store stacked CC register
        TFR     A,CC          ; update CC register
        LDA     #DIRECT       ; direct page
        TFR     A,DP          ; set DP
        LDB     [10+STOFF,S]  ; load code byte after SWI
        ANDB    #$7F          ; mask out JUMP bit
        LDX     SIMUL         ; switch table
        LDD     B,X           ; D = address of bios routine
        LDX     #OUT          ; X = desired return address
        PSHS    D,X           ; push return and call adresses
        LDU     #PRA          ; preload U with PRA
        LDD     5,S           ; 1 + 4 (PSHS D,X) : restore D
        LDX     8+STOFF,S     ; 4 + 4 (PSHS D,X) : restore X
        RTS                   ; call routine from SIMUL table

***
OUT
***

        TFR     CC,A          ; get CC
        ANDA    #$8F          ;
        ORA     ,S            ;
        STA     ,S            ; store CC for return
        LDX     10+STOFF,S    ; address after SWI
        LDB     ,X+           ; get command byte
        BMI     JMPTYP        ; bit 7 set: JUMP type
        STX     10+STOFF,S    ; change stacked PC
RTIPNT  RTI

JMPTYP  PULS    CC,A,B
#if NATIVE
        PULSW
#endif
        PULS    DP,X,Y,U
        LEAS    2,S           ; remove return address
RTSPNT  RTS                   ; return one level above

******************************************************************
* TABLE DES ADRESSES A METTRE DANS LES POINTEURS DE LA PAGE ZERO *
******************************************************************

TABADR  FDB     CHARGEN       ; $2073 GENPTR
        FDB     CHARGEN       ; $2070 USERAF
        FDB     TABASC        ; $206d CHRPTR
        FDB     TBNTRY        ; $206a SIMUL
        FDB     RTIPNT        ; $2067 FIRQPT
        FDB     RTIPNT        ; $2064 IRQPT
        FDB     RTIPNT        ; $2061 TIMEPT
        FDB     SWITCH        ; $205e SWI1PT

*********************************
* TABLE DE BRANCHEMENT STANDARD *
*********************************

TBNTRY  FDB     DEPART      ; 00 Retour au menu principal (MENU$)
        FDB     PUTCH       ; 02 Envoi d'un caractere (PUTC$)
        FDB     Sel_Col_RAM ; 04 select colour RAM
        FDB     Sel_Chr_RAM ; 06 select bitmap RAM (character)
        FDB     BUZZER      ; 08 Biip du clavier (BIIP$)
        FDB     GETCH       ; 0a Saisie d'un caractere au clavier (GETC$)
        FDB     KEYTST      ; 0c Controle rapide des touches clavier (KTST$)
        FDB     DRAWXY      ; 0e Trace d'un vecteur (DRAW$)
        FDB     PLOTXY      ; 10 Controle d'un point (PLOTS)
        FDB     CHPLOT      ; 12 Vecteurs "caracteres" (CHPL$)
        FDB     GETPT       ; 14 Test du status d'un point (GETP$)
        FDB     LPINT       ; 16 Lecture light-pen (LPIN$)
        FDB     Monitor     ; 18 ML monitor
        FDB     GETSC       ; 1a Recherche d'un caractere sur I'ecran (GETS$)
        FDB     JOYSTK      ; 1c Lecture des joysticks (JOYS$)
        FDB     NOTE        ; 1e Generateur de musique (NOTE$)
        FDB     P_EXIT      ; 20 Controleur de lecteur de cassettes (K7CO$)
        FDB     P_EXIT      ; 22 Mise en route ou arret moteur K7 (K7MO$)
        FDB     P_EXIT      ; 24 Controleur d'imprimante parallele (PRCO$)
        FDB     DKCONT      ; 26 Controleur de disquette (DKCO$)
        FDB     DKBOOT      ; 28 Points d'entree disque
        FDB     DKFMT       ; 2a format disk
        FDB     ALLOB       ; 2c allocate block
        FDB     ALLOD       ; 2e create file
        FDB     ECRSE       ; 30 write sector
        FDB     FINTR       ; 32 close write file
        FDB     LECFA       ; 34 load FAT
        FDB     MAJCL       ; 36 update cluster
        FDB     RECFI       ; 38 open file
        FDB     RECUP       ; 3a delete file

***********************************************
* Keyboard scan with autorepeat and click     *
* CONTROL  clears bit 6                       *
* BASIC    sets   bit 7                       *
* SHIFT    translates to upper case or symbol *
* KEYTST   returns:                           *
*  Z = 1   F = $3a       no key press         *
*  Z = 0   F = key index                      *
* CMPTKB   counter                            *
* KEY      previous key index or zero         *
* CAPSLK   0 : no CAPS lock                   *
* AUTRPT   0 : autorepeat is active           *
***********************************************

******
KEYTST
******

* 0 : $72 : BASIC  % *....
* 1 : $70 : SHIFT  % .*...
* 2 : $6e : STOP   % ..*..
* 3 : $6c : ACC    % ...*.
* 4 : $6a : CNT    % ....*

          CLRW                ; E = modifier, F = key index
          LDB   #$72          ; start with BASIC key

KEYT_10   STB   PRB-PRA,U     ; put code
          LDF   PRB-PRA,U     ; bit 7 = 0 : key pressed
          ROLW                ; rotate bit 7 of F into E
          SUBB  #2            ; next key
          CMPB  #$6a          ; CONTROL
          BHS   KEYT_10       ; loop
          LDF   #5            ; start of normal keys

KEYT_20   STB   PRB-PRA,U     ; put code
          TST   PRB-PRA,U     ; bit 7 = 0 : key pressed
          BPL   KEYT_30       ; -> exit
          INCF                ; next key
          SUBB  #2            ; next code
          BPL   KEYT_20       ; loop

KEYT_30   STW   3,S           ; store result for caller A,B
          CMPF  #$3A          ; Z = 1 for no key
          RTS

          FILL $f168-* (0)
DCMOTO_A  FCB   $11,$ec,$39   ; lecture bit cassette

          FILL $f181-* (0)
DCMOTO_B  FCB   $11,$ed,$39

          FILL $f1af-* (0)
DCMOTO_C  FCB   $11,$ee,$39


*****
GETCH
*****

          PSHS  CC,D          ; receive result in stack
          JSR   KEYTST        ; scan keyboard

GETC_10   TFR   W,Y           ; remember result
          LDX   #625          ; Anti-rebond de 5 Msec. = 625 * 8 Usec.

GETC_15   LEAX  -1,X
          BNE   GETC_15
          JSR   KEYTST
          CMPR  W,Y           ; same result ?
          BNE   GETC_10       ; no -> debounce
          PULS  CC,D          ; A = flags, B = key index

          CMPB  #$3A          ; B contient le code de la touche.
          BEQ   GETC_30
          CMPB  KEY           ; Est-ce toujours la meme touche ?
          BNE   GETC_20       ; Non : donc pas de repetition possible.
          LDE   CMPTKB
          CMPE  LATCLV        ; Repeat apres LATCLV*l/10 SEC.
          BLO   GETC_35       ; CMPTKB incremente dans le traitement IRQ.
          TST   AUTRPT
          BNE   GETC_35       ; -> in delay mode
          DEC   AUTRPT        ; set auto repeat flag
          BRA   GETC_25

GETC_20   CLR   CMPTKB        ; Reset du compteur de touches.

GETC_25   STB   KEY           ; B = code numerique.
          JSR   BUZZER        ; key click
          BITA  #%10000       ; bit 4 = BASIC flag
          BNE   GETC_40       ; -> no
          ORB   #$80          ; convert to token
          BRA   EXITB

GETC_30   CLR   KEY           ; no key

GETC_35   CLRB
          BRA   EXITB

GETC_40   LDX   CHRPTR        ; pointer to translation table
          LDB   B,X           ; ASCII code
          BITA  #%00001       ; bit 0 = CONTROL ?
          BNE   GETC_45       ; -> no
          ANDB  #$1F          ; ASCII -> control code
          BRA   EXITB

GETC_45   BITA  #%00010       ; bit 1 = ACC
          BNE   GETC_50       ; -> no
          SUBB  #'1'          ; ACC 1 -> ACC 9
          BMI   GETC_30
          CMPB  #8
          BHI   GETC_30
          LDX   #ACC_CODES
          LDB   B,X
          BRA   EXITB

GETC_50   BITA  #%00100       ; bit 2 = STOP ?
          BNE   GETC_55       ; -> no
          LDB   #3            ; Control C
          BRA   EXITB

GETC_55   BITA  #%01000       ; bit 3 = SHIFT ?
          BNE   ONEKEY        ; normal key
          CMPB  #6            ; CLS
          BNE   GETC_60
          LDB   #FF           ; Shift CLS = clear window

GETC_60   CMPB  #' '
          BLO   EXITB         ; ignore shift for codes < $20
          BNE   GETC_65       ; Shift-sp est le passage maj/min.
          COM   CAPSLK        ; toggle CAPS lock
          CLRB
          BRA   EXITB

GETC_65   CMPB  #'/'          ; * + , - . /
          BGT   SUPA2F        ; : ; < = > ?
          ORB   #$10
          BRA   EXITB

SUPA2F    CMPB  #'0'          ; 0
          BGT   SUPA30        ; `
          LDB   #$60
          BRA   EXITB

SUPA30    CMPB  #'9'          ; 1 2 3 4 5 6 7 8 9
          BGT   SUPA39        ; ! " # $ % & ' ( )
          ANDB  #$EF
          BRA   EXITB         ; C'est peut etre un accent aigu, grave ou trema.

SUPA39    CMPB  #'@'          ; $40 = code de @.
          BNE   EXITB
          LDB   #'^'          ; $5E = code  ^ = shift/@.
          BRA   EXITB

ONEKEY    CMPB  #'A'          ; $41 : code du A.
          BLO   EXITB         ; Si code du zero,c'est peut-etre l'accent grave.
          LDA   CAPSLK        ; test CAPS lock
          BNE   EXITB         ; -> CAPS lock is active
          ADDB  #$20          ; use lower case

EXITB     STB   4,S           ; Resultat dans la pile.
          RTS

*********
ACC_CODES
*********

          FCB   '|'           ; ACC 1
          FCB   '^'           ; ACC 2
          FCB   '~'           ; ACC 3
          FCB   '_'           ; ACC 4
          FCB   '['           ; ACC 5
          FCB   ']'           ; ACC 6
          FCB   '\\'          ; ACC 7
          FCB   '{'           ; ACC 8
          FCB   '}'           ; ACC 9

********************************
* Keycode to ASCII translation *
********************************

TABASC  FCB     $00           ; 00  BASIC
        FCB     $00           ; 01  SHIFT
        FCB     $00           ; 02  STOP
        FCB     $00           ; 03  ACC
        FCB     $00           ; 04  CNT

        FCB     $0D           ; 05  CR
        FCB     $06           ; 06  CLS     cls
        FCB     $43           ; 07  C       console
        FCB     $0B           ; 08  VT UP   cont
        FCB     $5a           ; 09  Z       fre
        FCB     $31           ; 0a  1     ! gr$
        FCB     $2B           ; 0b  +     ; restore
        FCB     $51           ; 0c  Q       attrb
        FCB     $2A           ; 0d  *     : play
        FCB     $41           ; 0e  A       return
        FCB     $56           ; 0f  V       line
        FCB     $08           ; 10  BS LEFT tron
        FCB     $58           ; 11  X       exec
        FCB     $32           ; 12  2     " left$
        FCB     $2D           ; 13  -     = data
        FCB     $57           ; 14  W       locate
        FCB     $2F           ; 15  /     ? print
        FCB     $53           ; 16  S       screen
        FCB     $42           ; 17  B       box
        FCB     $0A           ; 18  LF DOWN skipf
        FCB     $20           ; 19  SP
        FCB     $33           ; 1a  3     # mid$
        FCB     $30           ; 1b  0     ` read
        FCB     $45           ; 1c  E       else
        FCB     $50           ; 1d  P       pset
        FCB     $44           ; 1e  D       delete
        FCB     $40           ; 1f  @       motor
        FCB     $09           ; 20  HT RIGT troff
        FCB     $2e           ; 21  .     ^ poke
        FCB     $34           ; 22  4     $ right$
        FCB     $39           ; 23  9     ) strig
        FCB     $52           ; 24  R       run
        FCB     $4F           ; 25  O       on
        FCB     $46           ; 26  F       for
        FCB     $4C           ; 27  L       list
        FCB     $1E           ; 28  RS      merge
        FCB     $2C           ; 29  ,     > peek
        FCB     $35           ; 2a  5     % input
        FCB     $38           ; 2b  8     ( stick
        FCB     $54           ; 2c  T       to
        FCB     $49           ; 2d  I       if
        FCB     $47           ; 2e  G       go
        FCB     $4B           ; 2f  K       rnd
        FCB     $04           ; 30  INS     load
        FCB     $4D           ; 31  M     < clear
        FCB     $36           ; 32  6     & inpen
        FCB     $37           ; 33  7     ' ptrig
        FCB     $59           ; 34  Y       step
        FCB     $55           ; 35  U       dim
        FCB     $48           ; 36  H       sub
        FCB     $4A           ; 37  J       then
        FCB     $05           ; 38  DEL     save
        FCB     $4E           ; 39  N       next


*****
GETSC
*****

******************************
* Input : A = row    [0..24] *
*         X = column [0..39] *
* Output: B = ASCII code 4,S *
******************************

          LDE   ENACUR        ; save cursor status
          JSR   CURSOF        ; switch cursor off
          BSR   Row_Address   ; D = Row * 320
          ADDR  D,X           ; X = screen address
          LDU   GENPTR        ; normally CHARGEN
          BSR   Match_Cell    ; search character pattern
          STB   4,S           ; store in SWICH stack for B
          STE   ENACUR        ; restore cursor status
          RTS

**********
Match_Cell
**********

*******************************************
* Input : X = screen address of character *
*         U = character generator         *
* Output: B = found ASCII ocde            *
*******************************************

          LDD     #$0820      ; A = 8   B = ' '
MaCe_10   PSHS    X,U,D       ; save input parameter
MaCe_20   PULU    B           ; load next byte from generator
          CMPB    ,X          ; compare with screen byte
          BNE     MaCe_30     ; -> no match
          LEAX    40,X        ; point U to next screen byte
          DECA                ; byte countdown
          BNE     MaCe_20     ; loop
          PULS    PC,X,U,D    ; found code -> B

MaCe_30   PULS    X,U,D       ; restore input parameter
          LEAU    8,U         ; advance to next character
          INCB                ; code to match
          BPL     MaCe_10
          CLRB                ; no match
          RTS

***********
Row_Address
***********

          LDB   #160          ; bytes per line / 2
          LSLA                ; Row * 2
          MUL                 ; D = Row * 320
          RTS

*******
TRAPMON
*******

         LDA     ,S           ; load stacked CC
         ANDA    #$80         ; clear all but E flag
         STA     ,S           ; put back on stack
         TFR     A,CC         ; and use it
         LDA     #DIRECT
         TFR     A,DP
         JMP     Monitor

****************************************************************************
* PLOTXY allume le point passe par X [0,319] et Y [0,199] dans la couleur  *
* donnee par le registre FORME : 15 a 0 pour forme et -16 a -1 pour fond   *
* Registres utilises : PLOTX et PLOTY qui conservent X et Y et le registre *
* FORME.                                                                   *
* DRAWXY trace le vecteur entre le dernier point donne par PLOTX et PLOTY  *
* et X et Y, toujours dans la couleur donnee par le registre FORME.        *
* Les registres temporaires utilises sont DELTAY et TEMP.                  *
* Si le registre CHDRAW # 0, PLOT et DRAW sont en mode caractere et affi-  *
* chent le caractere dont le code ASCII est dans CHDRAW. Dans ce cas,      *
* X = [1,40] et Y = [0,24]                                                 *
****************************************************************************

******
CHPLOT
******

          TFR   X,D
          STB   Col
          TFR   Y,D
          STB   Row
          JSR   Set_Row_Col
          LDB   CHDRAW
          JMP   Display_Char
          SIZE

MASK01  LDB     PLOTX+1
MASQUE  LDU     #TABIT        ; Table des masques dans l'octet physique
MASK02  ANDB    #7            ; B = Reste de X/8
        LDA     B,U           ; A = masque.
        RTS

*******************************************
* STATUT D'UN POINT DANS L'ACCUMULATEUR B *
*******************************************

GETPT   BSR     CALCUL        ; X physique au retour de calcul.
        JSR     Sel_Col_RAM        ; Mise en memoire couleur.
        LDB     7+STOFF,S     ; Contenu de X (colonne) dans B.
        BSR     MASQUE
        LDB     ,X            ; Octet couleur.
        INC     PRA           ; Mise en memoire caractere.
        ANDA    ,X            ; A=0 ==> fond ; A=1 ==> forme.
        BNE     ZER           ; Si A=1 la couleur est dans les bits 4,5,6,7
        ANDB    #$0F          ; Si A=0 la couleur est dans les bits 0,1,2,3
        COMB
        SKIP2                 ; --> fin de traitement.

ZER     BSR     LSRB4
        STB     4,S           ; Mise du resultat dans la pile.
        RTS

*************************************
* ALLUMAGE OU EXTINCTION D'UN POINT *
*************************************

PLOTXY  TST     CHDRAW        ; Si CHDRAW # 0, c'est un point "caractere"
        BNE     CHPLOT        ; Point "caractere" ==> appel a PUTCH.
        STX     PLOTX
        STY     PLOTY
        BSR     CALCUL        ; X = adresse physique au retour.
        BSR     MASK01        ; A = masque du point au retour.

******************************
* AFFICHAGE FORME ET COULEUR *
******************************

* ENTREE : B = BITS A ECRIRE
*          X = ADRESSE PHYSIQUE
*          FORME = COULEUR

FNDFRM  JSR     Sel_Chr_RAM   ; Mise en memoire caractere {reg. sauvegardes)
        LDB     FORME         ; Test de fond ou forme -16 a +15
        BMI     ZERO          ; Fond = bit a mettre a 0.
        BSR     ORAX          ; OR du masoue (A) avec l'octet forme.
        BNE     EXEND         ; PIXMOD != 0 ==> pas d'ecriture de couleur.
        JSR     LSLB4         ; (7,6,5,4) <-- (3,2,1,0): couleur en "forme".
        LDA     #%00001111    ; Masquage de la couleur forme a remplacer.
        BRA     SUITE
ZERO    COMA                  ; Masque complemente pour mettre a 0 le bit.
        BSR     ANDAX         ; Test PIXMOD pour point "rapide".
        BNE     EXEND         ; Test sur PIXMOD fait en fin de GRAX/ANDAX.
        COMB                  ; Couleur de fond complementee a 1 --> 4 LSB.
        LDA     #%11110000    ; Masquage de la couleur fond a remplacer.
SUITE   JSR     Sel_Col_RAM   ; Mise en memoire couleur, ne detruit pas A.
        BSR     ANDAX         ; Mise a 0 des bits de couleur a remplacer.
        ADDB    ,X            ; Nouveaux bits de couleur a leur place.
        STB     ,X            ; Ranges dans l'octet correspondant.
EXEND   RTS

***********************************
* ORAX ET ANDAX POUR OPTIMISATION *
***********************************

ORAX    ORA     ,X            ; X = adresse physique de l'octet contenant le
        SKIP2                 ; pixel a "allumer" ou a "eteindre".
ANDAX   ANDA    ,X
        STA     ,X
        LDA     PIXMOD        ; Dans le cas du 2eme appel a ANDAX, ce test ne
        RTS                   ; Ratour soit dans SWITCH, soit dans CALLPL

LSRD1   LSRA                  ; == LSRD
        RORB
        SKIP2                 ; Pour terminer seulement par 2 LSRB.
LSRB4   LSRB
        LSRB
        LSRB
        LSRB
        RTS

*
***** CALCUL ADRESSE PHYSIQUE *****
*     ENTREE : X= abscisse, Y= ordonnee  -  SORTIE : X = ADRESSE PHYSIQUE
*
        INTERN  CALCUL
CALCUL  EQU     *
        TFR     Y,D           ; B <-- Ylow.
        LDA     #40           ; A <-- 40 (40 bytes par ligne de pixels)
        MUL                   ; D <-- Y * 40
        EXG     D,X           ; D <-- X coord. X <-- Ycoord. * 40
        BSR     LSRD1         ; D <-- X coord. / 8 : 8 pixels par octet
        LEAX    D,X           ; X <-- Ycoord. * 40 + xcoord. / 8
        RTS                   ; X = adresse memoire de l'octet
*
***** TRACE VECTEUR HORIZONTAL RAPIDE *****
*
DRWLIG  EQU     *
        CMPX    PLOTX         ; X >= PLOTX ==> vecteur de gauche a droite.
        BHS     NORMALA
        LDU     PLOTX         ; Inversion : PLOTX --> X
        EXG     X,U           ; X --> PLOTX
        STU     PLOTX
NORMALA EQU     *
        PSHS    X             ; Sauvegarde coordonnees arrivees pour le
        LDD     PLOTX         ; traitement final.
        BSR     LSRD1         ; D = PLOTX/8
        PSHS    B             ; Sauvegarde de PLOTX/8
        LDX     PLOTX         ; X = X0 origine.
        BSR     CALCUL        ; X = X0 adresse physique.
        LDD     1,S           ; D = destination.
        BSR     LSRD1         ; LSRD et deux LSRB = division par 8.
        SUBB    ,S+           ; D = X/8 - PLOTX/8
        BEQ     INBYTE        ; Si D nul, on est dans un octet.
        STB     TEMP+1
        JSR     MASK01
        LSLA                  ; Car U pointait un octet trop loin donc *2.
        DECA                  ; A <-- A-1 car commence a TABIT-1.
AFFICH  EQU     *
        BSR     FNDFRM        ; Appel routine d'affichage des points.
        LEAX    1,X           ; Octet suivant a afficher.
        LDA     #$FF
        DEC     TEMP+1        ; Decrement du compteur d'octets.
        BGT     AFFICH
        BRA     OUTLIG
INBYTE  EQU     *
        JSR     MASK01
        LSLA
        DECA
OUTLIG  EQU     *
        STA     TEMP+1
        LDD     ,S            ; D <-- destination.
        JSR     MASK02
        NEGA
        ANDA    TEMP+1
        JSR     FNDFRM        ; Affichage forme et couleur.
        LDX     10+STOFF,S    ; Pour mettre X destination comme origine par
        STX     PLOTX         ; defaut de la prochaine ligne.
        PULS    A,B,X,PC      ; Remise en etat de la pile et RTS.

*
***** TRACE D'UN VECTEUR [PLOTX,X,PLOTY,Y]
*
        INTERN  DRAWXY
DRAWXY  EQU     *
        LDD     #$0101        ; INCX et INCY mis a +1 par defaut sur la pile
        PSHS    A,B           ; Registres d'increment.
        CLRA
        LDB     11+STOFF,S    ; Y+1 [0-199] = Y low.
        SUBB    PLOTY+1       ; B = Y destination - Y origine
        BHI     D0            ; DELTAY positif.
        BNE     NEGINC        ; DELTAY < 0 ==> -1 --> INCX et INCY.
        TST     CHDRAW        ; Si CHDRAW # 0, pas de trace rapide.
        BEQ     DRWLIG        ; Si DELTAY = 0 et CHDRAW = 0 trace rapide.
NEGINC  EQU     *
        NEG     1,S           ; Increment sur Y = -1 . DeltaY<=O
        NEGB                  ; Delta Y = ABS (Delta Y)
D0      EQU     *
        STD     DELTAY        ; DeltaY positif
        LDD     8+STOFF,S     ; X destination = Xh/Xlow .
        SUBD    PLOTX         ; D = X destination - X origine
        BHS     D1            ; DeltaX positif ou nul.
        NEG     ,S            ; Increment sur X = -1
        BSR     NEGATD        ; Delta X <-- ABS (Delta X)
D1      EQU     *
        STD     DELTAX
        LDX     PLOTX         ; X,Y= points d'origine. Les points d'arrivee sont sur la pile
        LDY     PLOTY
        CMPD    DELTAY        ; D = ABS (Delta X) >? ABS (Delta Y)
        BHI     DRAW1         ; |DELTAX| > |DELTAY| ==> INC/DECX systematique.
        LDD     DELTAY
        BEQ     OUTDRW        ; |DELTAX| <= |DELTAY|, DELTAY nul ==> DELTAX = 0
*
        BSR     NEGATD        ; D <-- -|DELTAY|
        ASRA
        RORB                  ; D <-- (-|DELTAY|) / 2
*
TRACE2  EQU     *
        BSR     CHANGY        ; INC (resp. DEC) Y systematiquement.
        ADDD    DELTAX        ; D <-- N(y) DELTAX - DELTAY/2 -N[x) DELTAY
        BMI     NXTR2         ; 5i D<0 on continue, sinon on fait X=X-/+1
        BSR     CHANGX        ; Modifier X.
        SUBD    DELTAY
NXTR2   EQU     *
        BSR     CALLPL        ; Option grephique : appel a PLOTXY.
        CMPY    10+STOFF,S    ; Y est sur la pile : sortie des que Y = Y destination
        BNE     TRACE2
        PULS    A,B,PC        ; Effacement de INCX,INCY et retour.

DRAW1   EQU     *
        BSR     NEGATD        ; D <-- -|DELTAX|/2
        ASRA                  ; On forme D=-D/2, expression qui, quand elle
        RORB                  ; devient >D, exprime que l'on doit incrementer Y
*
TRACE1  EQU     *
        BSR     CHANGX        ; Modifier X systematiquement.
        ADDD    DELTAY
        BMI     NXTR1         ; X=X-+1 si D<0 on continue, si D>=0 on fait Y=Y-+1
        BSR     CHANGY        ; Modifier Y.
        SUBD    DELTAX
NXTR1   EQU     *
        BSR     CALLPL        ; Appel a PLOTXY
        CMPX    8+STOFF,S     ; X est sur la pile : sortie des que X = X destination
        BNE     TRACE1
OUTDRW  EQU     *
        PULS    A,B,PC        ; Effacement de INCX et INCY

CALLPL  EQU     *
        PSHS    A,B,X,Y,U     ; Sauvegarde des registres detruits par PLOTXY
        JSR     PLOTXY
        PULS    A,B,X,Y,U,PC  ; Restitution des registres et RTS.

CHANGX  EQU     *
        PSHS    A
        LDA     3,S           ; Pile = A/PCh/PCl/INCX/INCY...
        LEAX    A,X           ; INC ou DEC X suivant que INCX vaut + ou - 1.
        PULS    A,PC

CHANGY  EQU     *
        PSHS    A
        LDA     4,S           ; Pile = A/PCh/PCl/INCX/INCY
        LEAY    A,Y           ; INC ou DEC Y suivant que INCY vaut + ou - 1.
        PULS    A,PC

NEGATD  EQU     *
        COMA                  ; D <-- -D
        COMB
        ADDD    #1
        RTS

*
***** TABLE DES BITS A ALLUMER OU ETEINDRE *****
*
        FCB     $00
TABIT   EQU     *
        FCB     $80,$40,$20
        INTERN  OCTTBL
OCTTBL  EQU     *
        FCB     $10,8,4,2,1   ; Sert pour la table d'octaves de MUS (Basic)

***************************************************************
*                    J O Y S T K                              *
*                                                             *
*    Objet: primitive de traitement des joysticks             *
*    Parametres entree: A=numero du joystick [0,1]            *
*    Resultats joystick: dans B de 0 (etat neutre) a 8 dans   *
*    le sens des aiguilles d'une montre.                      *
*    1=N, 2=NE, 3=E, 4=SE, 5=S, 6=SW, 7=W, 8=NW               *
*    Resultat  joystk  : dans CY =0 gachette au repos         *
*                             ; =l gachette enfoncee         *
*    L'extension joystick est branchee sur un 6821 :          *
*          joystick 0                   joystick 1            *
*     BITS 0,1,2,3 PORT A     -    BITS 4,5,6,7 PORT A        *
*     TRIGGER : BIT6 PORT B   -    TRIGGER : BIT 7 PORT B     *
*     EXTENSION IT : CA1      -    EXTENSION IT : CA2         *
***************************************************************

JOYSTK  EQU     *
        LDB     PRA1-PRA,U    ; Port joystick
        TSTA                  ; 0 = joystick 0, 1 = joystick 1
        BEQ     SUIT10        ; No 0
        LDA     #$40          ; No 1
        LSRB
        LSRB
        LSRB
        LSRB                  ; BITS 7,6,5,4 --> 3,2,1,0
SUIT10  EQU     *
        ANDB    #$0F
        LDX     #TABJOY-5     ; La valeur minimum contenue dans B est 5.
        LDB     B,X           ; B contient la lecture du joystick
        STB     4,S           ; Sauvegarde dans la pile pour le RTI final
        ADDA    #$40          ; A=$80 si joystick 1, $40 sinon.
        ANDA    PRB1-PRA,U    ; Test du bit 7 ou 6 du port B (Trigger)
        CMPA    #1            ; Si A=0 on positionne la cari(gachette enfoncee)
        RTS                   ; sinon elle reste a zero.


***** TABLE DE CORRESPONDANCE DES VALEURS POSITIONNELLES
* 0=N, 1=S, 2=W, 3=E

TABJOY  FCB     4,2,3,0,6,8,7,0,5,1,0

SWI1SB  JMP     [SWI1PT]      ; default: [SWI1PT] = SWITCH
FIRQSB  JMP     [FIRQPT]      ; default: [FIRQPT] = RTIPNT


******
IRQSUB
******

        LDB     #DIRECT
        TFR     B,DP
        LDU     #PRA
        LDA     CRB-PRA,U     ; control register B 6821.
        BMI     IRQS_10       ; timer event
        JMP     [IRQPT]       ; user IRQ

IRQS_10 LDD     CLOCK+1       ; load jiffy clock
        INCD                  ; increment low  word
        STD     CLOCK+1
        BNE     IRQS_20
        INC     CLOCK         ; increment MSB

IRQS_20 ANDB    #3            ; auto repeat frequency
        BNE     IRQS_50       ; -> not yet
        TST     KEY           ; test autorepeat flag
        BEQ     IRQS_40       ; -> continue with cursor routine
        LDA     CMPTKB
        CMPA    LATCLV
        BEQ     IRQS_30
        INC     CMPTKB

IRQS_30 CLR     AUTRPT        ; On remet a zero le semaphore d'autorepeat

IRQS_40 LDA     CLOCK+2       ; lowest byte of clock
        ANDA    #31           ; cursor blink frequency
        BNE     IRQS_50
        TST     ENACUR        ; Test curseur on/off
        BEQ     IRQS_50       ; 0 ==> curseur off.
        LDB     ,U            ; U pointe sur PRA.
        JSR     Flip_Cursor   ; Inversion curseur et compteur d'inversions.
        STB     ,U            ; Restitution memoire caractere ou couleur.

IRQS_50 LDA     PRB-PRA,U     ; Reset de IRQB.
        TST     TIMEPT+2      ; Test du flag de TIMEPT (deroutement si #0)
        BEQ     IRQ_RTI
        JMP     [TIMEPT]      ; Deroutage interrupt timer.

IRQ_RTI RTI                   ; 6 us. Total : 46 us. < 64 us.
        SIZE


*************************************************************************
* Programme de generation de musique : la note a jouer est passee par   *
* l'accumulateur B. Elle est executee en fonction des parametres :      *
*    OCTAVE : nombre de fois qu'il faut repeter la 1/2 periode fonda-   *
*             mentale donnee par B                                      *
*    DUREE  : nombre de fois que l'on repete le diviseur de temps (255) *
*             avant de modifier le rapport cyclique (attaque)           *
*    TEMPO  : multiplicateur de duree - la duree relle est egale a      *
*             TEMPO * DUREE                                             *
*    TIMBPE : norbre indiquant la deviation (en + et en - sur les deux  *
*             1/2 periodes) du rapport cyclique, chaque fois que duree  *
*             est ecoulee.                                              *
* Les registres utilises sont :                                         *
*    TEMPO, DUREE,  MUSFLG (indique que le diviseur est passe par 0)    *
*    TIMBRE, OCTAVE                                                     *
*************************************************************************

PULSEC  EQU     DELTAY
DIVISR  EQU     DELTAY+1
PULSE0  EQU     TEMP
PULSE1  EQU     TEMP+1

NOTE    ORCC    #%11010000    ; Protection contre les interruptions
        LDA     DUREE+1       ; Duree et Tempo: seuls les 8 LSB de ces
        LDB     TEMPO+1       ; Registres sur 16 bits sont significatifs.
        PSHS    A             ; Pour ralentir la musique qui va plus vite
        LSRA                  ; sur MO5 que sur TO7, et qui doit fonctionner
        LSRA                  ; avec les memes parametres, on ajoute a la duree
        ADDA    ,S+           ; une valeur proportionnelle (DUREE/4).
        MUL                   ; Duree totale = tempo * duree * 5/4 -->
        TFR     D,Y           ; Y servira de compteur de la duree totale.
        LDB     4,S           ; Recuperation de B detruit par le "MUL".
        ANDB    #$0F          ; On ne conserve que les 4 LSB qui servent
        BEQ     OCTBAS        ; Cas du silence.
        LDX     #TABNOT-1     ; Table des frequences. B qui est non nul sert
        LDB     B,X           ; d'offset dans la table des frequences.

* Correction pour l'octave superieure

        LDA     OCTAVE+1      ; Octave vaut 1 pour la derniere fois
        DECA
        BNE     OCTBAS        ; Ce n'est pas le cas
        SUBB    #2            ; Retire 2 pour la derniere octave

OCTBAS  TFR     B,A           ; B sert au 1/2 PULSE "1" et A au 1/2 PULSE "0"

NOTE1   STD     PULSE0
        BEQ     NOTE0         ; Silence.
        LDX     OCTAVE        ; On repositionne la valeur de l'octave.

AGAIN1  LDB     PRB-PRA,U     ; U pointe sur PRA
        ORB     #$01          ; Bit0 de PRB = son force a 1.
        STB     PRB-PRA,U
        LDB     PULSE1        ; On passe la duree du 1 a PLAY.
        BSR     PLAY          ; Jouer le 1 ( lere partie du pulse )
        LEAX    -1,X          ; Decrement de l'octave qui a ete chargee dans X.
        BNE     AGAIN1        ; Tant que octave non finie, on rejoue le 1.

NOTE0   LDX     OCTAVE        ; On repositionne la valeur de l'octave.

AGAIN0  LDB     PRB-PRA,U     ; U pointe sur PRA
        ANDB    #$FE          ; Bit0 de PRB : son force a 1.
        STB     PRB-PRA,U
        LDB     PULSE0
        BSR     PLAY          ; Jouer le 0 ( 2eme partie du pulse )
        LEAX    -1,X          ; Decrement de l'octave qui a ete chargee dans X.
        BNE     AGAIN0        ; Tant que octave non finie, on rejoue le 0.

        LDD     PULSE0        ; Fin de pulse, changement d'attaque ?
        ADDA    TIMBRE        ; La valeur du 0 augmente de timbre,
        BCS     NOTE0
        SUBB    TIMBRE        ; et celle du 1 diminue d'autant.
        BHI     NOTE1         ; Continue tant que la duree n'est pas nulle
        BRA     NOTE0         ; Pulse 1 negatif, on reste a zero.

PLAY    STB     PULSEC        ; 1/2 PULSE a jouer

LOOP01  DECB                  ; Decrement de la note.
        BNE     LOOP01        ; Boucle la plus interne
        LDB     PULSEC        ; Diviseur de temps (init. arbitraire).
        BEQ     SILENT
        ADDB    DIVISR        ; Ce diviseur est incremente par pas de "B"
        CMPB    DIVISR        ; Le diviseur a-t-il fait un tour? (passe $FF).
        STB     DIVISR        ; Sauvegarde du diviseur.
        BHS     EXPLAY        ; Non ==> on ne touche ni a duree, ni a tempo.

SILENT  LEAY    -1,Y          ; Decrement du compteur de duree totale, qui
        BEQ     EXNOTE        ; est independant de la note et de 1'octave.

EXPLAY  RTS                   ; Retour de PLAY: revient dans NOTE0 ou NOTE1

EXNOTE  PULS    D,PC          ; Four depiler l'adresse de retour de PLAY et RTS


***************************************************
* TABLE DES FREQUENCES DE L'OCTAVE SUPERIEURE (4) *
***************************************************

TABNOT  FCB     $B0
        FCB     $A5
        FCB     $9C
        FCB     $92
        FCB     $89
        FCB     $81
        FCB     $78
        FCB     $71
        FCB     $6A
        FCB     $63
        FCB     $5D
        FCB     $57
        FCB     $51


        FILL   $f54e-* (0)
DCMOTO_D FCB    $11,$ff,$39   ; gestion interface

***************************************************************
* PUTCH is the text control routine of the screen.            *
* The input parameter is passed by the accumulator B.         *
*                                                             *
* SCRPT  : cursor address in RAM                              *
* Row    : cursor row                [0,24]                   *
* Col    : cursor column             [0,39]                   *
* Win_Top: top row of window                                  *
* Win_Bot: bottom row of window                               *
* USERAF : pointer to character generator                     *
* COLOUR : current colour fg=[bit 7..4] bf=[bit 3..0]         *
* ENACUR : visible cursor                                     *
* TEMP   : registre de travail temporaire                     *
***************************************************************

*****
PUTCH
*****
                ; EFHINZVC    ; disable interrupts
          ORCC  #%11010000    ; set flags E F I
          JSR   Sel_Chr_RAM   ; select character memory
          JSR   Erase_Cursor
          LDA   SEQUCE        ; inside sequence ?
          BNE   Do_Seq        ; handle it
          CMPB  #' '          ; displayable ?
          LBHS  Display_Char
          LSLB                ; B *= 2
          LDX   #TABDEC       ; TABDEC = action table
          JMP   [B,X]         ; codes interpretables.

******
Do_Seq
******

* Input : A = sequence marker
*       : B = actual parameter

          CMPA  #ESC
          BEQ   ESC_SEQ       ; ESC <p><q>
          CMPA  #US
          BEQ   US_SEQ        ; US  <p><q>
          DEC   SEQUCE
          LBEQ  Display_Char  ; final char of SS2 sequence
          LDA   #1
          STA   SEQUCE
DoSe_Ret  RTS

*******
ESC_SEQ
*******

          CMPB  #$20          ; full window attribute
          BNE   ESC_10
ESC_US    STB   SEQUCE+1      ; remember
          RTS                 ; action starts at next char

ESC_10    CMPB  #$40
          BLO   ESC_Ex
          CMPB  #$50
          BHS   ESC_20
          LSLB
          LSLB
          LSLB
          LSLB
          LDA   #$0f
          LDW   #$f00f        ; foreground mask
          BRA   ESC_30

ESC_20    CMPB  #$60
          BHS   ESC_40
          ANDB  #$0f
          LDA   #$f0
          LDW   #$0ff0        ; background mask

ESC_30    ANDA  COLOUR
          ORR   B,A
          STA   COLOUR
          TST   SEQUCE+1
          BEQ   ESC_Ex
          JSR   Set_Win_Colour
          BRA   ESC_Ex


ESC_40    CMPB  #$70
          BHS   ESC_50
          ANDB  #$0f
          LSLB                ; prepare for PRA
          LDA   PRA
          ANDA  #%11100001
          ORR   B,A
          STA   PRA
          BRA   ESC_Ex

ESC_50    CMPB  #$7b          ; inverse colour
          BNE   ESC_Ex
          LDA   COLOUR
          TFR   A,B
          LSLA
          LSLA
          LSLA
          LSLA
          LSRB
          LSRB
          LSRB
          LSRB
          ORR   B,A
          STA   COLOUR

ESC_Ex    CLR   SEQUCE
          CLR   SEQUCE+1
          RTS

******
US_SEQ
******

          TST   SEQUCE+1
          BEQ   ESC_US
          CMPB  #$40
          BLT   ESC_Ex
          ANDB  #$3f          ; Col
          DECB                ; 0 - 39
          STB   Col
          LDA   SEQUCE+1
          ANDA  #$3f          ; Row
          JSR   Set_Row_A
          BRA   ESC_Ex

************
Display_Char
************

          TSTB                ; Test caractere utilisateur ou non.
          BPL   DiCh_10       ; B <= $7F ==> caractere standard.
          LDU   USERAF        ; Pointe sur le generateur de car. utilisateur.
          SUBB  #$80          ; Pour se ramener entre 0 et $7F dans la table.
          BRA   DiCh_20

DiCh_10   LDU   GENPTR        ; Pointe sur le generateur de caracteres standard.
          SUBB  #' '

DiCh_20   LDA   #8            ; Calcul de l'offset dans la table : 8 octets
          MUL                 ; par caractere, donc on multiplie par 8
          LEAU  D,U           ; D pointe sur le 1er octet du caractere.
          LDX   SCRPT         ; Pointeur d'ecran courant.
          LDB   COLOUR        ; use current colour
          LDE   #8            ; 8 scanlines for standard character

DiCh_30   PULU  A             ; load  byte from character generator
          DEC   PRA           ; colour RAM
          STB   ,X
          INC   PRA           ; character RAM
          STA   ,X            ; store byte to   character RAM
          LEAX  40,X          ; move X to next scan line above
          DECE                ; scan line count down
          BNE   DiCh_30       ; loop

********
CU_RIGHT
********

          INC   Col
          LDA   Col
          CMPA  #RIMA
          BHS   CURI_10
          INC   SCRPT+1
          RTS

CURI_10   CLR   Col
          LDA   #$ff
          STA   [Wpt_Row]     ; link row

*******
CU_DOWN
*******

          INC   Row
          LDA   Row
          CMPA  Win_Bot
          BLS   CUDO_10
          JSR   Scroll_Up
          LDA   Win_Bot
CUDO_10   JMP   Set_Row_A

*******
CU_LEFT
*******

          LDA   Col
          BNE   CULE_10       ; -> not on left margin
          LDA   Win_Top
          CMPA  Row
          BHS   CUUP_20       ; -> on top row
          LDB   #RIMA-1       ; 39 = right margin
          STB   Col           ; wrap
          BRA   CUUP_10
CULE_10   DEC   SCRPT+1       ; Colonne precedente, deplacement a gauche
          DEC   Col           ; de SCRPT.
CULE_Ret  RTS

*****
CU_UP
*****

          LDA   Win_Top
          CMPA  Row
          BHS   CUUP_20       ; set to top row
CUUP_10   DEC   Row
          JMP   Set_Row_Col
CUUP_20   JMP   Set_Row_A


*********
Erase_EOL
*********

          CLR   [Wpt_Row]     ; unlink row
          LDD   #RIMA
          SUBB  Col           ; D = length
          LDY   SCRPT
          LDX   #BLOCZ
          JSR   Fill_Block
          LDX   #COLOUR
          JMP   Fill_Block


******
CURSOF
******

          BSR     Erase_Cursor        ; Extinction curseur.
          CLR     ENACUR
P_EXIT    RTS


**********
SWI_CURSON
**********

* *************************************
* Call this routine ONLY via SWI      *
* because it modifies a stacked value *
* *************************************

        LDA     2,S           ; get stacked CC
        ANDA    #%11101111    ; enable IRQ
        STA     2,S           ; put back on stack
        LDA     #$ff
        STA     ENACUR
        RTS


************
Erase_Cursor
************

        TST     ENACUR
        BEQ     FC_Ret
        TST     EFCMPT        ; Nombre pair de complements curseur ?
        BEQ     FC_Ret        ; Si oui rien de special a faire.

***********
Flip_Cursor
***********

        PSHS    B,X
        OIM     #1,PRA        ; character RAM
        LDX     SCRPT
        LDB     #8

FC_10   COM     ,X
        LEAX    40,X
        DECB
        BNE     FC_10
        COM     EFCMPT        ; inverse flag
        PULS    B,X
FC_Ret  RTS


******
CARRET
******

          BSR   Erase_Cursor
          CLR   [Wpt_Row]
          CLR   Col
          JMP   Set_Row_Col

********
Win_Home
********

          BSR   Erase_Cursor
          CLR   Col           ; Point d'entree en venant de Form Feed,
          LDA   Win_Top       ; Sinon, pas de scroll, Row prend la valeur
OUTHT     JMP   Set_Row_A

*********
COPY_CHAR
*********

          PSHS  D
          LDB   #8
COCH_10   LDA   ,X
          STA   ,Y
          DEC   PRA           ; colour RAM
          LDA   ,X
          STA   ,Y
          INC   PRA           ; character RAM
          LEAX  40,X
          LEAY  40,Y
          DECB
          BNE   COCH_10
          PULS  PC,D

          FILL $f719-* (0)
DCMOTO_E  FCB   $11,$fa,$39

*********
Scroll_Up
*********

          LDB   Win_Top       ; top row

***********
Scroll_Up_B
***********

          LDA   #DIRECT
          TFR   D,X           ; X = row terminator
          LSLB
          LDA   #160
          MUL
          TFR   D,Y           ; Y = row screen address

          CMPX  Wpt_Bot
          BEQ   ScUp_20       ; one row window

ScUp_10   LDA   1,X
          STA   ,X+
          CMPX  Wpt_Bot
          BLO   ScUp_10

ScUp_20   CLR   ,X            ; unlink bottom row
          LDD   #BLOCZ        ; fill address for character
          LDX   #COLOUR       ; fill address for colour
          PSHS  D,X           ; for two loop iterations

* Scroll window

ScUp_30   BSR   Win_Bot_Adr
          TFR   D,W
          TFR   Y,X           ; X = target = row 0
          SUBR  Y,W           ; W = byte count
          BEQ   ScUp_40       ; one row only
          TFR   Y,D
          ADDD  #320          ; D = source = row 1
          TFM   D+,X+         ; scroll

* Erase last line

ScUp_40   PULS  D             ; pointer to fill byte
          LDW   #320          ; one row
          TFM   D,X+          ; fill with zeroes

          EIM   #1,PRA        ; toggle char/colour
          CMPB  #<BLOCZ       ; filled with zero ?
          BEQ   ScUp_30       ; loop for colour

ScUp_Ret  RTS


**********
Delete_Row
**********

          LDB   Row
          BRA   Scroll_Up_B

************
Clear_Window
************

          LDX   Wpt_Top       ; clear terminator table
ClWi_10   CLR   ,X+
          CMPX  Wpt_Bot
          BLS   ClWi_10
          BSR   Win_Top_Adr
          TFR   D,Y           ; Y = target = top row
          BSR   Win_Bot_Adr
          ADDD  #320
          SUBR  Y,D           ; D = byte count
          LDX   #BLOCZ        ; fill address for character
          BSR   Fill_Block   ; character
          LDX   #COLOUR       ; fill address for colour
          BSR   Fill_Block   ; colour
          JMP   Win_Home
          SIZE

**********
Fill_Block
**********

          PSHS  D,Y
          TFR   D,W
          TFM   X,Y+
          EIM   #1,PRA        ; toggle char/colour
          PULS  PC,D,Y

***********
Win_Top_Adr
***********

          LDB   Win_Top
          LSLB
          LDA   #160
          MUL
          RTS

***********
Win_Bot_Adr
***********

          LDB   Win_Bot
          LSLB
          LDA   #160
          MUL
          RTS

***********
Scroll_Down
***********

          BSR   Win_Top_Adr
          TFR   D,Y           ; Y = address of top row
          LDW   Wpt_Top       ; W = address of top terminator

**************
Scroll_Down_WY
**************

          LDX   Wpt_Bot       ; address of last row
          CMPR  W,X
          BEQ   ScDo_20       ; one row window

ScDo_10   LDA   ,-X
          STA   1,X
          CMPR  W,X
          BHI   ScDo_10

ScDo_20   CLR   ,X            ; unlink top row
          LDD   #BLOCZ        ; fill address for character
          LDX   #COLOUR       ; fill address for colour
          PSHS  D,X           ; for two loop iterations

* Scroll window

ScDo_30   BSR   Win_Bot_Adr   ; last row
          TFR   D,X
          TFR   D,W
          DECD                ; D = source
          LEAX  319,X         ; X = target
          SUBR  Y,W           ; W = count
          BEQ   ScDo_40       ; W = 0 -> nothing to scroll
          TFM   D-,X-         ; scroll

* Erase top line

ScDo_40   PULS  D             ; pointer to fill byte
          LDW   #320          ; one row
          TFR   Y,X           ; address of top row
          TFM   D,X+          ; fill with zeroes

          EIM   #1,PRA        ; toggle char/colour
          CMPB  #<BLOCZ       ; filled with zero ?
          BEQ   ScDo_30       ; 2nd. for colour RAM
ScDo_Ret  RTS

**********
Insert_Row
**********

          LDB   Row

************
Insert_Row_B
************

          LDA   #DIRECT
          TFR   D,W           ; address of top terminator
          LSLB                ; row  * 2
          LDA   #160          ; size / 2
          MUL                 ; D = screen address of row
          TFR   D,Y
          BRA   Scroll_Down_WY

**********
Delete_Chr
**********

          CLR   EFCMPT
          LDY   SCRPT         ; screen address
          LDD   Row           ; A = Row, B = Col
          LDW   #RIMA-1
          SUBR  B,F           ; 39 - Col
          BEQ   DeCh_20       ; -> on right margin

DeCh_10   BSR   Scroll_Left   ; character
          BSR   Scroll_Left   ; colour

DeCh_20   ADDR  W,Y           ; right margin
          LDX   #TERMIN
          TST   A,X
          BEQ   DeCh_30       ; -> unlinked row

          LEAX  281,Y         ; +320 -39
          JSR   COPY_CHAR     ; wrap
          INCA                ; Row++
          LDW   #RIMA-1
          LEAY  -39,Y         ; -320 +320 -39
          BRA   DeCh_10

DeCh_30   BSR   Insert_Blank

          LEAX  -359,Y        ; -320 -39
          LDB   #160          ; check 160 words

DeCh_40   LDY   ,X++
          BNE   DeCh_Ret
          DECB
          BNE   DeCh_40
          DECA
          BMI   DeCh_Ret      ; already on top row
          LDX   #TERMIN       ; unlink previous row
          CLR   A,X           ; if this row is blank

DeCh_Ret  RTS

***********
Scroll_Left
***********

*******************************
* Scroll Row Left             *
*******************************
* Input : W = # of cells      *
*       : Y = start of target *
* Usage : B,X                 *
*******************************

          LDB   #8            ; scroll 8 scan lines
ScLe_10   PSHS  Y             ; save target start
          PSHSW               ; save width
          LEAX  1,Y           ; source start
          TFM   X+,Y+         ; scroll one scan line
          PULSW               ; restore width
          PULS  Y             ; restore target start
          LEAY  40,Y          ; nextscan line
          DECB                ; count down
          BNE   ScLe_10       ; loop
          LEAY  -320,Y        ; restore to entry value
          EIM   #1,PRA        ; toggle RAM
          RTS


************
Insert_Blank
************

          PSHS  D
          LDA   COLOUR
          LDB   #8
InBl_10   CLR   ,Y
          DEC   PRA           ; colour RAM
          STA   ,Y
          INC   PRA           ; character RAM
          LEAY  40,Y
          DECB
          BNE   InBl_10
          PULS  PC,D


**********
Insert_Chr
**********

          CLR   EFCMPT        ; clear cursor flag
          LDW   Row           ; W = insert position
          JSR   Find_LNB      ; D = end
          CMPB  #RIMA-1       ; right margin ?
          BLO   InCh_20       ; -> normal
          CMPA  Win_Bot       ; at bottom row ?
          BNE   InCh_10       ; -> insert line
          JSR   Find_SOL      ; Start of line
          CMPA  Win_Top       ; top row ?
          BEQ   InCh_Ret      ; -> locked: give up

          JSR   Scroll_Up     ; scroll whole window up
          DEC   Row           ; create empty bottom row
          JSR   Set_Row_Col   ; adjust cursor position
          BRA   Insert_Chr    ; and try again

InCh_10   LDX   #TERMIN       ; if row after LNB is linked
          TST   A,X           ; scrolling can continue
          BNE   InCh_20       ; no insertion needed

          PSHS  D,X           ; a new row is needed
          PSHSW
          TFR   A,B
          INCB                ; new row #
          JSR   Insert_Row_B  ; insert an empty row
          PULSW
          PULS  D,X
          CLR   A,X
          DEC   A,X           ; link to inserted row
          INCA                ; A = new last row

InCh_20   LDW   #RIMA-1       ; W = 39
          CMPA  Row
          BNE   InCh_30
          SUBF  Col           ; W = 39 - Col

InCh_30   PSHS  A
          JSR   Row_Address   ; D = start of row
          ADDB  #RIMA-1       ; D = end   of row
          TFR   D,Y
          PULS  A
          BSR   Scroll_Right  ; character
          BSR   Scroll_Right  ; colour
          SUBR  W,Y           ; insert position
          CMPA  Row
          BEQ   Insert_Blank

          LEAX  -281,Y        ; -320 + 39
          JSR   COPY_CHAR
          DECA
          BRA   InCh_20
InCh_Ret  RTS

************
Scroll_Right
************

*******************************
*      Scroll Row Right       *
*******************************
* Input : W = # of cells      *
*       : Y = start of target *
* Usage : B,X                 *
*******************************

          LDB   #8            ; scroll 8 scan lines
ScRi_10   PSHS  Y             ; save target start
          PSHSW               ; save width
          LEAX  -1,Y          ; source start
          TFM   X-,Y-         ; scroll one scan line
          PULSW               ; restore width
          PULS  Y             ; restore target start
          LEAY  40,Y          ; nextscan line
          DECB                ; count down
          BNE   ScRi_10       ; loop
          LEAY  -320,Y        ; restore to entry value
          EIM   #1,PRA        ; toggle RAM
          RTS

******
BUZZER
******

          PSHS  D
          TST   DISBUZ        ; buzzer enabled ?
          BNE   EXBUZZ        ; Si inhibe, on saute le buzzer.
          CLRA
BEEP      STA   PRB
          INCA
          CLRB
WTBEEP    INCB
          BPL   WTBEEP
          CMPA  #17           ; ll Msec
          BNE   BEEP
EXBUZZ    PULS  PC,D


***********
Sel_Chr_RAM
***********

        OIM     #1,PRA
        RTS

***********
Sel_Col_RAM
***********

        AIM     #$fe,PRA
        RTS

LSLB4   LSLB                  ; Routine separee pour optimisation.
        LSLB
        LSLB
        LSLB
        RTS

**********
Set_Win_BG
**********

          LDW   #$0ff0
          BRA   Set_Win_Colour

**********
Set_Win_FG
**********

          LDW   #$f00f

**************
Set_Win_Colour
**************

          BSR   Sel_Col_RAM
          JSR   Win_Top_Adr
          TFR   D,X
          JSR   Win_Bot_Adr
          TFR   D,Y
          LEAY  320,Y
          LDB   COLOUR
          ANDR  E,B

SWCO_10   LDA   ,X
          ANDR  F,A
          ORR   B,A
          STA   ,X+
          CMPR  Y,X
          BLT   SWCO_10
          RTS

***********
Set_Row_Col
***********

          LDA   Row

*********
Set_Row_A
*********

          STA   Row
          JSR   Row_Address
          ADDB  Col
          STD   SCRPT
          RTS


TABDEC    FDB   P_EXIT        ; $00 NUL  Ctrl @
          FDB   P_EXIT        ; $01 SOH  Ctrl A
          FDB   Set_Win_BG    ; $02 SOX  Ctrl B
          FDB   Set_Win_FG    ; $03 ETX  Ctrl C
          FDB   Insert_Chr    ; $04 EOT  Ctrl D
          FDB   Delete_Chr    ; $05 ENQ  Ctrl E
          FDB   Win_Home      ; $06 ACK  Ctrl F
          FDB   BUZZER        ; $07 BELL Ctrl G
          FDB   CU_LEFT       ; $08 BS   Ctrl H
          FDB   CU_RIGHT      ; $09 HT   Ctrl I
          FDB   CU_DOWN       ; $0a LF   Ctrl J
          FDB   CU_UP         ; $0b VT   Ctrl K
          FDB   Clear_Window  ; $0c FF   Ctrl L
          FDB   CARRET        ; $0d CR   Ctrl M
          FDB   Insert_Row    ; $0e SO   Ctrl N
          FDB   P_EXIT        ; $0f SI   Ctrl O
          FDB   P_EXIT        ; $10 DLE  Ctrl P
          FDB   SWI_CURSON    ; $11 DC1  Ctrl Q
          FDB   P_EXIT        ; $12 DC2  Ctrl R
          FDB   P_EXIT        ; $13 DC3  Ctrl S
          FDB   CURSOF        ; $14 DC4  Ctrl T
          FDB   P_EXIT        ; $15 NAK  Ctrl U
          FDB   Start_Seq     ; $16 SYN  Ctrl V
          FDB   Scroll_Down   ; $17 ETB  Ctrl W
          FDB   Erase_EOL     ; $18 CAN  Ctrl X
          FDB   Delete_Row    ; $19 EM   Ctrl Y
          FDB   Scroll_Up     ; $1a SUB  Ctrl Z
          FDB   Start_Seq     ; $1b ESC  Ctrl [
          FDB   P_EXIT        ; $1c FS   Ctrl \
          FDB   P_EXIT        ; $1d GS   Ctrl ]
          FDB   P_EXIT        ; $1e RS
          FDB   Start_Seq     ; $1f US

*********
Start_Seq
*********

          LSRB                ; restore escape code
          STB   SEQUCE        ; mark sequence start
          RTS

*****************************************
* Machine Language Monitor for 6309 CPU *
*****************************************

Msg_Mon   FCB   "  PC DPCC A B E F   X   Y   U   S   V\r\n;",0
Reg_Col   FCB   $70,$70,$10,$30,$70,$70,$60,$60
          FCB   $70,$70,$60,$60,$70,$70,$60,$60
          FCB   $80,$80

************
Mon_Commands
************

          FCB   ':',Mon_Modify_Memory
          FCB   ';',Mon_Modify_Register
          FCB   'G',Mon_Go
          FCB   'M',Mon_Show_Memory
          FCB   'R',Mon_Show_Register
          FCB   'X',Mon_Exit
          FCB    0

********
Mon_Text
********
          LDB   ,X+
Mont_10   CALL  PUTC
          LDB   ,X+
          BNE   Mont_10
          RTS

LPINT     ANDCC   #$fe        ; clear carry (no ligt pen)
          RTS

******
Mon_Go
******

          LDX   #BUF_TXT+2
          LDW   MON_PC        ; preset
          JSR   Mon_Get_Word
          LDS   MON_S         ; S
          STW   10+STOFF,S    ; PC
          LDA   MON_CC
          STA   ,S            ; CC
          LDQ   MON_A         ; A,B,E,F
          STQ   1,S           ; D
          LDA   MON_DP
          STA   3+STOFF,S     ; DP
          LDQ   MON_X
          STQ   4+STOFF,S     ; X,Y
          LDD   MON_U
          STD   8+STOFF,S     ; U
          LDD   MON_V         ; V
          TFR   D,V
          RTI

*******
Monitor
*******

          LDD   10+STOFF,S    ; PC
          STD   MON_PC
          LDD   1,S           ; D
          STQ   MON_A         ; A,B,E,F
          LDQ   4+STOFF,S     ; X,Y
          STQ   MON_X
          LDD   8+STOFF,S     ; U
          STD   MON_U
          STS   MON_S         ; S
          TFR   V,D
          STD   MON_V
          LDA   3+STOFF,S     ; DP
          LDB   ,S            ; CC
          STD   MON_DP
          CLR   CHANNEL       ; input from screen
          JSR   Mon_Show_Register

*********
Main_Loop
*********

          LDD   #$7021        ; A = $70, B = $21
          STA   COLOUR
          PSHS  DP
          TFR   B,DP          ; BASIC DP
          JSR   Edit_Get_Line
          PULS  DP

          LDX   #Mon_Commands
          LDA   BUF_TXT+1     ; command
          CMPA  #'a'
          BLO   Moni_20
          ANDA  #%1101 1111   ; force upper case

Moni_20   LDB   ,X+           ; command char
          BEQ   Moni_30       ; not in list
          LDU   ,X++          ; command subroutine
          CMPR  A,B
          BNE   Moni_20       ; next
          LDX   #BUF_TXT+2
          JSR   ,U
          BRA   Main_Loop

Moni_30   JSR   Mon_CRLF
          LDB   #'?'
          CALL  PUTC
          LDB   #BS
          CALL  PUTC
          BRA   Main_Loop


***************
Mon_Show_Memory
***************

          LDW   MON_MEM       ; preset
          BSR   Mon_Get_Word
          PSHSW
          ADDW  #63           ; preset
          BSR   Mon_Get_Word
          PULS  X             ; X = start address
          TFR   W,Y           ; Y = last  address
          CMPR  X,Y
          BHS   MoSM_10
          LEAY  63,Y          ; default

MoSM_10   JSR   Mon_Dump_Row
          CALL  KTST
          ANDA  #%00100       ; STOP key
          BEQ   MoSM_20
          CMPR  X,Y
          BHS   MoSM_10
MoSM_20   STX   MON_MEM       ; remember last used
          RTS

*****************
Mon_Modify_Memory
*****************

          BSR   Mon_Get_Word
          TFR   W,Y           ; Y = start address
          LDB   #8
MoMM_10   BSR   Mon_Get_Byte
          STA   ,Y+
          DECB
          BNE   MoMM_10
          RTS

*******************
Mon_Modify_Register
*******************

          LDY   #MONBUF
MoMR_10   BSR   Mon_Get_Byte
          STA   ,Y+
          CMPY  #MONBUF+18
          BLO   MoMR_10
          RTS

*****************
Mon_Show_Register
*****************

          LDX   #Msg_Mon
          JSR   Mon_Text

          LDX   #MONBUF
          LDU   #Reg_Col
MoSR_10   PULU  B
          STB   COLOUR
          LDB   ,X+
          JSR   Mon_Show_Byte
          CMPX  #MONBUF+18
          BLO   MoSR_10
#if NATIVE
          LDB   #'*'
          CALL  PUTC
#endif
          JMP   Mon_CRLF

********
Mon_Exit
********

          LDS   SP_DEF
          LDB   #$21
          TFR   B,DP
          JMP   Main

************
Mon_Get_Word
************

* Input : X = buffer pointer
*       : W = preset value
* Output: W = word
* Skip leading blank or minus

          LDA   ,X
          CMPA  #' '          ; leading blank ?
          BLO   MoGW_Ret
          BEQ   MoGW_10
          CMPA  #'-'          ; - separator ?
          BNE   MoGW_20
MoGW_10   LEAX  1,X

MoGW_20   BSR   Mon_Get_Byte
          TFR   A,E
          BSR   Mon_Get_Byte
          TFR   A,F
MoGW_Ret  RTS

************
Mon_Get_Byte
************

****************************************
* Input :  X = pointer to input buffer *
* Output:  A = byte value              *
****************************************

          PSHS  B
          LDB   ,X
          CMPB  #' '
          BNE   MoGB_10
          LEAX  1,X
MoGB_10   BSR   Mon_Get_Nibble
          TFR   B,A
          LSLA
          LSLA
          LSLA
          LSLA
          BSR   Mon_Get_Nibble
          ORR   B,A
          PULS  PC,B

**************
Mon_Get_Nibble
**************

*****************************************
* Input : X = pointer to next hex digit *
* Output: B = nibble value              *
*****************************************

          LDB   ,X+
          CMPB  #'9'+1
          BLO   MGB_10
          SUBB  #7
MGB_10    ANDB  #15
          RTS

************
Mon_Dump_Row
************

* Input : X = start address

          PSHS  D
          LDB   #':'
          CALL  PUTC
          TFR   X,D
          TFR   A,B
          BSR   Mon_Show_Byte
          TFR   X,D
          BSR   Mon_Show_Byte
          LDE   #8
MDR_10    BSR   Mon_Blank
          LDB   ,X+
          BSR   Mon_Show_Byte
          DECE
          BNE   MDR_10

          BSR   Mon_Blank
          LDA   #8
          LEAX  -8,X
MDR_20    LDB   ,X+
          BMI   MDR_30
          CMPB  #' '
          BHS   MDR_40
MDR_30    LDB   #'.'
MDR_40    CALL  PUTC
          DECA
          BNE   MDR_20
          BSR   Mon_CRLF
          PULS  PC,D

*********
Mon_Blank
*********

          LDB   #' '
          JUMP  PUTC

********
Mon_CRLF
********

          LDB   #CR
          CALL  PUTC
          LDB   #LF
          JUMP  PUTC

*************
Mon_Show_Byte
*************

* Input : B = byte

          BSR   Mon_Byte_Hex
          CALL  PUTC
          TFR   A,B
          JUMP  PUTC

************
Mon_Byte_Hex
************

* Input : B = byte
* Output: A = low  nibble
*         B = high nibble

          TFR   B,A
          BSR   Mon_Nib_Hex
          EXG   A,B
          LSRB
          LSRB
          LSRB
          LSRB

***********
Mon_Nib_Hex
***********

          ANDB  #15
          CMPB  #10
          BLO   MoNH_10
          ADDB  #7
MoNH_10   ADDB  #'0'
          RTS

        FILL $fcf0-* (0)

*******
CHARGEN
*******

*       BITS  . . * . * . . .  ; $1c
*       BITS  . . . . . . . .
*       BITS  . . * * * . . .
*       BITS  . . . . . * . .
*       BITS  . . * * * . . .
*       BITS  . * . . . * . .
*       BITS  . . * * * . * .
*       BITS  . . . . . . . .

*       BITS  . . * . . * . .  ; $1d
*       BITS  . . . . . . . .
*       BITS  . . * * * * . .
*       BITS  . * . . . . * .
*       BITS  . * . . . . * .
*       BITS  . * . . . . * .
*       BITS  . . * * * * . .
*       BITS  . . . . . . . .

*       BITS  . . * . . * . .  ; $1e
*       BITS  . . . . . . . .
*       BITS  . * . . . . * .
*       BITS  . * . . . . * .
*       BITS  . * . . . . * .
*       BITS  . * . . . * * .
*       BITS  . . * * * . * .
*       BITS  . . . . . . . .

*       BITS  . . . . . . . .  ; $1f
*       BITS  . . * * * . . .
*       BITS  . * . . . * . .
*       BITS  . * . * * . . .
*       BITS  . * . . . * . .
*       BITS  . * . . . * . .
*       BITS  . * . . * . . .
*       BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $20
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $21
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $22
        BITS  . . . * . * . .
        BITS  . . * . * . . .
        BITS  . * . * . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $23
        BITS  . . * . * . . .
        BITS  . . * . * . . .
        BITS  * * * * * * * .
        BITS  . . * . * . . .
        BITS  * * * * * * * .
        BITS  . . * . * . . .
        BITS  . . * . * . . .

        BITS  . . . . . . . .  ; $24
        BITS  . . . * . . . .
        BITS  . * * * * * . .
        BITS  * . . * . . . .
        BITS  . * * * * * . .
        BITS  . . . * . . * .
        BITS  * * * * * * . .
        BITS  . . . * . . . .

        BITS  . . . . . . . .  ; $25
        BITS  . * * . . . * .
        BITS  . * * . . * . .
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . * . . * * .
        BITS  . * . . . * * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $26
        BITS  . . * * . . . .
        BITS  . * . . * . . .
        BITS  . . * * . . . .
        BITS  . * . . * . * .
        BITS  . * . . * * . .
        BITS  . . * * * . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $27
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $28
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . . * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $29
        BITS  . . . * . . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $2a
        BITS  . . . . . . . .
        BITS  . . . * . . . .
        BITS  . * . * . * . .
        BITS  . . * * * . . .
        BITS  . * . * . * . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $2b
        BITS  . . . . . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . * * * * * . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $2c
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . * * . .
        BITS  . . . . * * . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $2d
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . * * * * * . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $2e
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . * * . . .
        BITS  . . . * * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $2f
        BITS  . . . . . . * .
        BITS  . . . . . * . .
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . * . . . . .
        BITS  . * . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $30
        BITS  . . * * * * . .
        BITS  . * . . . * * .
        BITS  . * . . * . * .
        BITS  . * . * . . * .
        BITS  . * * . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $31
        BITS  . . . . * . . .
        BITS  . . . * * . . .
        BITS  . . * . * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $32
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . . . . . . * .
        BITS  . . * * * * . .
        BITS  . * . . . . . .
        BITS  . * * * * * * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $33
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . . . * * * . .
        BITS  . . . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $34
        BITS  . . . . . * . .
        BITS  . . . . * * . .
        BITS  . . . * . * . .
        BITS  . . * . . * . .
        BITS  . * * * * * * .
        BITS  . . . . . * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $35
        BITS  . * * * * * * .
        BITS  . * . . . . . .
        BITS  . * * * * * . .
        BITS  . . . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $36
        BITS  . . . * * * . .
        BITS  . . * . . . . .
        BITS  . * * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $37
        BITS  . * * * * * * .
        BITS  . . . . . * . .
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . * . . . . .
        BITS  . * . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $38
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $39
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * * .
        BITS  . . . . . * . .
        BITS  . . * * * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $3a
        BITS  . . . . . . . .
        BITS  . . . * * . . .
        BITS  . . . * * . . .
        BITS  . . . . . . . .
        BITS  . . . * * . . .
        BITS  . . . * * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $3b
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . * * . .
        BITS  . . . . * * . .
        BITS  . . . . . . . .
        BITS  . . . . * * . .
        BITS  . . . * . . . .

        BITS  . . . . . . . .  ; $3c
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . * . . . . .
        BITS  . . * . . . . .
        BITS  . . . * . . . .
        BITS  . . . . * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $3d
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . * * * * * * .
        BITS  . . . . . . . .
        BITS  . * * * * * * .
        BITS  . . . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $3e
        BITS  . . . * . . . .
        BITS  . . . . * . . .
        BITS  . . . . . * . .
        BITS  . . . . . * . .
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $3f
        BITS  . . . * * * . .
        BITS  . . * . . . * .
        BITS  . . . . . * . .
        BITS  . . . . * . . .
        BITS  . . . . . . . .
        BITS  . . . . * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $40
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . * * * * .
        BITS  . * . * . . * .
        BITS  . * . * * * . .
        BITS  . . * * * * * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $41
        BITS  . . . * * . . .
        BITS  . . * . . * . .
        BITS  . * . . . . * .
        BITS  . * * * * * * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $42
        BITS  . * * * * * . .
        BITS  . . * . . . * .
        BITS  . . * * * * . .
        BITS  . . * . . . * .
        BITS  . . * . . . * .
        BITS  . * * * * * * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $43
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $44
        BITS  . * * * * * . .
        BITS  . . * . . . * .
        BITS  . . * . . . * .
        BITS  . . * . . . * .
        BITS  . . * . . . * .
        BITS  . * * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $45
        BITS  . * * * * * * .
        BITS  . * . . . . . .
        BITS  . * * * * . . .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . * * * * * * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $46
        BITS  . * * * * * * .
        BITS  . * . . . . . .
        BITS  . * * * * . . .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $47
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . . .
        BITS  . * . . * * * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $48
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * * * * * * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $49
        BITS  . . * * * . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . * * * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $4a
        BITS  . . . . . . * .
        BITS  . . . . . . * .
        BITS  . . . . . . * .
        BITS  . . . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $4b
        BITS  . * . . . * . .
        BITS  . * . . * . . .
        BITS  . * * * . . . .
        BITS  . * . * . . . .
        BITS  . * . . * . . .
        BITS  . * . . . * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $4c
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . * * * * * * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $4d
        BITS  . * . . . . * .
        BITS  . * * . . * * .
        BITS  . * . * * . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $4e
        BITS  . * . . . . * .
        BITS  . * * . . . * .
        BITS  . * . * . . * .
        BITS  . * . . * . * .
        BITS  . * . . . * * .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $4f
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $50
        BITS  . * * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * * * * * . .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $51
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . * . * .
        BITS  . * . . . * . .
        BITS  . . * * * . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $52
        BITS  . * * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * * * * * . .
        BITS  . * . . . * . .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $53
        BITS  . . * * * * . .
        BITS  . * . . . . . .
        BITS  . . * * * * . .
        BITS  . . . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $54
        BITS  . * * * * * . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $55
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $56
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . * . . * . .
        BITS  . . * . . * . .
        BITS  . . . * * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $57
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . * * . * .
        BITS  . * * . . * * .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $58
        BITS  . * . . . . * .
        BITS  . . * . . * . .
        BITS  . . . * * . . .
        BITS  . . . * * . . .
        BITS  . . * . . * . .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $59
        BITS  . * . . . * . .
        BITS  . . * . * . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $5a
        BITS  . * * * * * * .
        BITS  . . . . . * . .
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . * . . . . .
        BITS  . * * * * * * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $5b
        BITS  . . * * * . . .
        BITS  . . * . . . . .
        BITS  . . * . . . . .
        BITS  . . * . . . . .
        BITS  . . * . . . . .
        BITS  . . * * * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $5c
        BITS  . * . . . . . .
        BITS  . . * . . . . .
        BITS  . . . * . . . .
        BITS  . . . . * . . .
        BITS  . . . . . * . .
        BITS  . . . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $5d
        BITS  . . . * * * . .
        BITS  . . . . . * . .
        BITS  . . . . . * . .
        BITS  . . . . . * . .
        BITS  . . . . . * . .
        BITS  . . . * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $5e
        BITS  . . . * . . . .
        BITS  . . * . * . . .
        BITS  . * . . . * . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $5f
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  * * * * * * * *

        BITS  . . . . . . . .  ; $60
        BITS  . . * * . . . .
        BITS  . . * * . . . .
        BITS  . . . * * . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $61
        BITS  . . . . . . . .
        BITS  . . * * * . . .
        BITS  . . . . . * . .
        BITS  . . * * * . . .
        BITS  . * . . . * . .
        BITS  . . * * * . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $62
        BITS  . * . . . . . .
        BITS  . * . * * * . .
        BITS  . * * . . . * .
        BITS  . * . . . . * .
        BITS  . * * . . . * .
        BITS  . * . * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $63
        BITS  . . . . . . . .
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . . .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $64
        BITS  . . . . . . * .
        BITS  . . * * * . * .
        BITS  . * . . . * * .
        BITS  . * . . . . * .
        BITS  . * . . . * * .
        BITS  . . * * * . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $65
        BITS  . . . . . . . .
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * * * * * * .
        BITS  . * . . . . . .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $66
        BITS  . . . . * * . .
        BITS  . . . * . . * .
        BITS  . . . * . . . .
        BITS  . * * * * * . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $67
        BITS  . . . . . . . .
        BITS  . . * * * * . .
        BITS  . * . . . * * .
        BITS  . * . . . * * .
        BITS  . . * * * . * .
        BITS  . . . . . . * .
        BITS  . . * * * * . .

        BITS  . . . . . . . .  ; $68
        BITS  . * . . . . . .
        BITS  . * . * * * . .
        BITS  . * * . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . * . . .  ; $69
        BITS  . . . . . . . .
        BITS  . . . * * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . * . .  ; $6a
        BITS  . . . . . . . .
        BITS  . . . . . * . .
        BITS  . . . . . * . .
        BITS  . . . . . * . .
        BITS  . . . . . * . .
        BITS  . * . . . * . .
        BITS  . . * * * . . .

        BITS  . . . . . . . .  ; $6b
        BITS  . . * . . . . .
        BITS  . . * . . . * .
        BITS  . . * . . * . .
        BITS  . . * . * . . .
        BITS  . . * * . * . .
        BITS  . . * . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $6c
        BITS  . . . * * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $6d
        BITS  . . . . . . . .
        BITS  * . * . . * . .
        BITS  * * . * * . * .
        BITS  * . . * . . * .
        BITS  * . . * . . * .
        BITS  * . . * . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $6e
        BITS  . . . . . . . .
        BITS  . * . . * * . .
        BITS  . . * * . . * .
        BITS  . . * . . . * .
        BITS  . . * . . . * .
        BITS  . . * . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $6f
        BITS  . . . . . . . .
        BITS  . . * * * * . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $70
        BITS  . . . . . . . .
        BITS  . * . * * * . .
        BITS  . * * . . . * .
        BITS  . * . . . . * .
        BITS  . * * . . . * .
        BITS  . * . * * * . .
        BITS  . * . . . . . .

        BITS  . . . . . . . .  ; $71
        BITS  . . . . . . . .
        BITS  . . * * * . * .
        BITS  . * . . . * * .
        BITS  . * . . . * * .
        BITS  . * . . . * * .
        BITS  . . * * * . * .
        BITS  . . . . . . * .

        BITS  . . . . . . . .  ; $72
        BITS  . . . . . . . .
        BITS  . * . * * * . .
        BITS  . * * . . . * .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . * . . . . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $73
        BITS  . . . . . . . .
        BITS  . . * * * * . .
        BITS  . * . . . . . .
        BITS  . . * * * * . .
        BITS  . . . . . . * .
        BITS  . * * * * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $74
        BITS  . . . * . . . .
        BITS  . . * * * . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . * .
        BITS  . . . . * * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $75
        BITS  . . . . . . . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . * * .
        BITS  . . * * * . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $76
        BITS  . . . . . . . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . . * . . * . .
        BITS  . . . * * . . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $77
        BITS  . . . . . . . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * . * * . * .
        BITS  . . * . . * . .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $78
        BITS  . . . . . . . .
        BITS  . * . . . . * .
        BITS  . . * . . * . .
        BITS  . . . * * . . .
        BITS  . . * . . * . .
        BITS  . * . . . . * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $79
        BITS  . . . . . . . .
        BITS  . * . . . . * .
        BITS  . * . . . . * .
        BITS  . * * . . * * .
        BITS  . . . * * . * .
        BITS  . * . . . . * .
        BITS  . . * * * * . .

        BITS  . . . . . . . .  ; $7a
        BITS  . . . . . . . .
        BITS  . * * * * * * .
        BITS  . . . . . * . .
        BITS  . . . * * . . .
        BITS  . . * . . . . .
        BITS  . * * * * * * .
        BITS  . . . . . . . .

        BITS  . . . . . . . .  ; $7b
        BITS  . . . . . * . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . . . * . . .
        BITS  . . . . * . . .
        BITS  . . . . . * . .

        BITS  . . . * . . . .  ; $7c
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .

        BITS  . . . . . . . .  ; $7d
        BITS  . . * . . . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . . . * . . .
        BITS  . . . * . . . .
        BITS  . . . * . . . .
        BITS  . . * . . . . .

        BITS  . . . . . . . .  ; $7e
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . * * . * * .
        BITS  . * * . * * . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .
        BITS  . . . . . . . .

        BITS  * * * * * * * *  ; $7f
        BITS  * * * * * * * *
        BITS  * * * * * * * *
        BITS  * * * * * * * *
        BITS  * * * * * * * *
        BITS  * * * * * * * *
        BITS  * * * * * * * *
        BITS  * * * * * * * *

        FILL   $fff0-* (0)

DIV0    FDB     TRAPMON       ; DIV 0 trap
        FDB     RTIPNT        ; SWI 3
        FDB     RTIPNT        ; SWI 2
        FDB     FIRQSB        ; FIRQ
        FDB     IRQSUB        ; IRQ
        FDB     SWI1SB        ; SWI
        FDB     RTIPNT        ; NMI
        FDB     DEPART        ; RESET

        END
