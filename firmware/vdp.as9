; ***** VDP-functions *****

; VDP_Init                ; *** initialize VDP ***
; VDP_On                  ; *** enable screen ***
; VDP_Off                 ; *** disable screen ***
; VDP_SetWindow           ; *** set window to E=TopRow, F=BottomRow
; VDP_ClearWindow         ; *** clear window
; VDP_SetBGColor          ; *** set background-color from A to register 7 + revers in 12
; VDP_SetColor            ; *** set text-color from A to register 7 + revers in 12
; VDP_ReadChar            ; *** return char at actual cursor position in A
; VDP_ReadLine            ; *** store line A in LINEBUF
; VDP_PutChar             ; *** puts char from A to screen at actual cursor position and moves cursor
; VDP_CursorRight         ; *** Move cursor right
; VDP_CursorLeft          ; *** Move cursor left
; VDP_CursorDown          ; *** Move cursor down
; VDP_CursorUp            ; *** Move cursor up
; VDP_ScrollUp            ; *** scroll screen up
; VDP_SetCursor           ; *** set cursor to E=X, F=Y
; VDP_CursorOff           ; *** set cursor attribute byte in color table
; VDP_CursorOn            ; *** set cursor attribute bit in color table
; VDP_Backspace           ; *** backspace
; VDP_Delete              ; *** delete character
; VDP_Insert              ; *** insert SPACE
; VDP_ReadStatus          ; *** read status register in A - return status in A

; ***** VDP-Definitions

PAL = 1                         ; PAL=1, NTSC=0   selects V9938/58 PAL RGB-output

PATTERNTABLE    = $1000         ; font memory in VRAM
COLORTABLE      = $0A00         ; color/attribute-table in VRAM
SCREENTABLE     = $0000         ; screen memory in VRAM

VDPREG1         = $10           ; VDP reg 1 value (mode bits M1+M2, screen disabled)
VDPREG9         = $80 | PAL*2   ; VDP reg 9 value ($80 = NTSC, $82 = PAL / 212 lines)
VDPREG18        = $0d           ; VDP reg 18 value (V/H screen adjust, $0d = Sony PVM 9")

VDPCOLOR        = 15            ; start color values
VDPBGCOLOR      = 1

COLUMNS         = 80            ; screen columns
ROWS            = 26            ; used lines

**************************************************************************
; VDP-Macros

VDPWAITC MACRO ARG      ; *** wait ARG cycles
        FILL ARG ($12)          ; each $12=nop needs 1/3 us @ 3MHz 6309/native mode
        ENDM

ADDD8   MACRO ARG       ; *** adds 8bit value/memory to D
        addb ARG                ; add low-byte
        adca #$00               ; add carry to high-byte
        ENDM

VDPSETREG MACRO ARG     ; *** set VDP Register ARG to A
        pshs cc                 ; safe flags
        orcc  #IRQFLAG|FIRQFLAG ; disable interrupts
        sta IO_VDPCONTROL       ; first writes data in A to control port #1
        nop                     ; adds 2 nops to reach 2us pause
        nop
        lda # ARG | $80         ; writes register no. with bit#7 = 1 to Port #1
        sta IO_VDPCONTROL
        puls cc                 ; restore flags
        ENDM

VDPWRITEADDRESS MACRO   ; *** set VDP write vram address-pointer to D
        pshs cc                 ; safe flags
        orcc #IRQFLAG|FIRQFLAG  ; disable interrupts
        stb IO_VDPCONTROL       ; write address low-byte
        nop                     ; adds 2 nops to reach 2us pause
        nop
        ora # $40               ; bit#6 = 1 write
        sta IO_VDPCONTROL       ; write address high-byte
        puls cc                 ; restore flags
        ENDM

VDPREADADDRESS MACRO    ; *** set VDP read vram address-pointer to D
        pshs cc                 ; safe flags
        orcc #IRQFLAG|FIRQFLAG  ; disable interrupts
        stb IO_VDPCONTROL       ; read address low-byte
        nop                     ; adds 2 nops to reach 2us pause
        nop
        nop 
        nop
        sta IO_VDPCONTROL       ; read address high-byte
        puls cc                 ; restore flags
        ENDM

; ***** VDP-Subroutines

VDP_Wait11c             ; *** wait 11 cycles (jsr=7c, rts=4c)
        rts

VDP_Init                ; *** initialize VDP ***
        clra
        VDPSETREG 17            ; write VDP regs fast indirect
        ldx #VDPINITDATA
VDPINIT lda ,x+
        jsr VDP_Wait11c         ; loop-write=13c + 11c wait
        sta IO_VDPINDIRECT
        cmpx #VDPINITDATAEND
        bne VDPINIT

        jsr VDP_Wait11c
        lda #VDPREG18
        VDPSETREG 18            ; set register 18 V/H display adjust L 7-1,0,f-8 R
                                ; * clear 16kB VRAM
        jsr VDP_Wait11c
        clrd
        VDPWRITEADDRESS         ; set VRAM write address to D = $0000, Bank Reg already $00
        ldw #$4000              ; set counter W to $4000
VDPCLRR jsr VDP_Wait11c         ; loop-write=8c + 11c wait - >5us is OK
        stb IO_VDPRAM           ; B = VRAM init value = $00
        decw
        bne VDPCLRR
        jsr VDP_Wait11c
        clra
        VDPSETREG 14            ; set VRAM bank reg back to 0
                                ; * copy font to pattern generator table
        jsr VDP_Wait11c
        ldd #PATTERNTABLE
        VDPWRITEADDRESS         ; set VRAM write address to D = Patterntable
        ldx #VDPFONTDATA
VDPLFNT lda ,x+
        jsr VDP_Wait11c         ; loop-write=13c + 11c wait
        sta IO_VDPRAM
        cmpx #VDPFONTDATA+VDPFONTSIZE
        bne VDPLFNT
                                ; * load color palette
        jsr VDP_Wait11c
        clra
        VDPSETREG 16
        ldx #VDPPALETTEDATA
VDPLPAL lda ,x+                 ; load palette-color to write
        jsr VDP_Wait11c         ; loop-write=13c + 11c wait
        sta IO_VDPPALETTE       ; write to palette register
        cmpx #VDPPALETTEDATAEND
        bne VDPLPAL

        jsr VDP_Wait11c
        ldd #SCREENTABLE
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        ldw #(ROWS+1)*COLUMNS
        lda #'#'                ; fill with SPACE
VDPCLRS jsr VDP_Wait11c         ; loop-write=8c + 11c wait
        VDPWAITC 5              ; add. 5c for 8us
        sta IO_VDPRAM
        decw
        bne VDPCLRS

        lda #0
        sta BIOS_CursorX        ; initialize zeropage variables
        sta BIOS_CursorY
        sta BIOS_RowTop
        lda #ROWS-1
        sta BIOS_RowBottom
        lda #COLUMNS
        sta BIOS_Columns
        lda #VDPCOLOR
        sta BIOS_Color
        lda #VDPBGCOLOR
        sta BIOS_BGColor
        rts

VDP_On                  ; *** enable screen ***
        lda #VDPREG1 | $40      ; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
        VDPSETREG 1
        rts

VDP_Off                 ; *** disable screen ***
        lda #VDPREG1 & $bf      ; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
        VDPSETREG 1
        rts

VDP_SetWindow           ; *** set window to E=TopRow, F=BottomRow
        ste BIOS_RowTop
        stf BIOS_RowBottom
        rts

VDP_ClearWindow         ; *** clear window
        jsr VDP_CursorOff
        lda BIOS_RowTop         ; load windows top row
        ldb BIOS_Columns        ; load columns
        mul                     ; calc screen position
        addd #SCREENTABLE       ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        lda BIOS_RowBottom      ; load window bottom row
        adda #1                 ; add one line to bottom
        suba BIOS_RowTop        ; calc lines to clear (Carry flag already 0 from adda)
        ldb BIOS_Columns
        mul                     ; calc bytes to clear
        lde #' '                ; fill with SPACE
VDPCLRW jsr VDP_Wait11c
        VDPWAITC 4              ; add 4c to get 8us
        ste IO_VDPRAM
        decd
        bne VDPCLRW
        sta BIOS_CursorX        ; set cursor to column 0 (A is already 0 from decd)
        lda BIOS_RowTop
        sta BIOS_CursorY        ; set cursor to window top line
        jsr VDP_CursorOn
        rts

VDP_SetBGColor          ; *** set background-color from A to register 7 + revers in 12
        sta BIOS_BGColor
        lda BIOS_Color
        bra VDPSCOL

VDP_SetColor            ; *** set text-color from A to register 7 + revers in 12
        sta BIOS_Color          ; store new textcolor
VDPSCOL lsla                    ; shift to high nibble
        lsla
        lsla
        lsla
        ora BIOS_BGColor        ; add bg color variable
        VDPSETREG 7             ; set color register
        lda BIOS_BGColor
        lsla
        lsla
        lsla
        lsla
        ora BIOS_Color
        jsr VDP_Wait11c
        VDPSETREG 12
        rts

VDP_ReadChar            ; *** return at actual cursor position in A
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        jsr VDP_Wait11c
        VDPWAITC 6              ; add 6c to get 8us
        lda IO_VDPRAM
        rts

VDP_ReadLine            ; *** store line A in LINEBUF
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        addd #SCREENTABLE       ; add VRAM position
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        ldy #LINEBUF            ; load buffer address in Y
        ldb BIOS_Columns        ; load columns in x-counter
VDPREAD jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda IO_VDPRAM           ; read char
        sta ,y+                 ; write to buffer
        decb                    ; dec x-counter
        bne VDPREAD             ; read next char
        rts

VDP_ScrollUp            ; *** scroll screen up
        lde BIOS_RowTop         ; load top row as line counter in E
        cmpe BIOS_RowBottom     ; check lines to scroll?
        beq VDPSCRN             ; skip scrolling if only one line to scroll
        tfr e,a                 ; copy toprow to A for calc
        ldb BIOS_Columns
        mul                     ; calc line position
        addd #SCREENTABLE       ; calc target line screen address
        tfr d,x                 ; copy target address to X
VDPSCRL ADDD8 BIOS_Columns      ; add columns for source address
        VDPREADADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb BIOS_Columns        ; load columns in x-counter
VDPSCRS jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda IO_VDPRAM           ; load from VRAM
        sta ,y+                 ; write to buffer
        decb
        bne VDPSCRS             ; end of line? 
        tfr x,d                 ; move stored target address to D    
        VDPWRITEADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb BIOS_Columns        ; load columns in x-counter
VDPSCRT jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda ,y+
        sta IO_VDPRAM
        decb
        bne VDPSCRT
        ince                    ; next row
        cmpe BIOS_RowBottom
        beq VDPSCRN             ; last row - finished scrolling
        tfr x,d                 ; copy last target address to D
        ADDD8 BIOS_Columns      ; add columns
        tfr d,x                 ; copy next traget address to X
        bra VDPSCRL             ; scroll netxt line
VDPSCRN lda BIOS_RowBottom      ; bottom row lÃ¶schen
        ldb BIOS_Columns
        mul
        addd #SCREENTABLE       ; calc screen address
        VDPWRITEADDRESS
        ldb BIOS_Columns        ; load columns in x-counter
        lda #' '                ; clear line with SPACE
VDPSCRC jsr VDP_Wait11c
        VDPWAITC 6              ; 7c + 11c +6c = 8us
        sta IO_VDPRAM
        decb
        bne VDPSCRC
        rts 

VDP_PutChar             ; *** puts char from A to screen at actual cursor position and moves cursor
        tfr a,e                 ; safe char in E 
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        jsr VDP_Wait11c
        VDPWAITC 5              ; add 5c to get 8us
        ste IO_VDPRAM
VDP_CursorRight         ; *** Move cursor right
        bsr VDP_CursorOff
        lda BIOS_CursorX
        inca                    ; move right
        cmpa BIOS_Columns       ; end of line ?
        bne VDPCRSR             ; not column end ?
        lda BIOS_CursorY
        cmpa BIOS_RowBottom     ; reached window bottom row ?
        bne VDPCRRS             ; no scroll neccessary
        jsr VDP_ScrollUp
        bra VDPCRRE
VDPCRRS inca 
        sta BIOS_CursorY
VDPCRRE clra
VDPCRSR sta BIOS_CursorX
        bsr VDP_CursorOn
        rts

VDP_CursorDown          ; *** Move cursor down
        lda BIOS_CursorY
        cmpa BIOS_RowBottom     ; reached window bottom row ?
        bne VDPCRSD
        jsr VDP_ScrollUp        ; scroll up
        rts
VDPCRSD bsr VDP_CursorOff
        inca
        sta BIOS_CursorY        ; move down
        bsr VDP_CursorOn
        rts

VDP_CursorUp            ; *** Move cursor up
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; reached window top row ?
        beq VDPCRSU
        bsr VDP_CursorOff
        deca
        sta BIOS_CursorY        ; move up
        bsr VDP_CursorOn
VDPCRSU rts

VDP_SetCursor           ; *** set cursor to E=X, F=Y
        bsr VDP_CursorOff
        ste BIOS_CursorX
        stf BIOS_CursorY
        bsr VDP_CursorOn
        rts

VDP_CursorOff            ; *** set cursor attribute byte in color table
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        lsrd                    ; divide by 8 to calc color/attribute-table position
        lsrd
        lsrd
        addd #COLORTABLE        ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Colortable
        jsr VDP_Wait11c
        clra
        sta IO_VDPRAM
        rts

VDP_CursorOn            ; *** set cursor attribute bit in color table
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        tfr b,e                 ; safe low byte of screen position in E
        lsrd                    ; divide by 8 to calc color/attribute-table position
        lsrd
        lsrd
        addd #COLORTABLE        ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Colortable
        tfr e,b                 ; restore low byte
        andb #$07               ; isolate byte position
        clra
        tfr d,x
        lda REVERSETABLE,x      ; load bit for screen position
        VDPWAITC 8
        sta IO_VDPRAM
        rts
REVERSETABLE    FCB $80,$40,$20,$10,$08,$04,$02,$01

VDP_CursorLeft          ; *** Move cursor left
        bsr VDP_CursorOff
        lda BIOS_CursorX
        bne VDPCRSL             ; not column 0 ?
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; reached window top row ?
        beq VDPCRLE
        deca                    ; move one row up
        sta BIOS_CursorY
        lda BIOS_Columns
VDPCRSL deca                    ; move left
        sta BIOS_CursorX
VDPCRLE bsr VDP_CursorOn
        rts

VDP_Backspace              ; *** backspace
        bsr VDP_CursorLeft
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; check if window top row    
        bne VDP_Delete
        lda BIOS_CursorX        ; check if first char in window
        bne VDP_Delete
        rts                     ; no delete possible in uper left corner !

VDP_Delete              ; *** delete character
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        tfr d,x                 ; safe write address in X
        lde BIOS_CursorX        ; Load Cursor column
        ince                    ; add 1 because last col is 79 and columns is 80 !
        cmpe BIOS_Columns       ; check if last char in line
        beq VDPDELN             ; skip srolling
        incd                    ; calc read address
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        tfr e,b                 ; move x-counter to B
        ldy #LINEBUF            ; load buffer address in Y
VDPDELR jsr VDP_Wait11c
        lda IO_VDPRAM           ; load char
        sta ,y+                 ; write char to buffer
        incb
        cmpb BIOS_Columns       ; check reached end of line ?
        bne VDPDELR             ; read next char
        tfr x,d                 ; restore write address
        VDPWRITEADDRESS
        tfr e,b                 ; move x-counter to B
        ldy #LINEBUF            ; load buffer address in Y
VDPDELW jsr VDP_Wait11c
        lda ,y+                 ; read char from buffer
        sta IO_VDPRAM           ; write char
        incb
        cmpb BIOS_Columns       ; check reached end of chars in buffer ?
        bne VDPDELW             ; write  next char
VDPDELS lda #' '                ; fill last char in line with SPACE
        jsr VDP_Wait11c
        VDPWAITC 1              ; add 1c to get 8us minimum
        sta IO_VDPRAM           ; write char
        rts
VDPDELN VDPWRITEADDRESS
        bra VDPDELS             ; clear last char in line   

VDP_Insert              ; *** insert character
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        tfr d,x                 ; safe read address in X
        lde BIOS_CursorX        ; Load Cursor column
        ince                    ; add 1 because last col is 79 and columns is 80 !
        cmpe BIOS_Columns       ; check if last char in line
        beq VDPINSN             ; skip srolling
        dece                    ; restore cursor column
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        tfr e,b                 ; move x-counter to B
        ldy #LINEBUF            ; load buffer address in Y
VDPINSR jsr VDP_Wait11c
        lda IO_VDPRAM           ; load char
        sta ,y+                 ; write char to buffer
        incb
        cmpb BIOS_Columns       ; check reached end of line ?
        bne VDPINSR             ; read next char
        tfr x,d                 ; restore read address
        incd                    ; add 1 to get write address
        VDPWRITEADDRESS
        tfr e,b                 ; move x-counter to B
        ldy #LINEBUF             ; load buffer address in Y
VDPINSW jsr VDP_Wait11c
        lda ,y+                 ; read char from buffer
        sta IO_VDPRAM           ; write char
        incb
        cmpb BIOS_Columns       ; check reached end of chars in buffer ?
        bne VDPINSW             ; write  next char
        tfr x,d                 ; restore write address - cursor position
        VDPWAITC 6              ; add 6c to get 8us
VDPINSN VDPWRITEADDRESS
        lda #' '                ; fill last char in line with SPACE
        jsr VDP_Wait11c
        VDPWAITC 4              ; add 4c to get 8us minimum
        sta IO_VDPRAM           ; write char
        rts

VDP_ReadStatus          ; *** read status register in A - return status in A
        lda #1
        VDPSETREG 15            ; reg 15 = 1 initiates read status-reg 1
        jsr VDP_Wait11c
        VDPWAITC 6              ; 18c+6c = wait 8 us total for VPD
        lda IO_VDPSTATUS        ; read status
        rts

**************************************************************************
; vdp-tables
VDPINITDATA                         ; ***** VDP init data table *****
        FCB $04,VDPREG1,$03,$2f,$02,$3f,$03,VDPCOLOR*16+VDPBGCOLOR
        FCB $08,VDPREG9,$00,$00,VDPBGCOLOR*16+VDPCOLOR,$f0,$00
        ; reg  0: $04 mode control 1: text mode 2 (bit#1-3 = M3 - M5)
        ; reg  1: $10 mode control 2: bit#1 16x16 sprites, bit#3-4 = M2-M1, #6 =1: display enable)
        ; reg  2: $03 name (screen) table base address $0000 ( * $400 + bit#0+1 = 1)
        ; reg  3: $2f color table base address $0A00 ( * $40 + bit#0-2 = 1)
        ; reg  4: $02 pattern (character) generator table base address $1000 (* $800)
        ; reg  5: $3f sprite attribute table base address $1e00 (* $80 - bit#0+1 = 1)
        ; reg  6: $03 sprite pattern (data) generator base address = $1800 (* $800)
        ; reg  7: $10 text/overscan-backdrop color 
        ; reg  8: $08 bit#3 = 1: 64k VRAM chips, bit#1 = 0 sprites disable, bit#5 0=transparent
        ; reg  9: $80 bit#1 = NTSC/PAL, #2 = EVEN/ODD, #3 = interlace, #7 = 192/212 lines
        ; reg 10: $00 color table base address $0000 bit#0-2 = A14-A16
        ; reg 11: $00 sprite attribute table base address bit#0-1 = A15-A16
        ; reg 12: $20 text/background blink color
        ; reg 13: $f0 blink periods ON/OFF - f0 = blinking off
        ; reg 14: $00 VRAM write addresss bit#0-2 = A14-A16
        ; reg 16: $00 color palette pointer to color 0
VDPINITDATAEND

VDPPALETTEDATA ; ***** Color Palette - 16 colors, 2 byte/color RB, 0G each 3bit -> CGA-colors *****
        FCB $00,$00,$05,$00,$00,$05,$05,$05 ;   0=black     1=blue      2=green       3=cyan
        FCB $50,$00,$55,$00,$50,$03,$55,$05 ;   4=red       5=magenta   6=brown       7=lightgrey
        FCB $33,$03,$37,$03,$33,$07,$37,$07 ;   8=grey      9=lightblue a=lightgreen  b=lightcyan
        FCB $73,$03,$77,$03,$73,$07,$77,$07 ;   c=lightred  d=ltmagenta e=yellow      f=white
VDPPALETTEDATAEND
        FCB 0                   ; only to get last label !
**************************************************************************